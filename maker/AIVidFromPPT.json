{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-3ZrOk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "context",
            "id": "APIRequest-MteaQ",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-3ZrOk{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-3ZrOk≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRequest-MteaQ{≈ìfieldName≈ì:≈ìcontext≈ì,≈ìid≈ì:≈ìAPIRequest-MteaQ≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "ParserComponent-3ZrOk",
        "sourceHandle": "{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-3ZrOk≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRequest-MteaQ",
        "targetHandle": "{≈ìfieldName≈ì:≈ìcontext≈ì,≈ìid≈ì:≈ìAPIRequest-MteaQ≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "APIRequest",
            "id": "APIRequest-MteaQ",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-f2gGq",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__APIRequest-MteaQ{≈ìdataType≈ì:≈ìAPIRequest≈ì,≈ìid≈ì:≈ìAPIRequest-MteaQ≈ì,≈ìname≈ì:≈ìdata≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-ParserComponent-f2gGq{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-f2gGq≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}",
        "selected": false,
        "source": "APIRequest-MteaQ",
        "sourceHandle": "{≈ìdataType≈ì:≈ìAPIRequest≈ì,≈ìid≈ì:≈ìAPIRequest-MteaQ≈ì,≈ìname≈ì:≈ìdata≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}",
        "target": "ParserComponent-f2gGq",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-f2gGq≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JsonFormatter",
            "id": "ParserComponent-O6keT",
            "name": "formatted_output",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-3ZrOk",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ParserComponent-O6keT{≈ìdataType≈ì:≈ìJsonFormatter≈ì,≈ìid≈ì:≈ìParserComponent-O6keT≈ì,≈ìname≈ì:≈ìformatted_output≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-ParserComponent-3ZrOk{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-3ZrOk≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}",
        "selected": false,
        "source": "ParserComponent-O6keT",
        "sourceHandle": "{≈ìdataType≈ì:≈ìJsonFormatter≈ì,≈ìid≈ì:≈ìParserComponent-O6keT≈ì,≈ìname≈ì:≈ìformatted_output≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}",
        "target": "ParserComponent-3ZrOk",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-3ZrOk≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-f2gGq",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "context",
            "id": "APIRequest-ffu1F",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-f2gGq{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-f2gGq≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRequest-ffu1F{≈ìfieldName≈ì:≈ìcontext≈ì,≈ìid≈ì:≈ìAPIRequest-ffu1F≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "ParserComponent-f2gGq",
        "sourceHandle": "{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-f2gGq≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRequest-ffu1F",
        "targetHandle": "{≈ìfieldName≈ì:≈ìcontext≈ì,≈ìid≈ì:≈ìAPIRequest-ffu1F≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "APIRequest",
            "id": "APIRequest-ffu1F",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-A9PXP",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__APIRequest-ffu1F{≈ìdataType≈ì:≈ìAPIRequest≈ì,≈ìid≈ì:≈ìAPIRequest-ffu1F≈ì,≈ìname≈ì:≈ìdata≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-ParserComponent-A9PXP{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-A9PXP≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}",
        "selected": false,
        "source": "APIRequest-ffu1F",
        "sourceHandle": "{≈ìdataType≈ì:≈ìAPIRequest≈ì,≈ìid≈ì:≈ìAPIRequest-ffu1F≈ì,≈ìname≈ì:≈ìdata≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}",
        "target": "ParserComponent-A9PXP",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-A9PXP≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "HttpFilePoster",
            "id": "HttpFilePoster-P1BCq",
            "name": "images",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data",
            "id": "LoopComponent-93yXb",
            "inputTypes": [
              "Data",
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-HttpFilePoster-P1BCq{≈ìdataType≈ì:≈ìHttpFilePoster≈ì,≈ìid≈ì:≈ìHttpFilePoster-P1BCq≈ì,≈ìname≈ì:≈ìimages≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-LoopComponent-93yXb{≈ìfieldName≈ì:≈ìdata≈ì,≈ìid≈ì:≈ìLoopComponent-93yXb≈ì,≈ìinputTypes≈ì:[≈ìData≈ì,≈ìDataFrame≈ì],≈ìtype≈ì:≈ìother≈ì}",
        "selected": false,
        "source": "HttpFilePoster-P1BCq",
        "sourceHandle": "{≈ìdataType≈ì:≈ìHttpFilePoster≈ì,≈ìid≈ì:≈ìHttpFilePoster-P1BCq≈ì,≈ìname≈ì:≈ìimages≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}",
        "target": "LoopComponent-93yXb",
        "targetHandle": "{≈ìfieldName≈ì:≈ìdata≈ì,≈ìid≈ì:≈ìLoopComponent-93yXb≈ì,≈ìinputTypes≈ì:[≈ìData≈ì,≈ìDataFrame≈ì],≈ìtype≈ì:≈ìother≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LoopComponent",
            "id": "LoopComponent-93yXb",
            "name": "item",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-RuSjk",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-LoopComponent-93yXb{≈ìdataType≈ì:≈ìLoopComponent≈ì,≈ìid≈ì:≈ìLoopComponent-93yXb≈ì,≈ìname≈ì:≈ìitem≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-ParserComponent-RuSjk{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-RuSjk≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}",
        "selected": false,
        "source": "LoopComponent-93yXb",
        "sourceHandle": "{≈ìdataType≈ì:≈ìLoopComponent≈ì,≈ìid≈ì:≈ìLoopComponent-93yXb≈ì,≈ìname≈ì:≈ìitem≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}",
        "target": "ParserComponent-RuSjk",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-RuSjk≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "APIRequest",
            "id": "APIRequest-yuDNo",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "dataType": "LoopComponent",
            "id": "LoopComponent-93yXb",
            "name": "item",
            "output_types": [
              "Data"
            ]
          }
        },
        "id": "reactflow__edge-APIRequest-yuDNo{≈ìdataType≈ì:≈ìAPIRequest≈ì,≈ìid≈ì:≈ìAPIRequest-yuDNo≈ì,≈ìname≈ì:≈ìdata≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-LoopComponent-93yXb{≈ìdataType≈ì:≈ìLoopComponent≈ì,≈ìid≈ì:≈ìLoopComponent-93yXb≈ì,≈ìname≈ì:≈ìitem≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}",
        "selected": false,
        "source": "APIRequest-yuDNo",
        "sourceHandle": "{≈ìdataType≈ì:≈ìAPIRequest≈ì,≈ìid≈ì:≈ìAPIRequest-yuDNo≈ì,≈ìname≈ì:≈ìdata≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}",
        "target": "LoopComponent-93yXb",
        "targetHandle": "{≈ìdataType≈ì:≈ìLoopComponent≈ì,≈ìid≈ì:≈ìLoopComponent-93yXb≈ì,≈ìname≈ì:≈ìitem≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LoopComponent",
            "id": "LoopComponent-93yXb",
            "name": "done",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "TypeConverterComponent-bQpta",
            "inputTypes": [
              "Message",
              "Data",
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-LoopComponent-93yXb{≈ìdataType≈ì:≈ìLoopComponent≈ì,≈ìid≈ì:≈ìLoopComponent-93yXb≈ì,≈ìname≈ì:≈ìdone≈ì,≈ìoutput_types≈ì:[≈ìDataFrame≈ì]}-TypeConverterComponent-bQpta{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìTypeConverterComponent-bQpta≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì,≈ìData≈ì,≈ìDataFrame≈ì],≈ìtype≈ì:≈ìother≈ì}",
        "selected": false,
        "source": "LoopComponent-93yXb",
        "sourceHandle": "{≈ìdataType≈ì:≈ìLoopComponent≈ì,≈ìid≈ì:≈ìLoopComponent-93yXb≈ì,≈ìname≈ì:≈ìdone≈ì,≈ìoutput_types≈ì:[≈ìDataFrame≈ì]}",
        "target": "TypeConverterComponent-bQpta",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìTypeConverterComponent-bQpta≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì,≈ìData≈ì,≈ìDataFrame≈ì],≈ìtype≈ì:≈ìother≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TypeConverterComponent",
            "id": "TypeConverterComponent-bQpta",
            "name": "data_output",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-NR60l",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-TypeConverterComponent-bQpta{≈ìdataType≈ì:≈ìTypeConverterComponent≈ì,≈ìid≈ì:≈ìTypeConverterComponent-bQpta≈ì,≈ìname≈ì:≈ìdata_output≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-ParserComponent-NR60l{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-NR60l≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}",
        "selected": false,
        "source": "TypeConverterComponent-bQpta",
        "sourceHandle": "{≈ìdataType≈ì:≈ìTypeConverterComponent≈ì,≈ìid≈ì:≈ìTypeConverterComponent-bQpta≈ì,≈ìname≈ì:≈ìdata_output≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}",
        "target": "ParserComponent-NR60l",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-NR60l≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-NR60l",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "LanguageModelComponent-vkYKd",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-ParserComponent-NR60l{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-NR60l≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-LanguageModelComponent-vkYKd{≈ìfieldName≈ì:≈ìinput_value≈ì,≈ìid≈ì:≈ìLanguageModelComponent-vkYKd≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "ParserComponent-NR60l",
        "sourceHandle": "{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-NR60l≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "LanguageModelComponent-vkYKd",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_value≈ì,≈ìid≈ì:≈ìLanguageModelComponent-vkYKd≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "APIRequest",
            "id": "APIRequest-B5UnD",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-4MaHk",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-APIRequest-B5UnD{≈ìdataType≈ì:≈ìAPIRequest≈ì,≈ìid≈ì:≈ìAPIRequest-B5UnD≈ì,≈ìname≈ì:≈ìdata≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-ParserComponent-4MaHk{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-4MaHk≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}",
        "selected": false,
        "source": "APIRequest-B5UnD",
        "sourceHandle": "{≈ìdataType≈ì:≈ìAPIRequest≈ì,≈ìid≈ì:≈ìAPIRequest-B5UnD≈ì,≈ìname≈ì:≈ìdata≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}",
        "target": "ParserComponent-4MaHk",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-4MaHk≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-4MaHk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "JsonFormatter-UQUk3",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-ParserComponent-4MaHk{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-4MaHk≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-JsonFormatter-UQUk3{≈ìfieldName≈ì:≈ìinput_value≈ì,≈ìid≈ì:≈ìJsonFormatter-UQUk3≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "ParserComponent-4MaHk",
        "sourceHandle": "{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-4MaHk≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "JsonFormatter-UQUk3",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_value≈ì,≈ìid≈ì:≈ìJsonFormatter-UQUk3≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LanguageModelComponent",
            "id": "LanguageModelComponent-6o3Gn",
            "name": "response_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ParserComponent-O6keT",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__LanguageModelComponent-6o3Gn{≈ìdataType≈ì:≈ìLanguageModelComponent≈ì,≈ìid≈ì:≈ìLanguageModelComponent-6o3Gn≈ì,≈ìname≈ì:≈ìresponse_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-ParserComponent-O6keT{≈ìfieldName≈ì:≈ìinput_value≈ì,≈ìid≈ì:≈ìParserComponent-O6keT≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "LanguageModelComponent-6o3Gn",
        "sourceHandle": "{≈ìdataType≈ì:≈ìLanguageModelComponent≈ì,≈ìid≈ì:≈ìLanguageModelComponent-6o3Gn≈ì,≈ìname≈ì:≈ìresponse_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "ParserComponent-O6keT",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_value≈ì,≈ìid≈ì:≈ìParserComponent-O6keT≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-A9PXP",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "context",
            "id": "APIRequest-yuDNo",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-A9PXP{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-A9PXP≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRequest-yuDNo{≈ìfieldName≈ì:≈ìcontext≈ì,≈ìid≈ì:≈ìAPIRequest-yuDNo≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "ParserComponent-A9PXP",
        "sourceHandle": "{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-A9PXP≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRequest-yuDNo",
        "targetHandle": "{≈ìfieldName≈ì:≈ìcontext≈ì,≈ìid≈ì:≈ìAPIRequest-yuDNo≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JsonFormatter",
            "id": "JsonFormatter-UQUk3",
            "name": "formatted_output",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "json_connection",
            "id": "APIRequest-J2FTE",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__JsonFormatter-UQUk3{≈ìdataType≈ì:≈ìJsonFormatter≈ì,≈ìid≈ì:≈ìJsonFormatter-UQUk3≈ì,≈ìname≈ì:≈ìformatted_output≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-APIRequest-J2FTE{≈ìfieldName≈ì:≈ìjson_connection≈ì,≈ìid≈ì:≈ìAPIRequest-J2FTE≈ì,≈ìinputTypes≈ì:[≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}",
        "selected": false,
        "source": "JsonFormatter-UQUk3",
        "sourceHandle": "{≈ìdataType≈ì:≈ìJsonFormatter≈ì,≈ìid≈ì:≈ìJsonFormatter-UQUk3≈ì,≈ìname≈ì:≈ìformatted_output≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}",
        "target": "APIRequest-J2FTE",
        "targetHandle": "{≈ìfieldName≈ì:≈ìjson_connection≈ì,≈ìid≈ì:≈ìAPIRequest-J2FTE≈ì,≈ìinputTypes≈ì:[≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-RuSjk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "image_url",
            "id": "LanguageModelComponent-6o3Gn",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-RuSjk{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-RuSjk≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-LanguageModelComponent-6o3Gn{≈ìfieldName≈ì:≈ìimage_url≈ì,≈ìid≈ì:≈ìLanguageModelComponent-6o3Gn≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "ParserComponent-RuSjk",
        "sourceHandle": "{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-RuSjk≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "LanguageModelComponent-6o3Gn",
        "targetHandle": "{≈ìfieldName≈ì:≈ìimage_url≈ì,≈ìid≈ì:≈ìLanguageModelComponent-6o3Gn≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-RuSjk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "TypeConverterComponent-rttuM",
            "inputTypes": [
              "Message",
              "Data",
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ParserComponent-RuSjk{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-RuSjk≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-TypeConverterComponent-rttuM{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìTypeConverterComponent-rttuM≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì,≈ìData≈ì,≈ìDataFrame≈ì],≈ìtype≈ì:≈ìother≈ì}",
        "selected": false,
        "source": "ParserComponent-RuSjk",
        "sourceHandle": "{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-RuSjk≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "TypeConverterComponent-rttuM",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìTypeConverterComponent-rttuM≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì,≈ìData≈ì,≈ìDataFrame≈ì],≈ìtype≈ì:≈ìother≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-XNusb",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "system_message",
            "id": "LanguageModelComponent-6o3Gn",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-XNusb{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-XNusb≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-LanguageModelComponent-6o3Gn{≈ìfieldName≈ì:≈ìsystem_message≈ì,≈ìid≈ì:≈ìLanguageModelComponent-6o3Gn≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "ParserComponent-XNusb",
        "sourceHandle": "{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-XNusb≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "LanguageModelComponent-6o3Gn",
        "targetHandle": "{≈ìfieldName≈ì:≈ìsystem_message≈ì,≈ìid≈ì:≈ìLanguageModelComponent-6o3Gn≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "APIRouteManager",
            "id": "APIRouteManager-qHxWw",
            "name": "url_1",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "post_url",
            "id": "HttpFilePoster-P1BCq",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__APIRouteManager-qHxWw{≈ìdataType≈ì:≈ìAPIRouteManager≈ì,≈ìid≈ì:≈ìAPIRouteManager-qHxWw≈ì,≈ìname≈ì:≈ìurl_1≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-HttpFilePoster-P1BCq{≈ìfieldName≈ì:≈ìpost_url≈ì,≈ìid≈ì:≈ìHttpFilePoster-P1BCq≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "APIRouteManager-qHxWw",
        "sourceHandle": "{≈ìdataType≈ì:≈ìAPIRouteManager≈ì,≈ìid≈ì:≈ìAPIRouteManager-qHxWw≈ì,≈ìname≈ì:≈ìurl_1≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "HttpFilePoster-P1BCq",
        "targetHandle": "{≈ìfieldName≈ì:≈ìpost_url≈ì,≈ìid≈ì:≈ìHttpFilePoster-P1BCq≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "APIRouteManager",
            "id": "APIRouteManager-26dEs",
            "name": "url_3",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "url_input",
            "id": "APIRequest-MteaQ",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__APIRouteManager-26dEs{≈ìdataType≈ì:≈ìAPIRouteManager≈ì,≈ìid≈ì:≈ìAPIRouteManager-26dEs≈ì,≈ìname≈ì:≈ìurl_3≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRequest-MteaQ{≈ìfieldName≈ì:≈ìurl_input≈ì,≈ìid≈ì:≈ìAPIRequest-MteaQ≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "APIRouteManager-26dEs",
        "sourceHandle": "{≈ìdataType≈ì:≈ìAPIRouteManager≈ì,≈ìid≈ì:≈ìAPIRouteManager-26dEs≈ì,≈ìname≈ì:≈ìurl_3≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRequest-MteaQ",
        "targetHandle": "{≈ìfieldName≈ì:≈ìurl_input≈ì,≈ìid≈ì:≈ìAPIRequest-MteaQ≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "APIRouteManager",
            "id": "APIRouteManager-45oOD",
            "name": "url_4",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "url_input",
            "id": "APIRequest-ffu1F",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__APIRouteManager-45oOD{≈ìdataType≈ì:≈ìAPIRouteManager≈ì,≈ìid≈ì:≈ìAPIRouteManager-45oOD≈ì,≈ìname≈ì:≈ìurl_4≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRequest-ffu1F{≈ìfieldName≈ì:≈ìurl_input≈ì,≈ìid≈ì:≈ìAPIRequest-ffu1F≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "APIRouteManager-45oOD",
        "sourceHandle": "{≈ìdataType≈ì:≈ìAPIRouteManager≈ì,≈ìid≈ì:≈ìAPIRouteManager-45oOD≈ì,≈ìname≈ì:≈ìurl_4≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRequest-ffu1F",
        "targetHandle": "{≈ìfieldName≈ì:≈ìurl_input≈ì,≈ìid≈ì:≈ìAPIRequest-ffu1F≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "APIRouteManager",
            "id": "ParserComponent-jnWWE",
            "name": "url_5",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "url_input",
            "id": "APIRequest-yuDNo",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jnWWE{≈ìdataType≈ì:≈ìAPIRouteManager≈ì,≈ìid≈ì:≈ìParserComponent-jnWWE≈ì,≈ìname≈ì:≈ìurl_5≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRequest-yuDNo{≈ìfieldName≈ì:≈ìurl_input≈ì,≈ìid≈ì:≈ìAPIRequest-yuDNo≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "ParserComponent-jnWWE",
        "sourceHandle": "{≈ìdataType≈ì:≈ìAPIRouteManager≈ì,≈ìid≈ì:≈ìParserComponent-jnWWE≈ì,≈ìname≈ì:≈ìurl_5≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRequest-yuDNo",
        "targetHandle": "{≈ìfieldName≈ì:≈ìurl_input≈ì,≈ìid≈ì:≈ìAPIRequest-yuDNo≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-VZz3F",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "domain",
            "id": "APIRouteManager-qHxWw",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-VZz3F{≈ìdataType≈ì:≈ìPrompt Template≈ì,≈ìid≈ì:≈ìPrompt Template-VZz3F≈ì,≈ìname≈ì:≈ìprompt≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRouteManager-qHxWw{≈ìfieldName≈ì:≈ìdomain≈ì,≈ìid≈ì:≈ìAPIRouteManager-qHxWw≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "Prompt Template-VZz3F",
        "sourceHandle": "{≈ìdataType≈ì:≈ìPrompt Template≈ì,≈ìid≈ì:≈ìPrompt Template-VZz3F≈ì,≈ìname≈ì:≈ìprompt≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRouteManager-qHxWw",
        "targetHandle": "{≈ìfieldName≈ì:≈ìdomain≈ì,≈ìid≈ì:≈ìAPIRouteManager-qHxWw≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-VZz3F",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "domain",
            "id": "APIRouteManager-26dEs",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-VZz3F{≈ìdataType≈ì:≈ìPrompt Template≈ì,≈ìid≈ì:≈ìPrompt Template-VZz3F≈ì,≈ìname≈ì:≈ìprompt≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRouteManager-26dEs{≈ìfieldName≈ì:≈ìdomain≈ì,≈ìid≈ì:≈ìAPIRouteManager-26dEs≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "Prompt Template-VZz3F",
        "sourceHandle": "{≈ìdataType≈ì:≈ìPrompt Template≈ì,≈ìid≈ì:≈ìPrompt Template-VZz3F≈ì,≈ìname≈ì:≈ìprompt≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRouteManager-26dEs",
        "targetHandle": "{≈ìfieldName≈ì:≈ìdomain≈ì,≈ìid≈ì:≈ìAPIRouteManager-26dEs≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-VZz3F",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "domain",
            "id": "APIRouteManager-45oOD",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-VZz3F{≈ìdataType≈ì:≈ìPrompt Template≈ì,≈ìid≈ì:≈ìPrompt Template-VZz3F≈ì,≈ìname≈ì:≈ìprompt≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRouteManager-45oOD{≈ìfieldName≈ì:≈ìdomain≈ì,≈ìid≈ì:≈ìAPIRouteManager-45oOD≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "Prompt Template-VZz3F",
        "sourceHandle": "{≈ìdataType≈ì:≈ìPrompt Template≈ì,≈ìid≈ì:≈ìPrompt Template-VZz3F≈ì,≈ìname≈ì:≈ìprompt≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRouteManager-45oOD",
        "targetHandle": "{≈ìfieldName≈ì:≈ìdomain≈ì,≈ìid≈ì:≈ìAPIRouteManager-45oOD≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-VZz3F",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "domain",
            "id": "APIRouteManager-H7DON",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-VZz3F{≈ìdataType≈ì:≈ìPrompt Template≈ì,≈ìid≈ì:≈ìPrompt Template-VZz3F≈ì,≈ìname≈ì:≈ìprompt≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRouteManager-H7DON{≈ìfieldName≈ì:≈ìdomain≈ì,≈ìid≈ì:≈ìAPIRouteManager-H7DON≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "Prompt Template-VZz3F",
        "sourceHandle": "{≈ìdataType≈ì:≈ìPrompt Template≈ì,≈ìid≈ì:≈ìPrompt Template-VZz3F≈ì,≈ìname≈ì:≈ìprompt≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRouteManager-H7DON",
        "targetHandle": "{≈ìfieldName≈ì:≈ìdomain≈ì,≈ìid≈ì:≈ìAPIRouteManager-H7DON≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-VZz3F",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "domain",
            "id": "ParserComponent-jnWWE",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-VZz3F{≈ìdataType≈ì:≈ìPrompt Template≈ì,≈ìid≈ì:≈ìPrompt Template-VZz3F≈ì,≈ìname≈ì:≈ìprompt≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-ParserComponent-jnWWE{≈ìfieldName≈ì:≈ìdomain≈ì,≈ìid≈ì:≈ìParserComponent-jnWWE≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "Prompt Template-VZz3F",
        "sourceHandle": "{≈ìdataType≈ì:≈ìPrompt Template≈ì,≈ìid≈ì:≈ìPrompt Template-VZz3F≈ì,≈ìname≈ì:≈ìprompt≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "ParserComponent-jnWWE",
        "targetHandle": "{≈ìfieldName≈ì:≈ìdomain≈ì,≈ìid≈ì:≈ìParserComponent-jnWWE≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "APIRouteManager",
            "id": "APIRouteManager-H7DON",
            "name": "url_2",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "url_input",
            "id": "APIRequest-J2FTE",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__APIRouteManager-H7DON{≈ìdataType≈ì:≈ìAPIRouteManager≈ì,≈ìid≈ì:≈ìAPIRouteManager-H7DON≈ì,≈ìname≈ì:≈ìurl_2≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRequest-J2FTE{≈ìfieldName≈ì:≈ìurl_input≈ì,≈ìid≈ì:≈ìAPIRequest-J2FTE≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "APIRouteManager-H7DON",
        "sourceHandle": "{≈ìdataType≈ì:≈ìAPIRouteManager≈ì,≈ìid≈ì:≈ìAPIRouteManager-H7DON≈ì,≈ìname≈ì:≈ìurl_2≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRequest-J2FTE",
        "targetHandle": "{≈ìfieldName≈ì:≈ìurl_input≈ì,≈ìid≈ì:≈ìAPIRequest-J2FTE≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "APIRequest",
            "id": "APIRequest-J2FTE",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-nInK7",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__APIRequest-J2FTE{≈ìdataType≈ì:≈ìAPIRequest≈ì,≈ìid≈ì:≈ìAPIRequest-J2FTE≈ì,≈ìname≈ì:≈ìdata≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-ParserComponent-nInK7{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-nInK7≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}",
        "selected": false,
        "source": "APIRequest-J2FTE",
        "sourceHandle": "{≈ìdataType≈ì:≈ìAPIRequest≈ì,≈ìid≈ì:≈ìAPIRequest-J2FTE≈ì,≈ìname≈ì:≈ìdata≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}",
        "target": "ParserComponent-nInK7",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-nInK7≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-nInK7",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "TextOutput-HddTz",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-nInK7{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-nInK7≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-TextOutput-HddTz{≈ìfieldName≈ì:≈ìinput_value≈ì,≈ìid≈ì:≈ìTextOutput-HddTz≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "ParserComponent-nInK7",
        "sourceHandle": "{≈ìdataType≈ì:≈ìParserComponent≈ì,≈ìid≈ì:≈ìParserComponent-nInK7≈ì,≈ìname≈ì:≈ìparsed_text≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "TextOutput-HddTz",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_value≈ì,≈ìid≈ì:≈ìTextOutput-HddTz≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-VZz3F",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "domain",
            "id": "APIRouteManager-71tBG",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-VZz3F{≈ìdataType≈ì:≈ìPrompt Template≈ì,≈ìid≈ì:≈ìPrompt Template-VZz3F≈ì,≈ìname≈ì:≈ìprompt≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRouteManager-71tBG{≈ìfieldName≈ì:≈ìdomain≈ì,≈ìid≈ì:≈ìAPIRouteManager-71tBG≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "Prompt Template-VZz3F",
        "sourceHandle": "{≈ìdataType≈ì:≈ìPrompt Template≈ì,≈ìid≈ì:≈ìPrompt Template-VZz3F≈ì,≈ìname≈ì:≈ìprompt≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRouteManager-71tBG",
        "targetHandle": "{≈ìfieldName≈ì:≈ìdomain≈ì,≈ìid≈ì:≈ìAPIRouteManager-71tBG≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LanguageModelComponent",
            "id": "LanguageModelComponent-vkYKd",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "url_suffix",
            "id": "APIRouteManager-71tBG",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__LanguageModelComponent-vkYKd{≈ìdataType≈ì:≈ìLanguageModelComponent≈ì,≈ìid≈ì:≈ìLanguageModelComponent-vkYKd≈ì,≈ìname≈ì:≈ìtext_output≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRouteManager-71tBG{≈ìfieldName≈ì:≈ìurl_suffix≈ì,≈ìid≈ì:≈ìAPIRouteManager-71tBG≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "LanguageModelComponent-vkYKd",
        "sourceHandle": "{≈ìdataType≈ì:≈ìLanguageModelComponent≈ì,≈ìid≈ì:≈ìLanguageModelComponent-vkYKd≈ì,≈ìname≈ì:≈ìtext_output≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRouteManager-71tBG",
        "targetHandle": "{≈ìfieldName≈ì:≈ìurl_suffix≈ì,≈ìid≈ì:≈ìAPIRouteManager-71tBG≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "APIRouteManager",
            "id": "APIRouteManager-71tBG",
            "name": "url_5",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "url_input",
            "id": "APIRequest-B5UnD",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__APIRouteManager-71tBG{≈ìdataType≈ì:≈ìAPIRouteManager≈ì,≈ìid≈ì:≈ìAPIRouteManager-71tBG≈ì,≈ìname≈ì:≈ìurl_5≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-APIRequest-B5UnD{≈ìfieldName≈ì:≈ìurl_input≈ì,≈ìid≈ì:≈ìAPIRequest-B5UnD≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "APIRouteManager-71tBG",
        "sourceHandle": "{≈ìdataType≈ì:≈ìAPIRouteManager≈ì,≈ìid≈ì:≈ìAPIRouteManager-71tBG≈ì,≈ìname≈ì:≈ìurl_5≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "APIRequest-B5UnD",
        "targetHandle": "{≈ìfieldName≈ì:≈ìurl_input≈ì,≈ìid≈ì:≈ìAPIRequest-B5UnD≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TypeConverterComponent",
            "id": "TypeConverterComponent-rttuM",
            "name": "data_output",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-XNusb",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__TypeConverterComponent-rttuM{≈ìdataType≈ì:≈ìTypeConverterComponent≈ì,≈ìid≈ì:≈ìTypeConverterComponent-rttuM≈ì,≈ìname≈ì:≈ìdata_output≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}-ParserComponent-XNusb{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-XNusb≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}",
        "selected": false,
        "source": "TypeConverterComponent-rttuM",
        "sourceHandle": "{≈ìdataType≈ì:≈ìTypeConverterComponent≈ì,≈ìid≈ì:≈ìTypeConverterComponent-rttuM≈ì,≈ìname≈ì:≈ìdata_output≈ì,≈ìoutput_types≈ì:[≈ìData≈ì]}",
        "target": "ParserComponent-XNusb",
        "targetHandle": "{≈ìfieldName≈ì:≈ìinput_data≈ì,≈ìid≈ì:≈ìParserComponent-XNusb≈ì,≈ìinputTypes≈ì:[≈ìDataFrame≈ì,≈ìData≈ì],≈ìtype≈ì:≈ìother≈ì}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LanguageSelector",
            "id": "ParserComponent-GsXoJ",
            "name": "output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "text1",
            "id": "TypeConverterComponent-rttuM",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-GsXoJ{≈ìdataType≈ì:≈ìLanguageSelector≈ì,≈ìid≈ì:≈ìParserComponent-GsXoJ≈ì,≈ìname≈ì:≈ìoutput≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}-TypeConverterComponent-rttuM{≈ìfieldName≈ì:≈ìtext1≈ì,≈ìid≈ì:≈ìTypeConverterComponent-rttuM≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}",
        "selected": false,
        "source": "ParserComponent-GsXoJ",
        "sourceHandle": "{≈ìdataType≈ì:≈ìLanguageSelector≈ì,≈ìid≈ì:≈ìParserComponent-GsXoJ≈ì,≈ìname≈ì:≈ìoutput≈ì,≈ìoutput_types≈ì:[≈ìMessage≈ì]}",
        "target": "TypeConverterComponent-rttuM",
        "targetHandle": "{≈ìfieldName≈ì:≈ìtext1≈ì,≈ìid≈ì:≈ìTypeConverterComponent-rttuM≈ì,≈ìinputTypes≈ì:[≈ìMessage≈ì],≈ìtype≈ì:≈ìstr≈ì}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "undefined-zw3NM",
          "node": {
            "description": "## üìñ README\n\nPerform basic prompting with a Language model component.\n\n#### Quick Start\n- Open the **Playground** to chat with your bot.\n\n#### Next steps:\nExperiment by changing the prompt and the Language model temperature to see how the bot's responses change.",
            "display_name": "Read Me",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          }
        },
        "id": "undefined-zw3NM",
        "measured": {
          "height": 324,
          "width": 575
        },
        "position": {
          "x": 4589.254481036097,
          "y": 1640.616128032521
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "ParserComponent-3ZrOk",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep",
              "clean_data"
            ],
            "frozen": false,
            "icon": "braces",
            "last_updated": "2025-11-19T12:16:42.453Z",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Clean Data",
                "dynamic": false,
                "info": "Enable to clean the data by removing empty rows and lines in each cell of the DataFrame/ Data object.",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Clean Data\",\n            info=(\n                \"Enable to clean the data by removing empty rows and lines \"\n                \"in each cell of the DataFrame/ Data object.\"\n            ),\n            value=True,\n            advanced=True,\n            required=False,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = field_value == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = field_value == \"Parser\"\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{{\n  \"channel\": \"openai\",\n  \"instructions\": \"Speak in a cheerful and positive tone.\",\n  \"model\": \"gpt-4o-mini-tts\",\n  \"text\": \"{oral_broadcast}\",\n  \"voice\": \"coral\",\n  \"img_url\": \"{img_url}\"\n}}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-3ZrOk",
        "measured": {
          "height": 341,
          "width": 320
        },
        "position": {
          "x": 11669.399601265422,
          "y": 5145.0822182378
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "APIRequest-MteaQ",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Make HTTP requests using URL or cURL commands.",
            "display_name": "TTS API Request",
            "documentation": "https://docs.langflow.org/components-data#api-request",
            "edited": true,
            "field_order": [
              "url_input",
              "context",
              "curl_input",
              "method",
              "mode",
              "query_params",
              "body",
              "headers",
              "timeout",
              "follow_redirects",
              "save_to_file",
              "include_httpx_metadata"
            ],
            "frozen": false,
            "icon": "Globe",
            "last_updated": "2025-11-21T01:08:30.135Z",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "API Response",
                "group_outputs": false,
                "hidden": null,
                "method": "make_api_request",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "body": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Body",
                "dynamic": false,
                "info": "The body to send with the request as a dictionary (for POST, PATCH, PUT).",
                "input_types": [
                  "Data"
                ],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "body",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "description": "Parameter name",
                      "disable_edit": false,
                      "display_name": "Key",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "key",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "Parameter value",
                      "disable_edit": false,
                      "display_name": "Value",
                      "edit_mode": "popover",
                      "filterable": true,
                      "hidden": false,
                      "name": "value",
                      "sortable": true
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": []
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nimport re\nimport tempfile\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Any\nfrom urllib.parse import parse_qsl, urlencode, urlparse, urlunparse\n\nimport aiofiles\nimport aiofiles.os as aiofiles_os\nimport httpx\nimport validators\n\nfrom langflow.base.curl.parse import parse_context\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import TabInput\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    IntInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TableInput,\n)\nfrom langflow.schema.data import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.services.deps import get_settings_service\nfrom langflow.utils.component_utils import set_current_fields, set_field_advanced, set_field_display\n\n# Define fields for each mode\nMODE_FIELDS = {\n    \"URL\": [\n        \"url_input\",\n        \"method\",\n    ],\n    \"cURL\": [\"curl_input\"],\n}\n\n# Fields that should always be visible\nDEFAULT_FIELDS = [\"mode\"]\n\n\nclass APIRequestComponent(Component):\n    display_name = \"TTS API Request\"\n    description = \"Make HTTP requests using URL or cURL commands.\"\n    documentation: str = \"https://docs.langflow.org/components-data#api-request\"\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"url_input\",\n            display_name=\"URL\",\n            info=\"Enter the URL for the request.\",\n            advanced=False,\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"context\",\n            display_name=\"Context JSON\",\n            info=(\n                \"‰∏ä‰∏ãÊñáÂ≠óÊÆµÔºåJSON Ê†ºÂºè„ÄÇÂ¶ÇÊûúÂ°´ÂÜô‰∫ÜÊ≠§Â≠óÊÆµÔºåËØ∑Ê±ÇÊñπÊ≥ïÂ∞ÜË¢´ËÆæ‰∏∫ POSTÔºå\"\n                \"‰∏îÊ≠§ JSON ÂÜÖÂÆπÂ∞Ü‰Ωú‰∏∫ËØ∑Ê±Ç Body ÂèëÈÄÅÔºå‰ºòÂÖàÁ∫ßÈ´ò‰∫é Body Ë°®Ê†ºÂ≠óÊÆµ„ÄÇ\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=False,\n        ),\n        MultilineInput(\n            name=\"curl_input\",\n            display_name=\"cURL\",\n            info=(\n                \"Paste a curl command to populate the fields. \"\n                \"This will fill in the dictionary fields for headers and body.\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=True,\n            show=False,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"],\n            value=\"GET\",\n            info=\"The HTTP method to use.\",\n            real_time_refresh=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"URL\", \"cURL\"],\n            value=\"URL\",\n            info=\"Enable cURL mode to populate fields from a cURL command.\",\n            real_time_refresh=True,\n        ),\n        DataInput(\n            name=\"query_params\",\n            display_name=\"Query Parameters\",\n            info=\"The query parameters to append to the URL.\",\n            advanced=True,\n        ),\n        TableInput(\n            name=\"body\",\n            display_name=\"Body\",\n            info=\"The body to send with the request as a dictionary (for POST, PATCH, PUT).\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Key\",\n                    \"type\": \"str\",\n                    \"description\": \"Parameter name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"description\": \"Parameter value\",\n                },\n            ],\n            value=[],\n            input_types=[\"Data\"],\n            advanced=True,\n            real_time_refresh=True,\n        ),\n        TableInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Header\",\n                    \"type\": \"str\",\n                    \"description\": \"Header name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"type\": \"str\",\n                    \"description\": \"Header value\",\n                },\n            ],\n            value=[{\"key\": \"User-Agent\", \"value\": get_settings_service().settings.user_agent}],\n            advanced=True,\n            input_types=[\"Data\"],\n            real_time_refresh=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            value=30,\n            info=\"The timeout to use for the request.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"follow_redirects\",\n            display_name=\"Follow Redirects\",\n            value=True,\n            info=\"Whether to follow http redirects.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"save_to_file\",\n            display_name=\"Save to File\",\n            value=False,\n            info=\"Save the API response to a temporary file\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_httpx_metadata\",\n            display_name=\"Include HTTPx Metadata\",\n            value=False,\n            info=(\n                \"Include properties such as headers, status_code, response_headers, \"\n                \"and redirection_history in the output.\"\n            ),\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"API Response\", name=\"data\", method=\"make_api_request\"),\n    ]\n\n    def _parse_json_value(self, value: Any) -> Any:\n        \"\"\"Parse a value that might be a JSON string.\"\"\"\n        if not isinstance(value, str):\n            return value\n\n        try:\n            parsed = json.loads(value)\n        except json.JSONDecodeError:\n            return value\n        else:\n            return parsed\n\n    def _process_body(self, body: Any) -> dict:\n        \"\"\"Process the body input into a valid dictionary.\"\"\"\n        if body is None:\n            return {}\n        if hasattr(body, \"data\"):\n            body = body.data\n        if isinstance(body, dict):\n            return self._process_dict_body(body)\n        if isinstance(body, str):\n            return self._process_string_body(body)\n        if isinstance(body, list):\n            return self._process_list_body(body)\n        return {}\n\n    def _process_dict_body(self, body: dict) -> dict:\n        \"\"\"Process dictionary body by parsing JSON values.\"\"\"\n        return {k: self._parse_json_value(v) for k, v in body.items()}\n\n    def _process_string_body(self, body: str) -> dict:\n        \"\"\"Process string body by attempting JSON parse.\"\"\"\n        try:\n            return self._process_body(json.loads(body))\n        except json.JSONDecodeError:\n            return {\"data\": body}\n\n    def _process_list_body(self, body: list) -> dict:\n        \"\"\"Process list body by converting to key-value dictionary.\"\"\"\n        processed_dict = {}\n        try:\n            for item in body:\n                # Unwrap Data objects\n                current_item = item\n                if hasattr(item, \"data\"):\n                    unwrapped_data = item.data\n                    # If the unwrapped data is a dict but not key-value format, use it directly\n                    if isinstance(unwrapped_data, dict) and not self._is_valid_key_value_item(unwrapped_data):\n                        return unwrapped_data\n                    current_item = unwrapped_data\n                if not self._is_valid_key_value_item(current_item):\n                    continue\n                key = current_item[\"key\"]\n                value = self._parse_json_value(current_item[\"value\"])\n                processed_dict[key] = value\n        except (KeyError, TypeError, ValueError) as e:\n            self.log(f\"Failed to process body list: {e}\")\n            return {}\n        return processed_dict\n\n    def _is_valid_key_value_item(self, item: Any) -> bool:\n        \"\"\"Check if an item is a valid key-value dictionary.\"\"\"\n        return isinstance(item, dict) and \"key\" in item and \"value\" in item\n\n    def parse_curl(self, curl: str, build_config: dotdict) -> dotdict:\n        \"\"\"Parse a cURL command and update build configuration.\"\"\"\n        try:\n            parsed = parse_context(curl)\n\n            # Update basic configuration\n            url = parsed.url\n            # Normalize URL before setting it\n            url = self._normalize_url(url)\n\n            build_config[\"url_input\"][\"value\"] = url\n            build_config[\"method\"][\"value\"] = parsed.method.upper()\n\n            # Process headers\n            headers_list = [{\"key\": k, \"value\": v} for k, v in parsed.headers.items()]\n            build_config[\"headers\"][\"value\"] = headers_list\n\n            # Process body data\n            if not parsed.data:\n                build_config[\"body\"][\"value\"] = []\n            elif parsed.data:\n                try:\n                    json_data = json.loads(parsed.data)\n                    if isinstance(json_data, dict):\n                        body_list = [\n                            {\"key\": k, \"value\": json.dumps(v) if isinstance(v, dict | list) else str(v)}\n                            for k, v in json_data.items()\n                        ]\n                        build_config[\"body\"][\"value\"] = body_list\n                    else:\n                        build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": json.dumps(json_data)}]\n                except json.JSONDecodeError:\n                    build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": parsed.data}]\n\n        except Exception as exc:\n            msg = f\"Error parsing curl: {exc}\"\n            self.log(msg)\n            raise ValueError(msg) from exc\n\n        return build_config\n\n    def _normalize_url(self, url: str) -> str:\n        \"\"\"Normalize URL by adding https:// if no protocol is specified.\"\"\"\n        if not url or not isinstance(url, str):\n            msg = \"URL cannot be empty\"\n            raise ValueError(msg)\n\n        url = url.strip()\n        if url.startswith((\"http://\", \"https://\")):\n            return url\n        return f\"https://{url}\"\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: dict | None = None,\n        body: Any = None,\n        timeout: int = 5,\n        *,\n        follow_redirects: bool = True,\n        save_to_file: bool = False,\n        include_httpx_metadata: bool = False,\n    ) -> Data:\n        method = method.upper()\n        if method not in {\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"}:\n            msg = f\"Unsupported method: {method}\"\n            raise ValueError(msg)\n\n        processed_body = self._process_body(body)\n        redirection_history = []\n\n        try:\n            # Prepare request parameters\n            request_params = {\n                \"method\": method,\n                \"url\": url,\n                \"headers\": headers,\n                # Ê≥®ÊÑè: httpx ÂÜÖÈÉ®‰ºöÊ£ÄÊü• methodÔºåÂ¶ÇÊûú method ‰∏çÊîØÊåÅ body (Â¶Ç GET)Ôºå‰ºöÂøΩÁï• json/content\n                \"json\": processed_body,\n                \"timeout\": timeout,\n                \"follow_redirects\": follow_redirects,\n            }\n            response = await client.request(**request_params)\n\n            redirection_history = [\n                {\n                    \"url\": redirect.headers.get(\"Location\", str(redirect.url)),\n                    \"status_code\": redirect.status_code,\n                }\n                for redirect in response.history\n            ]\n\n            is_binary, file_path = await self._response_info(response, with_file_path=save_to_file)\n            response_headers = self._headers_to_dict(response.headers)\n\n            # Base metadata\n            metadata = {\n                \"source\": url,\n                \"status_code\": response.status_code,\n                \"response_headers\": response_headers,\n            }\n\n            if redirection_history:\n                metadata[\"redirection_history\"] = redirection_history\n\n            if save_to_file:\n                mode = \"wb\" if is_binary else \"w\"\n                encoding = response.encoding if mode == \"w\" else None\n                if file_path:\n                    await aiofiles_os.makedirs(file_path.parent, exist_ok=True)\n                    if is_binary:\n                        async with aiofiles.open(file_path, \"wb\") as f:\n                            await f.write(response.content)\n                            await f.flush()\n                    else:\n                        async with aiofiles.open(file_path, \"w\", encoding=encoding) as f:\n                            await f.write(response.text)\n                            await f.flush()\n                    metadata[\"file_path\"] = str(file_path)\n\n                if include_httpx_metadata:\n                    metadata.update({\"headers\": headers})\n                return Data(data=metadata)\n\n            # Handle response content\n            if is_binary:\n                result = response.content\n            else:\n                try:\n                    result = response.json()\n                except json.JSONDecodeError:\n                    self.log(\"Failed to decode JSON response\")\n                    result = response.text.encode(\"utf-8\")\n\n            metadata[\"result\"] = result\n\n            if include_httpx_metadata:\n                metadata.update({\"headers\": headers})\n\n            return Data(data=metadata)\n        except (httpx.HTTPError, httpx.RequestError, httpx.TimeoutException) as exc:\n            self.log(f\"Error making request to {url}\")\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 500,\n                    \"error\": str(exc),\n                    **({\"redirection_history\": redirection_history} if redirection_history else {}),\n                },\n            )\n\n    def add_query_params(self, url: str, params: dict) -> str:\n        \"\"\"Add query parameters to URL efficiently.\"\"\"\n        if not params:\n            return url\n        url_parts = list(urlparse(url))\n        query = dict(parse_qsl(url_parts[4]))\n        query.update(params)\n        url_parts[4] = urlencode(query)\n        return urlunparse(url_parts)\n\n    def _headers_to_dict(self, headers: httpx.Headers) -> dict[str, str]:\n        \"\"\"Convert HTTP headers to a dictionary with lowercased keys.\"\"\"\n        return {k.lower(): v for k, v in headers.items()}\n\n    def _process_headers(self, headers: Any) -> dict:\n        \"\"\"Process the headers input into a valid dictionary.\"\"\"\n        if headers is None:\n            return {}\n        if isinstance(headers, dict):\n            return headers\n        if isinstance(headers, list):\n            # Mudan√ßa para aceitar Flow Credentials\n            if isinstance(headers[0], Data):\n                return headers[0].data[\"headers\"]\n            return {item[\"key\"]: item[\"value\"] for item in headers if self._is_valid_key_value_item(item)}\n        return {}\n\n    async def make_api_request(self) -> Data:\n        \"\"\"Make HTTP request with optimized parameter handling and special handling for context JSON.\"\"\"\n        method = self.method\n        url = self.url_input.strip() if isinstance(self.url_input, str) else \"\"\n        headers = self.headers or {}\n        body = self.body or {}\n        timeout = self.timeout\n        follow_redirects = self.follow_redirects\n        save_to_file = self.save_to_file\n        include_httpx_metadata = self.include_httpx_metadata\n        \n        # ----------------------------------------------------\n        # Êñ∞Â¢ûÁöÑ Context JSON Â§ÑÁêÜÈÄªËæë\n        # ----------------------------------------------------\n        if isinstance(self.context, str) and self.context.strip():\n            try:\n                # Â∞ùËØïÂ∞Ü context Ëß£Êûê‰∏∫ JSON ÂØπË±°\n                context_json_data = json.loads(self.context)\n                \n                # Â¶ÇÊûúËß£ÊûêÊàêÂäüÔºåÂàô‰ΩøÁî® context_json_data ‰Ωú‰∏∫ËØ∑Ê±Ç body\n                # Âπ∂‰∏îÂº∫Âà∂ËÆæÁΩÆ method ‰∏∫ POSTÔºåÂêåÊó∂Á°Æ‰øù Content-Type ‰∏∫ application/json\n                method = \"POST\"\n                # Context JSON ‰ºòÂÖàÁ∫ßÊúÄÈ´ò\n                body = context_json_data\n                \n                # ËßÑËåÉÂåñ headers ‰∏∫Â≠óÂÖ∏ÔºåÂπ∂ËÆæÁΩÆ Content-Type\n                headers = self._process_headers(headers)\n                headers[\"Content-Type\"] = \"application/json\"\n                \n            except json.JSONDecodeError:\n                # Â¶ÇÊûú context Êó†Ê≥ïËß£Êûê‰∏∫ JSONÔºåÂàôËßÜ‰∏∫ÊôÆÈÄöÂ≠óÁ¨¶‰∏≤Ôºå‰∏çÁâπÊÆäÂ§ÑÁêÜÔºå\n                # ËÆ©ÂÖ∂Âú®ÂêéÁª≠ÁöÑ body ÊµÅÁ®ã‰∏≠Ë¢´ÂøΩÁï•ÔºåÊàñËÄÖÂ¶ÇÊûúÁî®Êà∑Ê≤°ÊúâËøûÊé• body Â≠óÊÆµÔºå\n                # ÈÇ£‰πà context Â≠óÊÆµÂ∞Ü‰∏ç‰ºöË¢´Áî®Âà∞„ÄÇ\n                pass\n        # ----------------------------------------------------\n\n        # Normalize URL before validation\n        url = self._normalize_url(url)\n\n        # Validate URL\n        if not validators.url(url):\n            msg = f\"Invalid URL provided: {url}\"\n            raise ValueError(msg)\n\n        # Process query parameters\n        if isinstance(self.query_params, str):\n            query_params = dict(parse_qsl(self.query_params))\n        else:\n            query_params = self.query_params.data if self.query_params else {}\n\n        # Process headers and body (body processed here will be standard table/input data\n        # unless it was overwritten by context_json_data above).\n        if not (isinstance(body, dict) and 'Content-Type' in headers):\n             # ‰ªÖÂú®Êú™Ë¢´ context ÈÄªËæëË¶ÜÁõñÊó∂ÊâçÂ§ÑÁêÜ headers Âíå body\n            headers = self._process_headers(headers)\n            body = self._process_body(body)\n            \n        url = self.add_query_params(url, query_params)\n\n        async with httpx.AsyncClient() as client:\n            # ÂΩì body ÊòØ dict Êó∂Ôºåmake_request ‰ºöÂ∞ÜÂÖ∂‰Ωú‰∏∫ JSON body ÂèëÈÄÅ\n            result = await self.make_request(\n                client,\n                method,\n                url,\n                headers,\n                body,\n                timeout,\n                follow_redirects=follow_redirects,\n                save_to_file=save_to_file,\n                include_httpx_metadata=include_httpx_metadata,\n            )\n        self.status = result\n        return result\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        \"\"\"Update the build config based on the selected mode.\"\"\"\n        if field_name != \"mode\":\n            if field_name == \"curl_input\" and self.mode == \"cURL\" and self.curl_input:\n                return self.parse_curl(self.curl_input, build_config)\n            return build_config\n\n        if field_value == \"cURL\":\n            set_field_display(build_config, \"curl_input\", value=True)\n            if build_config[\"curl_input\"][\"value\"]:\n                build_config = self.parse_curl(build_config[\"curl_input\"][\"value\"], build_config)\n        else:\n            set_field_display(build_config, \"curl_input\", value=False)\n\n        return set_current_fields(\n            build_config=build_config,\n            action_fields=MODE_FIELDS,\n            selected_action=field_value,\n            default_fields=DEFAULT_FIELDS,\n            func=set_field_advanced,\n            default_value=True,\n        )\n\n    async def _response_info(\n        self, response: httpx.Response, *, with_file_path: bool = False\n    ) -> tuple[bool, Path | None]:\n        \"\"\"Determine the file path and whether the response content is binary.\n\n        Args:\n            response (Response): The HTTP response object.\n            with_file_path (bool): Whether to save the response content to a file.\n\n        Returns:\n            Tuple[bool, Path | None]:\n                A tuple containing a boolean indicating if the content is binary and the full file path (if applicable).\n        \"\"\"\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        is_binary = \"application/octet-stream\" in content_type or \"application/binary\" in content_type\n\n        if not with_file_path:\n            return is_binary, None\n\n        component_temp_dir = Path(tempfile.gettempdir()) / self.__class__.__name__\n\n        # Create directory asynchronously\n        await aiofiles_os.makedirs(component_temp_dir, exist_ok=True)\n\n        filename = None\n        if \"Content-Disposition\" in response.headers:\n            content_disposition = response.headers[\"Content-Disposition\"]\n            filename_match = re.search(r'filename=\"(.+?)\"', content_disposition)\n            if filename_match:\n                extracted_filename = filename_match.group(1)\n                filename = extracted_filename\n\n        # Step 3: Infer file extension or use part of the request URL if no filename\n        if not filename:\n            # Extract the last segment of the URL path\n            url_path = urlparse(str(response.request.url) if response.request else \"\").path\n            base_name = Path(url_path).name  # Get the last segment of the path\n            if not base_name:  # If the path ends with a slash or is empty\n                base_name = \"response\"\n\n            # Infer file extension\n            content_type_to_extension = {\n                \"text/plain\": \".txt\",\n                \"application/json\": \".json\",\n                \"image/jpeg\": \".jpg\",\n                \"image/png\": \".png\",\n                \"application/octet-stream\": \".bin\",\n            }\n            extension = content_type_to_extension.get(content_type, \".bin\" if is_binary else \".txt\")\n            filename = f\"{base_name}{extension}\"\n\n        # Step 4: Define the full file path\n        file_path = component_temp_dir / filename\n\n        # Step 5: Check if file exists asynchronously and handle accordingly\n        try:\n            # Try to create the file exclusively (x mode) to check existence\n            async with aiofiles.open(file_path, \"x\") as _:\n                pass  # File created successfully, we can use this path\n        except FileExistsError:\n            # If file exists, append a timestamp to the filename\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d%H%M%S%f\")\n            file_path = component_temp_dir / f\"{timestamp}-{filename}\"\n\n        return is_binary, file_path"
              },
              "context": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Context JSON",
                "dynamic": false,
                "info": "‰∏ä‰∏ãÊñáÂ≠óÊÆµÔºåJSON Ê†ºÂºè„ÄÇÂ¶ÇÊûúÂ°´ÂÜô‰∫ÜÊ≠§Â≠óÊÆµÔºåËØ∑Ê±ÇÊñπÊ≥ïÂ∞ÜË¢´ËÆæ‰∏∫ POSTÔºå‰∏îÊ≠§ JSON ÂÜÖÂÆπÂ∞Ü‰Ωú‰∏∫ËØ∑Ê±Ç Body ÂèëÈÄÅÔºå‰ºòÂÖàÁ∫ßÈ´ò‰∫é Body Ë°®Ê†ºÂ≠óÊÆµ„ÄÇ",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "context",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "curl_input": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "cURL",
                "dynamic": false,
                "info": "Paste a curl command to populate the fields. This will fill in the dictionary fields for headers and body.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "curl_input",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "follow_redirects": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Follow Redirects",
                "dynamic": false,
                "info": "Whether to follow http redirects.",
                "list": false,
                "list_add_label": "Add More",
                "name": "follow_redirects",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "headers": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Headers",
                "dynamic": false,
                "info": "The headers to send with the request",
                "input_types": [
                  "Data"
                ],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "headers",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "description": "Header name",
                      "disable_edit": false,
                      "display_name": "Header",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "key",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "Header value",
                      "disable_edit": false,
                      "display_name": "Value",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "value",
                      "sortable": true,
                      "type": "str"
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": [
                  {
                    "key": "User-Agent",
                    "value": "langflow"
                  }
                ]
              },
              "include_httpx_metadata": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Include HTTPx Metadata",
                "dynamic": false,
                "info": "Include properties such as headers, status_code, response_headers, and redirection_history in the output.",
                "list": false,
                "list_add_label": "Add More",
                "name": "include_httpx_metadata",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "method": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Method",
                "dynamic": false,
                "external_options": {},
                "info": "The HTTP method to use.",
                "load_from_db": false,
                "name": "method",
                "options": [
                  "GET",
                  "POST",
                  "PATCH",
                  "PUT",
                  "DELETE"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "POST"
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Enable cURL mode to populate fields from a cURL command.",
                "name": "mode",
                "options": [
                  "URL",
                  "cURL"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "URL"
              },
              "query_params": {
                "_input_type": "DataInput",
                "advanced": true,
                "display_name": "Query Parameters",
                "dynamic": false,
                "info": "The query parameters to append to the URL.",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "query_params",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "save_to_file": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Save to File",
                "dynamic": false,
                "info": "Save the API response to a temporary file",
                "list": false,
                "list_add_label": "Add More",
                "name": "save_to_file",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "The timeout to use for the request.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 30
              },
              "url_input": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "URL",
                "dynamic": false,
                "info": "Enter the URL for the request.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "url_input",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "APIRequest"
        },
        "dragging": false,
        "id": "APIRequest-MteaQ",
        "measured": {
          "height": 477,
          "width": 320
        },
        "position": {
          "x": 12356.407725053214,
          "y": 4715.939598413875
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-f2gGq",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep",
              "clean_data"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Clean Data",
                "dynamic": false,
                "info": "Enable to clean the data by removing empty rows and lines in each cell of the DataFrame/ Data object.",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Clean Data\",\n            info=(\n                \"Enable to clean the data by removing empty rows and lines \"\n                \"in each cell of the DataFrame/ Data object.\"\n            ),\n            value=True,\n            advanced=True,\n            required=False,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = field_value == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = field_value == \"Parser\"\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{{\n  \"audio_file\": \"{result[file_url]}\",\n  \"char_interval\": 0.5,\n  \"gender\": 1,\n  \"text\": \"{result[oral_broadcast]}\",\n  \"subtitle_url\":\"{result[subtitle_url]}\",\n  \"img_url\":\"{result[img_url]}\"\n}}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-f2gGq",
        "measured": {
          "height": 341,
          "width": 320
        },
        "position": {
          "x": 12364.485933525768,
          "y": 5395.6143622009595
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-O6keT",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Parses and outputs clean JSON data.",
            "display_name": "LLM response parser",
            "documentation": "",
            "edited": true,
            "field_order": [
              "input_value"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "JSON Data",
                "group_outputs": false,
                "hidden": null,
                "method": "format_json",
                "name": "formatted_output",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Table View",
                "group_outputs": false,
                "hidden": null,
                "method": "build_dataframe",
                "name": "dataframe_output",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\n\n\nclass JsonFormatterComponent(Component):\n    display_name = \"LLM response parser\"\n    description = \"Parses and outputs clean JSON data.\"\n    name = \"JsonFormatter\"\n    icon = \"braces\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input JSON\",\n            info=\"Paste your raw JSON string here.\",\n            value='{\"segments\": []}',\n            tool_mode=True,\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            name=\"formatted_output\",\n            display_name=\"JSON Data\",\n            method=\"format_json\",\n        ),\n        Output(\n            name=\"dataframe_output\",\n            display_name=\"Table View\",\n            method=\"build_dataframe\",\n        ),\n    ]\n\n    def parse_input(self):\n        \"\"\"\n        Ëß£ÊûêËæìÂÖ•ÔºåÁ°Æ‰øùËøîÂõû Python Â≠óÂÖ∏ÊàñÂàóË°®\n        \"\"\"\n        value = self.input_value\n\n        # 1. Â¶ÇÊûúÂ∑≤ÁªèÊòØÂ≠óÂÖ∏ÔºåÁõ¥Êé•ËøîÂõû\n        if isinstance(value, dict):\n            return value\n        \n        # 2. Â¶ÇÊûúÊòØ Data ÂØπË±°ÔºåÊèêÂèñ data\n        if hasattr(value, \"data\") and isinstance(value.data, dict):\n             return value.data\n        \n        # 3. Â¶ÇÊûúÊòØÂ≠óÁ¨¶‰∏≤ÔºåÂ∞ùËØïËß£Êûê\n        if isinstance(value, str):\n            try:\n                # Ê∏ÖÁêÜÂèØËÉΩÁöÑÈ¶ñÂ∞æÁ©∫ÁôΩ\n                clean_value = value.strip()\n                return json.loads(clean_value)\n            except json.JSONDecodeError as e:\n                # Â¶ÇÊûúËß£ÊûêÂ§±Ë¥•ÔºåÂ∞ùËØïÁÆÄÂçï‰øÆÂ§çÔºàÈíàÂØπÊüê‰∫õÈùûÊ†á JSONÔºâÊàñËÄÖÊäõÂá∫ÈîôËØØ\n                raise ValueError(f\"Invalid JSON format: {e}\")\n        \n        return value\n\n    def format_json(self) -> Data:\n        try:\n            data_obj = self.parse_input()\n            \n            # ÈáçÁÇπ‰øÆÊîπÔºöÁõ¥Êé•Â∞ÜÂØπË±°‰º†Áªô data ÂèÇÊï∞\n            # ‰∏çÂÜçÊâãÂä®Ê∑ªÂä† \"text\" Â≠óÊÆµÔºåËøôÊ†∑ËæìÂá∫ÁïåÈù¢Â∞±ÊòØÂπ≤ÂáÄÁöÑ JSON ÁªìÊûÑ\n            if isinstance(data_obj, dict):\n                return Data(data=data_obj)\n            \n            elif isinstance(data_obj, list):\n                # Â¶ÇÊûúÊòØÂàóË°®ÔºåLangflow Data ÈúÄË¶Å‰∏Ä‰∏™Ê†πÂ≠óÂÖ∏ÔºåÊàë‰ª¨Áî® \"result\" ÂåÖË£π\n                # ÊàñËÄÖÂ¶ÇÊûú‰Ω†ÊÉ≥ËÆ©ÂàóË°®‰Ωú‰∏∫ valueÔºå‰πüÂèØ‰ª•‰∏çÂÅöÂ§ÑÁêÜËßÜÂÖ∑‰ΩìÊÉÖÂÜµËÄåÂÆö\n                # ‰ΩÜÈíàÂØπ‰Ω†ÁöÑ segments Ê°à‰æãÔºåËæìÂÖ•ÊòØ dictÔºå‰ºöËµ∞‰∏äÈù¢ÁöÑÈÄªËæë\n                return Data(data={\"result\": data_obj})\n            \n            else:\n                # ÂÖ∂‰ªñÁ±ªÂûã\n                return Data(data={\"result\": data_obj})\n\n        except Exception as e:\n            self.log(f\"Error formatting JSON: {e}\")\n            return Data(data={\"error\": str(e)})\n\n    def build_dataframe(self) -> DataFrame:\n        \"\"\"\n        Ë°®Ê†ºËßÜÂõæÈÄªËæë\n        \"\"\"\n        try:\n            data_obj = self.parse_input()\n            \n            if isinstance(data_obj, dict):\n                if \"segments\" in data_obj and isinstance(data_obj[\"segments\"], list):\n                    return DataFrame(data_obj[\"segments\"])\n                return DataFrame([data_obj])\n                \n            if isinstance(data_obj, list):\n                return DataFrame(data_obj)\n                \n            return DataFrame()\n        except Exception:\n            return DataFrame()"
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Input JSON",
                "dynamic": false,
                "info": "Paste your raw JSON string here.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{\"segments\": []}"
              }
            },
            "tool_mode": false
          },
          "selected_output": "formatted_output",
          "showNode": true,
          "type": "JsonFormatter"
        },
        "dragging": false,
        "id": "ParserComponent-O6keT",
        "measured": {
          "height": 216,
          "width": 320
        },
        "position": {
          "x": 11697.680517630066,
          "y": 4745.327104499432
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "APIRequest-ffu1F",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Make HTTP requests using URL or cURL commands.",
            "display_name": "Digital Man API Request",
            "documentation": "https://docs.langflow.org/components-data#api-request",
            "edited": true,
            "field_order": [
              "url_input",
              "context",
              "curl_input",
              "method",
              "mode",
              "query_params",
              "body",
              "headers",
              "timeout",
              "follow_redirects",
              "save_to_file",
              "include_httpx_metadata"
            ],
            "frozen": false,
            "icon": "Globe",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "API Response",
                "group_outputs": false,
                "hidden": null,
                "method": "make_api_request",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "body": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Body",
                "dynamic": false,
                "info": "The body to send with the request as a dictionary (for POST, PATCH, PUT).",
                "input_types": [
                  "Data"
                ],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "body",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "description": "Parameter name",
                      "disable_edit": false,
                      "display_name": "Key",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "key",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "Parameter value",
                      "disable_edit": false,
                      "display_name": "Value",
                      "edit_mode": "popover",
                      "filterable": true,
                      "hidden": false,
                      "name": "value",
                      "sortable": true
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": []
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nimport re\nimport tempfile\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Any\nfrom urllib.parse import parse_qsl, urlencode, urlparse, urlunparse\n\nimport aiofiles\nimport aiofiles.os as aiofiles_os\nimport httpx\nimport validators\n\nfrom langflow.base.curl.parse import parse_context\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import TabInput\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    IntInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TableInput,\n)\nfrom langflow.schema.data import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.services.deps import get_settings_service\nfrom langflow.utils.component_utils import set_current_fields, set_field_advanced, set_field_display\n\n# Define fields for each mode\nMODE_FIELDS = {\n    \"URL\": [\n        \"url_input\",\n        \"method\",\n    ],\n    \"cURL\": [\"curl_input\"],\n}\n\n# Fields that should always be visible\nDEFAULT_FIELDS = [\"mode\"]\n\n\nclass APIRequestComponent(Component):\n    display_name = \"Digital Man API Request\"\n    description = \"Make HTTP requests using URL or cURL commands.\"\n    documentation: str = \"https://docs.langflow.org/components-data#api-request\"\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"url_input\",\n            display_name=\"URL\",\n            info=\"Enter the URL for the request.\",\n            advanced=False,\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"context\",\n            display_name=\"Context JSON\",\n            info=(\n                \"‰∏ä‰∏ãÊñáÂ≠óÊÆµÔºåJSON Ê†ºÂºè„ÄÇÂ¶ÇÊûúÂ°´ÂÜô‰∫ÜÊ≠§Â≠óÊÆµÔºåËØ∑Ê±ÇÊñπÊ≥ïÂ∞ÜË¢´ËÆæ‰∏∫ POSTÔºå\"\n                \"‰∏îÊ≠§ JSON ÂÜÖÂÆπÂ∞Ü‰Ωú‰∏∫ËØ∑Ê±Ç Body ÂèëÈÄÅÔºå‰ºòÂÖàÁ∫ßÈ´ò‰∫é Body Ë°®Ê†ºÂ≠óÊÆµ„ÄÇ\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=False,\n        ),\n        MultilineInput(\n            name=\"curl_input\",\n            display_name=\"cURL\",\n            info=(\n                \"Paste a curl command to populate the fields. \"\n                \"This will fill in the dictionary fields for headers and body.\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=True,\n            show=False,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"],\n            value=\"GET\",\n            info=\"The HTTP method to use.\",\n            real_time_refresh=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"URL\", \"cURL\"],\n            value=\"URL\",\n            info=\"Enable cURL mode to populate fields from a cURL command.\",\n            real_time_refresh=True,\n        ),\n        DataInput(\n            name=\"query_params\",\n            display_name=\"Query Parameters\",\n            info=\"The query parameters to append to the URL.\",\n            advanced=True,\n        ),\n        TableInput(\n            name=\"body\",\n            display_name=\"Body\",\n            info=\"The body to send with the request as a dictionary (for POST, PATCH, PUT).\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Key\",\n                    \"type\": \"str\",\n                    \"description\": \"Parameter name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"description\": \"Parameter value\",\n                },\n            ],\n            value=[],\n            input_types=[\"Data\"],\n            advanced=True,\n            real_time_refresh=True,\n        ),\n        TableInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Header\",\n                    \"type\": \"str\",\n                    \"description\": \"Header name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"type\": \"str\",\n                    \"description\": \"Header value\",\n                },\n            ],\n            value=[{\"key\": \"User-Agent\", \"value\": get_settings_service().settings.user_agent}],\n            advanced=True,\n            input_types=[\"Data\"],\n            real_time_refresh=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            value=300,\n            info=\"The timeout to use for the request.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"follow_redirects\",\n            display_name=\"Follow Redirects\",\n            value=True,\n            info=\"Whether to follow http redirects.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"save_to_file\",\n            display_name=\"Save to File\",\n            value=False,\n            info=\"Save the API response to a temporary file\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_httpx_metadata\",\n            display_name=\"Include HTTPx Metadata\",\n            value=False,\n            info=(\n                \"Include properties such as headers, status_code, response_headers, \"\n                \"and redirection_history in the output.\"\n            ),\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"API Response\", name=\"data\", method=\"make_api_request\"),\n    ]\n\n    def _parse_json_value(self, value: Any) -> Any:\n        \"\"\"Parse a value that might be a JSON string.\"\"\"\n        if not isinstance(value, str):\n            return value\n\n        try:\n            parsed = json.loads(value)\n        except json.JSONDecodeError:\n            return value\n        else:\n            return parsed\n\n    def _process_body(self, body: Any) -> dict:\n        \"\"\"Process the body input into a valid dictionary.\"\"\"\n        if body is None:\n            return {}\n        if hasattr(body, \"data\"):\n            body = body.data\n        if isinstance(body, dict):\n            return self._process_dict_body(body)\n        if isinstance(body, str):\n            return self._process_string_body(body)\n        if isinstance(body, list):\n            return self._process_list_body(body)\n        return {}\n\n    def _process_dict_body(self, body: dict) -> dict:\n        \"\"\"Process dictionary body by parsing JSON values.\"\"\"\n        return {k: self._parse_json_value(v) for k, v in body.items()}\n\n    def _process_string_body(self, body: str) -> dict:\n        \"\"\"Process string body by attempting JSON parse.\"\"\"\n        try:\n            return self._process_body(json.loads(body))\n        except json.JSONDecodeError:\n            return {\"data\": body}\n\n    def _process_list_body(self, body: list) -> dict:\n        \"\"\"Process list body by converting to key-value dictionary.\"\"\"\n        processed_dict = {}\n        try:\n            for item in body:\n                # Unwrap Data objects\n                current_item = item\n                if hasattr(item, \"data\"):\n                    unwrapped_data = item.data\n                    # If the unwrapped data is a dict but not key-value format, use it directly\n                    if isinstance(unwrapped_data, dict) and not self._is_valid_key_value_item(unwrapped_data):\n                        return unwrapped_data\n                    current_item = unwrapped_data\n                if not self._is_valid_key_value_item(current_item):\n                    continue\n                key = current_item[\"key\"]\n                value = self._parse_json_value(current_item[\"value\"])\n                processed_dict[key] = value\n        except (KeyError, TypeError, ValueError) as e:\n            self.log(f\"Failed to process body list: {e}\")\n            return {}\n        return processed_dict\n\n    def _is_valid_key_value_item(self, item: Any) -> bool:\n        \"\"\"Check if an item is a valid key-value dictionary.\"\"\"\n        return isinstance(item, dict) and \"key\" in item and \"value\" in item\n\n    def parse_curl(self, curl: str, build_config: dotdict) -> dotdict:\n        \"\"\"Parse a cURL command and update build configuration.\"\"\"\n        try:\n            parsed = parse_context(curl)\n\n            # Update basic configuration\n            url = parsed.url\n            # Normalize URL before setting it\n            url = self._normalize_url(url)\n\n            build_config[\"url_input\"][\"value\"] = url\n            build_config[\"method\"][\"value\"] = parsed.method.upper()\n\n            # Process headers\n            headers_list = [{\"key\": k, \"value\": v} for k, v in parsed.headers.items()]\n            build_config[\"headers\"][\"value\"] = headers_list\n\n            # Process body data\n            if not parsed.data:\n                build_config[\"body\"][\"value\"] = []\n            elif parsed.data:\n                try:\n                    json_data = json.loads(parsed.data)\n                    if isinstance(json_data, dict):\n                        body_list = [\n                            {\"key\": k, \"value\": json.dumps(v) if isinstance(v, dict | list) else str(v)}\n                            for k, v in json_data.items()\n                        ]\n                        build_config[\"body\"][\"value\"] = body_list\n                    else:\n                        build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": json.dumps(json_data)}]\n                except json.JSONDecodeError:\n                    build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": parsed.data}]\n\n        except Exception as exc:\n            msg = f\"Error parsing curl: {exc}\"\n            self.log(msg)\n            raise ValueError(msg) from exc\n\n        return build_config\n\n    def _normalize_url(self, url: str) -> str:\n        \"\"\"Normalize URL by adding https:// if no protocol is specified.\"\"\"\n        if not url or not isinstance(url, str):\n            msg = \"URL cannot be empty\"\n            raise ValueError(msg)\n\n        url = url.strip()\n        if url.startswith((\"http://\", \"https://\")):\n            return url\n        return f\"https://{url}\"\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: dict | None = None,\n        body: Any = None,\n        timeout: int = 5,\n        *,\n        follow_redirects: bool = True,\n        save_to_file: bool = False,\n        include_httpx_metadata: bool = False,\n    ) -> Data:\n        method = method.upper()\n        if method not in {\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"}:\n            msg = f\"Unsupported method: {method}\"\n            raise ValueError(msg)\n\n        processed_body = self._process_body(body)\n        redirection_history = []\n\n        try:\n            # Prepare request parameters\n            request_params = {\n                \"method\": method,\n                \"url\": url,\n                \"headers\": headers,\n                # Ê≥®ÊÑè: httpx ÂÜÖÈÉ®‰ºöÊ£ÄÊü• methodÔºåÂ¶ÇÊûú method ‰∏çÊîØÊåÅ body (Â¶Ç GET)Ôºå‰ºöÂøΩÁï• json/content\n                \"json\": processed_body,\n                \"timeout\": timeout,\n                \"follow_redirects\": follow_redirects,\n            }\n            response = await client.request(**request_params)\n\n            redirection_history = [\n                {\n                    \"url\": redirect.headers.get(\"Location\", str(redirect.url)),\n                    \"status_code\": redirect.status_code,\n                }\n                for redirect in response.history\n            ]\n\n            is_binary, file_path = await self._response_info(response, with_file_path=save_to_file)\n            response_headers = self._headers_to_dict(response.headers)\n\n            # Base metadata\n            metadata = {\n                \"source\": url,\n                \"status_code\": response.status_code,\n                \"response_headers\": response_headers,\n            }\n\n            if redirection_history:\n                metadata[\"redirection_history\"] = redirection_history\n\n            if save_to_file:\n                mode = \"wb\" if is_binary else \"w\"\n                encoding = response.encoding if mode == \"w\" else None\n                if file_path:\n                    await aiofiles_os.makedirs(file_path.parent, exist_ok=True)\n                    if is_binary:\n                        async with aiofiles.open(file_path, \"wb\") as f:\n                            await f.write(response.content)\n                            await f.flush()\n                    else:\n                        async with aiofiles.open(file_path, \"w\", encoding=encoding) as f:\n                            await f.write(response.text)\n                            await f.flush()\n                    metadata[\"file_path\"] = str(file_path)\n\n                if include_httpx_metadata:\n                    metadata.update({\"headers\": headers})\n                return Data(data=metadata)\n\n            # Handle response content\n            if is_binary:\n                result = response.content\n            else:\n                try:\n                    result = response.json()\n                except json.JSONDecodeError:\n                    self.log(\"Failed to decode JSON response\")\n                    result = response.text.encode(\"utf-8\")\n\n            metadata[\"result\"] = result\n\n            if include_httpx_metadata:\n                metadata.update({\"headers\": headers})\n\n            return Data(data=metadata)\n        except (httpx.HTTPError, httpx.RequestError, httpx.TimeoutException) as exc:\n            self.log(f\"Error making request to {url}\")\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 500,\n                    \"error\": str(exc),\n                    **({\"redirection_history\": redirection_history} if redirection_history else {}),\n                },\n            )\n\n    def add_query_params(self, url: str, params: dict) -> str:\n        \"\"\"Add query parameters to URL efficiently.\"\"\"\n        if not params:\n            return url\n        url_parts = list(urlparse(url))\n        query = dict(parse_qsl(url_parts[4]))\n        query.update(params)\n        url_parts[4] = urlencode(query)\n        return urlunparse(url_parts)\n\n    def _headers_to_dict(self, headers: httpx.Headers) -> dict[str, str]:\n        \"\"\"Convert HTTP headers to a dictionary with lowercased keys.\"\"\"\n        return {k.lower(): v for k, v in headers.items()}\n\n    def _process_headers(self, headers: Any) -> dict:\n        \"\"\"Process the headers input into a valid dictionary.\"\"\"\n        if headers is None:\n            return {}\n        if isinstance(headers, dict):\n            return headers\n        if isinstance(headers, list):\n            # Mudan√ßa para aceitar Flow Credentials\n            if isinstance(headers[0], Data):\n                return headers[0].data[\"headers\"]\n            return {item[\"key\"]: item[\"value\"] for item in headers if self._is_valid_key_value_item(item)}\n        return {}\n\n    async def make_api_request(self) -> Data:\n        \"\"\"Make HTTP request with optimized parameter handling and special handling for context JSON.\"\"\"\n        method = self.method\n        url = self.url_input.strip() if isinstance(self.url_input, str) else \"\"\n        headers = self.headers or {}\n        body = self.body or {}\n        timeout = self.timeout\n        follow_redirects = self.follow_redirects\n        save_to_file = self.save_to_file\n        include_httpx_metadata = self.include_httpx_metadata\n        \n        # ----------------------------------------------------\n        # Êñ∞Â¢ûÁöÑ Context JSON Â§ÑÁêÜÈÄªËæë\n        # ----------------------------------------------------\n        if isinstance(self.context, str) and self.context.strip():\n            try:\n                # Â∞ùËØïÂ∞Ü context Ëß£Êûê‰∏∫ JSON ÂØπË±°\n                context_json_data = json.loads(self.context)\n                \n                # Â¶ÇÊûúËß£ÊûêÊàêÂäüÔºåÂàô‰ΩøÁî® context_json_data ‰Ωú‰∏∫ËØ∑Ê±Ç body\n                # Âπ∂‰∏îÂº∫Âà∂ËÆæÁΩÆ method ‰∏∫ POSTÔºåÂêåÊó∂Á°Æ‰øù Content-Type ‰∏∫ application/json\n                method = \"POST\"\n                # Context JSON ‰ºòÂÖàÁ∫ßÊúÄÈ´ò\n                body = context_json_data\n                \n                # ËßÑËåÉÂåñ headers ‰∏∫Â≠óÂÖ∏ÔºåÂπ∂ËÆæÁΩÆ Content-Type\n                headers = self._process_headers(headers)\n                headers[\"Content-Type\"] = \"application/json\"\n                \n            except json.JSONDecodeError:\n                # Â¶ÇÊûú context Êó†Ê≥ïËß£Êûê‰∏∫ JSONÔºåÂàôËßÜ‰∏∫ÊôÆÈÄöÂ≠óÁ¨¶‰∏≤Ôºå‰∏çÁâπÊÆäÂ§ÑÁêÜÔºå\n                # ËÆ©ÂÖ∂Âú®ÂêéÁª≠ÁöÑ body ÊµÅÁ®ã‰∏≠Ë¢´ÂøΩÁï•ÔºåÊàñËÄÖÂ¶ÇÊûúÁî®Êà∑Ê≤°ÊúâËøûÊé• body Â≠óÊÆµÔºå\n                # ÈÇ£‰πà context Â≠óÊÆµÂ∞Ü‰∏ç‰ºöË¢´Áî®Âà∞„ÄÇ\n                pass\n        # ----------------------------------------------------\n\n        # Normalize URL before validation\n        url = self._normalize_url(url)\n\n        # Validate URL\n        if not validators.url(url):\n            msg = f\"Invalid URL provided: {url}\"\n            raise ValueError(msg)\n\n        # Process query parameters\n        if isinstance(self.query_params, str):\n            query_params = dict(parse_qsl(self.query_params))\n        else:\n            query_params = self.query_params.data if self.query_params else {}\n\n        # Process headers and body (body processed here will be standard table/input data\n        # unless it was overwritten by context_json_data above).\n        if not (isinstance(body, dict) and 'Content-Type' in headers):\n             # ‰ªÖÂú®Êú™Ë¢´ context ÈÄªËæëË¶ÜÁõñÊó∂ÊâçÂ§ÑÁêÜ headers Âíå body\n            headers = self._process_headers(headers)\n            body = self._process_body(body)\n            \n        url = self.add_query_params(url, query_params)\n\n        async with httpx.AsyncClient() as client:\n            # ÂΩì body ÊòØ dict Êó∂Ôºåmake_request ‰ºöÂ∞ÜÂÖ∂‰Ωú‰∏∫ JSON body ÂèëÈÄÅ\n            result = await self.make_request(\n                client,\n                method,\n                url,\n                headers,\n                body,\n                timeout,\n                follow_redirects=follow_redirects,\n                save_to_file=save_to_file,\n                include_httpx_metadata=include_httpx_metadata,\n            )\n        self.status = result\n        return result\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        \"\"\"Update the build config based on the selected mode.\"\"\"\n        if field_name != \"mode\":\n            if field_name == \"curl_input\" and self.mode == \"cURL\" and self.curl_input:\n                return self.parse_curl(self.curl_input, build_config)\n            return build_config\n\n        if field_value == \"cURL\":\n            set_field_display(build_config, \"curl_input\", value=True)\n            if build_config[\"curl_input\"][\"value\"]:\n                build_config = self.parse_curl(build_config[\"curl_input\"][\"value\"], build_config)\n        else:\n            set_field_display(build_config, \"curl_input\", value=False)\n\n        return set_current_fields(\n            build_config=build_config,\n            action_fields=MODE_FIELDS,\n            selected_action=field_value,\n            default_fields=DEFAULT_FIELDS,\n            func=set_field_advanced,\n            default_value=True,\n        )\n\n    async def _response_info(\n        self, response: httpx.Response, *, with_file_path: bool = False\n    ) -> tuple[bool, Path | None]:\n        \"\"\"Determine the file path and whether the response content is binary.\n\n        Args:\n            response (Response): The HTTP response object.\n            with_file_path (bool): Whether to save the response content to a file.\n\n        Returns:\n            Tuple[bool, Path | None]:\n                A tuple containing a boolean indicating if the content is binary and the full file path (if applicable).\n        \"\"\"\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        is_binary = \"application/octet-stream\" in content_type or \"application/binary\" in content_type\n\n        if not with_file_path:\n            return is_binary, None\n\n        component_temp_dir = Path(tempfile.gettempdir()) / self.__class__.__name__\n\n        # Create directory asynchronously\n        await aiofiles_os.makedirs(component_temp_dir, exist_ok=True)\n\n        filename = None\n        if \"Content-Disposition\" in response.headers:\n            content_disposition = response.headers[\"Content-Disposition\"]\n            filename_match = re.search(r'filename=\"(.+?)\"', content_disposition)\n            if filename_match:\n                extracted_filename = filename_match.group(1)\n                filename = extracted_filename\n\n        # Step 3: Infer file extension or use part of the request URL if no filename\n        if not filename:\n            # Extract the last segment of the URL path\n            url_path = urlparse(str(response.request.url) if response.request else \"\").path\n            base_name = Path(url_path).name  # Get the last segment of the path\n            if not base_name:  # If the path ends with a slash or is empty\n                base_name = \"response\"\n\n            # Infer file extension\n            content_type_to_extension = {\n                \"text/plain\": \".txt\",\n                \"application/json\": \".json\",\n                \"image/jpeg\": \".jpg\",\n                \"image/png\": \".png\",\n                \"application/octet-stream\": \".bin\",\n            }\n            extension = content_type_to_extension.get(content_type, \".bin\" if is_binary else \".txt\")\n            filename = f\"{base_name}{extension}\"\n\n        # Step 4: Define the full file path\n        file_path = component_temp_dir / filename\n\n        # Step 5: Check if file exists asynchronously and handle accordingly\n        try:\n            # Try to create the file exclusively (x mode) to check existence\n            async with aiofiles.open(file_path, \"x\") as _:\n                pass  # File created successfully, we can use this path\n        except FileExistsError:\n            # If file exists, append a timestamp to the filename\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d%H%M%S%f\")\n            file_path = component_temp_dir / f\"{timestamp}-{filename}\"\n\n        return is_binary, file_path"
              },
              "context": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Context JSON",
                "dynamic": false,
                "info": "‰∏ä‰∏ãÊñáÂ≠óÊÆµÔºåJSON Ê†ºÂºè„ÄÇÂ¶ÇÊûúÂ°´ÂÜô‰∫ÜÊ≠§Â≠óÊÆµÔºåËØ∑Ê±ÇÊñπÊ≥ïÂ∞ÜË¢´ËÆæ‰∏∫ POSTÔºå‰∏îÊ≠§ JSON ÂÜÖÂÆπÂ∞Ü‰Ωú‰∏∫ËØ∑Ê±Ç Body ÂèëÈÄÅÔºå‰ºòÂÖàÁ∫ßÈ´ò‰∫é Body Ë°®Ê†ºÂ≠óÊÆµ„ÄÇ",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "context",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "curl_input": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "cURL",
                "dynamic": false,
                "info": "Paste a curl command to populate the fields. This will fill in the dictionary fields for headers and body.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "curl_input",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "follow_redirects": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Follow Redirects",
                "dynamic": false,
                "info": "Whether to follow http redirects.",
                "list": false,
                "list_add_label": "Add More",
                "name": "follow_redirects",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "headers": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Headers",
                "dynamic": false,
                "info": "The headers to send with the request",
                "input_types": [
                  "Data"
                ],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "headers",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "description": "Header name",
                      "disable_edit": false,
                      "display_name": "Header",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "key",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "Header value",
                      "disable_edit": false,
                      "display_name": "Value",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "value",
                      "sortable": true,
                      "type": "str"
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": [
                  {
                    "key": "User-Agent",
                    "value": "langflow"
                  }
                ]
              },
              "include_httpx_metadata": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Include HTTPx Metadata",
                "dynamic": false,
                "info": "Include properties such as headers, status_code, response_headers, and redirection_history in the output.",
                "list": false,
                "list_add_label": "Add More",
                "name": "include_httpx_metadata",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "method": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Method",
                "dynamic": false,
                "external_options": {},
                "info": "The HTTP method to use.",
                "load_from_db": false,
                "name": "method",
                "options": [
                  "GET",
                  "POST",
                  "PATCH",
                  "PUT",
                  "DELETE"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "POST"
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Enable cURL mode to populate fields from a cURL command.",
                "name": "mode",
                "options": [
                  "URL",
                  "cURL"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "URL"
              },
              "query_params": {
                "_input_type": "DataInput",
                "advanced": true,
                "display_name": "Query Parameters",
                "dynamic": false,
                "info": "The query parameters to append to the URL.",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "query_params",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "save_to_file": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Save to File",
                "dynamic": false,
                "info": "Save the API response to a temporary file",
                "list": false,
                "list_add_label": "Add More",
                "name": "save_to_file",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "The timeout to use for the request.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 300
              },
              "url_input": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "URL",
                "dynamic": false,
                "info": "Enter the URL for the request.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "url_input",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "APIRequest"
        },
        "dragging": false,
        "id": "APIRequest-ffu1F",
        "measured": {
          "height": 477,
          "width": 320
        },
        "position": {
          "x": 12990.04579444461,
          "y": 4723.959211848642
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-A9PXP",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep",
              "clean_data"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Clean Data",
                "dynamic": false,
                "info": "Enable to clean the data by removing empty rows and lines in each cell of the DataFrame/ Data object.",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Clean Data\",\n            info=(\n                \"Enable to clean the data by removing empty rows and lines \"\n                \"in each cell of the DataFrame/ Data object.\"\n            ),\n            value=True,\n            advanced=True,\n            required=False,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = field_value == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = field_value == \"Parser\"\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{{\n      \"audio_url\": \"{result[audio_url]}\",\n      \"subtitle_url\": \"{result[subtitle_url]}\",\n      \"video_url\": \"{result[video_url]}\",\n      \"img_url\": \"{result[img_url]}\"\n }}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-A9PXP",
        "measured": {
          "height": 341,
          "width": 320
        },
        "position": {
          "x": 13454.42612043631,
          "y": 4925.584098452565
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "undefined-wTI2w",
          "node": {
            "description": "# AIVidFromPPT\nGenerate a digital human explanation video based on the PPT file you upload.\n\n1. Upload your PPT at the \"Upload PPT\" node.\n2. Click the \"Loop\" node to run the process.\n3. Check the result at the final \"Output\" node.",
            "display_name": "Read Me",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          }
        },
        "dragging": false,
        "id": "undefined-wTI2w",
        "measured": {
          "height": 324,
          "width": 575
        },
        "position": {
          "x": 9336.993597195795,
          "y": 4122.466837903992
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "HttpFilePoster-P1BCq",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Êé•ÂèóÊú¨Âú∞PPTXÊñá‰ª∂ÔºåPOST‰∏ä‰º†Âà∞ÊåáÂÆöURLÂπ∂ËøîÂõûÂìçÂ∫îÔºõËæìÂá∫‰ªÖ‰∏∫ÂõæÁâáÂàóË°®",
            "display_name": "PPT upload",
            "documentation": "https://docs.langflow.org/components-processing",
            "edited": true,
            "field_order": [
              "input_file",
              "post_url",
              "upload_mode",
              "field_name",
              "extra_fields",
              "headers",
              "timeout",
              "return_json"
            ],
            "frozen": false,
            "icon": "upload",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "ÂõæÁâáÂàóË°®",
                "group_outputs": false,
                "hidden": null,
                "method": "extract_images",
                "name": "images",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"\nHTTP Êñá‰ª∂‰∏ä‰º†ÁªÑ‰ª∂ÔºàPPTXÁâàÔºâ\n\nÂäüËÉΩÔºö\n- Êé•Âèó‰∏Ä‰∏™Êú¨Âú∞ PPTX Êñá‰ª∂ÔºàFileInputÔºâ\n- Â∞ÜÊñá‰ª∂‰ª• POST ÊñπÂºè‰∏ä‰º†Âà∞ÊåáÂÆöÁöÑ `post_url`\n- ÊîØÊåÅ multipart/form-data Êàñ‰∫åËøõÂà∂‰∏ä‰º†Ê®°Âºè\n- ÂèØÊ∑ªÂä†È¢ùÂ§ñË°®ÂçïÂ≠óÊÆµ‰∏éËØ∑Ê±ÇÂ§¥\n- ËøîÂõûÂìçÂ∫îÊñáÊú¨‰∏éÁªìÊûÑÂåñÊï∞ÊçÆ\n\"\"\"\n\nfrom __future__ import annotations\n\nimport io\nimport json\nimport mimetypes\nimport os\nfrom typing import Any, Dict, Optional, Tuple, List\nimport re\n\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    IntInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass HttpFilePosterComponent(Component):\n    display_name = \"PPT upload\"\n    description = \"Êé•ÂèóÊú¨Âú∞PPTXÊñá‰ª∂ÔºåPOST‰∏ä‰º†Âà∞ÊåáÂÆöURLÂπ∂ËøîÂõûÂìçÂ∫îÔºõËæìÂá∫‰ªÖ‰∏∫ÂõæÁâáÂàóË°®\"\n    documentation: str = \"https://docs.langflow.org/components-processing\"\n    icon = \"upload\"\n    name = \"HttpFilePoster\"\n\n    inputs = [\n        FileInput(\n            name=\"input_file\",\n            display_name=\"PPTXÊñá‰ª∂\",\n            info=\"ÈÄâÊã©Ë¶Å‰∏ä‰º†ÁöÑÊú¨Âú∞PPTXÊñá‰ª∂\",\n            file_types=[\"pptx\"],\n            advanced=False,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"post_url\",\n            display_name=\"POSTÁõÆÊ†áURL\",\n            info=\"Êñá‰ª∂Â∞ÜË¢´POSTÂà∞Ê≠§URL\",\n            advanced=False,\n            required=True,\n        ),\n        DropdownInput(\n            name=\"upload_mode\",\n            display_name=\"‰∏ä‰º†Ê®°Âºè\",\n            options=[\"multipart\", \"binary\"],\n            value=\"multipart\",\n            info=\"multipart‰Ωú‰∏∫Ë°®ÂçïÊñá‰ª∂‰∏ä‰º†Ôºõbinary‰ª•ÂéüÂßãÂ≠óËäÇ‰Ωú‰∏∫ËØ∑Ê±Ç‰Ωì\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"field_name\",\n            display_name=\"Êñá‰ª∂Â≠óÊÆµÂêç\",\n            value=\"file\",\n            info=\"multipartÊ®°Âºè‰∏ãÊñá‰ª∂ÂØπÂ∫îÁöÑË°®ÂçïÂ≠óÊÆµÂêç\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"extra_fields\",\n            display_name=\"È¢ùÂ§ñË°®ÂçïÂ≠óÊÆµ(JSON)\",\n            value=\"{}\",\n            info=\"multipartÊ®°Âºè‰∏ãÁöÑÈ¢ùÂ§ñÂ≠óÊÆµÔºåJSONÂØπË±°Ê†ºÂºè\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"headers\",\n            display_name=\"ËØ∑Ê±ÇÂ§¥(JSON)\",\n            value=\"{}\",\n            info=\"Ëá™ÂÆö‰πâËØ∑Ê±ÇÂ§¥ÔºåJSONÂØπË±°Ê†ºÂºè\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Ë∂ÖÊó∂Êó∂Èó¥(Áßí)\",\n            value=30,\n            info=\"ËØ∑Ê±ÇË∂ÖÊó∂Êó∂Èó¥\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"return_json\",\n            display_name=\"Â∞ùËØïËß£ÊûêJSONÂìçÂ∫î\",\n            value=True,\n            info=\"Ëã•ÂìçÂ∫î‰∏∫JSONÔºåËøîÂõûÁªìÊûÑÂåñÊï∞ÊçÆ\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"ÂõæÁâáÂàóË°®\", name=\"images\", method=\"extract_images\"),\n    ]\n\n    # ------------------------------ Helpers -----------------------------------\n\n    def _parse_json_field(self, raw: Optional[str]) -> Dict[str, Any]:\n        if not raw:\n            return {}\n        try:\n            return json.loads(raw)\n        except Exception:\n            # ÂÖÅËÆ∏‰ΩøÁî®ÁÆÄÂçïÁöÑ k=v Êç¢Ë°åÊ†ºÂºè‰Ωú‰∏∫ÂÖúÂ∫ï\n            result: Dict[str, Any] = {}\n            for line in raw.splitlines():\n                if \"=\" in line:\n                    k, v = line.split(\"=\", 1)\n                    result[k.strip()] = v.strip()\n            return result\n\n    def _resolve_file(self) -> Tuple[str, io.BytesIO, Optional[str]]:\n        \"\"\"\n        ËøîÂõû (filename, file_obj, mime_type)\n        - ‰ΩøÁî®Êú¨Âú∞ input_fileÔºàÂøÖÂ°´Ôºâ\n        \"\"\"\n        if self.input_file and os.path.exists(self.input_file):\n            filename = os.path.basename(self.input_file)\n            mime, _ = mimetypes.guess_type(filename)\n            with open(self.input_file, \"rb\") as f:\n                buf = io.BytesIO(f.read())\n            buf.seek(0)\n            return filename, buf, mime\n        raise ValueError(\"ËØ∑Êèê‰æõÊú¨Âú∞PPTXÊñá‰ª∂\")\n\n    def _do_post(self) -> Dict[str, Any]:\n        try:\n            import requests\n        except Exception as e:\n            raise RuntimeError(\"ÈúÄË¶Å requests Â∫ì‰ª•ÊâßË°åHTTPËØ∑Ê±Ç\") from e\n\n        if not self.post_url:\n            raise ValueError(\"post_url ‰∏∫ÂøÖÂ°´\")\n\n        headers = self._parse_json_field(self.headers)\n        extra_fields = self._parse_json_field(self.extra_fields)\n        filename, file_obj, mime = self._resolve_file()\n\n        # Ê†πÊçÆ‰∏ä‰º†Ê®°ÂºèÊûÑÈÄ†ËØ∑Ê±Ç\n        if (self.upload_mode or \"multipart\") == \"multipart\":\n            files = {self.field_name or \"file\": (filename, file_obj, mime or \"application/octet-stream\")}\n            data = extra_fields\n            resp = requests.post(self.post_url, files=files, data=data, headers=headers, timeout=self.timeout or 30)\n        else:  # binary\n            body = file_obj.read()\n            # Content-Type ‰ªéÊé®Êñ≠ÁöÑ mime Êàñ octet-stream\n            ct = mime or \"application/octet-stream\"\n            headers = {**headers, \"Content-Type\": ct}\n            resp = requests.post(self.post_url, data=body, headers=headers, timeout=self.timeout or 30)\n\n        result: Dict[str, Any] = {\n            \"ok\": resp.ok,\n            \"status_code\": resp.status_code,\n            \"headers\": dict(resp.headers or {}),\n            \"url\": resp.url,\n        }\n\n        # ÊñáÊú¨‰∏éJSONËß£Êûê\n        try:\n            text = resp.text\n        except Exception:\n            text = \"\"\n        result[\"text\"] = text\n\n        if self.return_json:\n            try:\n                result[\"json\"] = resp.json()\n            except Exception:\n                result[\"json\"] = None\n\n        return result\n\n    # ------------------------------ Outputs -----------------------------------\n\n    def _collect_images_from_json(self, obj: Any) -> List[str]:\n        images: List[str] = []\n\n        def is_image_str(s: str) -> bool:\n            if s.startswith(\"data:image/\"):\n                return True\n            # ÁÆÄÂçïÂåπÈÖçÂ∏∏ËßÅÂõæÁâáÊâ©Â±ïÂêç\n            return bool(re.search(r\"https?://[^\\s]+\\.(png|jpg|jpeg|gif|bmp|webp)(\\?[^\\s]*)?$\", s, re.IGNORECASE))\n\n        def walk(o: Any):\n            if isinstance(o, dict):\n                # Â∏∏ËßÅÂΩ¢ÊÄÅÔºö{\"url\": \"...\"} Êàñ {\"image_url\": {\"url\": \"...\"}}\n                for k, v in o.items():\n                    if isinstance(v, str) and is_image_str(v):\n                        images.append(v)\n                    elif isinstance(v, dict) and \"url\" in v and isinstance(v[\"url\"], str) and is_image_str(v[\"url\"]):\n                        images.append(v[\"url\"])\n                    else:\n                        walk(v)\n            elif isinstance(o, list):\n                for it in o:\n                    walk(it)\n            elif isinstance(o, str):\n                if is_image_str(o):\n                    images.append(o)\n\n        walk(obj)\n        # ÂéªÈáç‰øùÊåÅÈ°∫Â∫è\n        seen = set()\n        unique = []\n        for u in images:\n            if u not in seen:\n                seen.add(u)\n                unique.append(u)\n        return unique\n\n    def extract_images(self) -> Data:\n        \"\"\"ÊâßË°å‰∏ä‰º†Âπ∂‰ªéÂìçÂ∫î‰∏≠ÊèêÂèñÂõæÁâáURLÊàñData URIÔºåËøîÂõûÂõæÁâáÂàóË°®\"\"\"\n        try:\n            res = self._do_post()\n        except Exception as e:\n            err = {\"success\": False, \"error\": str(e)}\n            self.status = err\n            return Data(value=[])  # ËæìÂá∫‰ªÖÂõæÁâáÂàóË°®ÔºåÈîôËØØÊó∂ËøîÂõûÁ©∫ÂàóË°®\n\n        images: List[str] = []\n\n        # 1) ‰ºòÂÖà‰ªé JSON ÊèêÂèñ\n        if isinstance(res.get(\"json\"), (dict, list)):\n            images = self._collect_images_from_json(res[\"json\"]) or []\n\n        # 2) Ëã•JSONÊó†ÁªìÊûúÔºå‰ªéÊñáÊú¨‰∏≠Ê≠£ÂàôÊèêÂèñ\n        if not images and isinstance(res.get(\"text\"), str):\n            pattern = r\"https?://[^\\s]+\\.(png|jpg|jpeg|gif|bmp|webp)(\\?[^\\s]*)?\"\n            images = re.findall(pattern, res[\"text\"], re.IGNORECASE)\n            # re.findall ËøîÂõûÁöÑÊòØÂÖÉÁªÑ (ext, query) ÊàñÂåπÈÖçÁªÑÔºåÈúÄË¶ÅÈáçÂª∫ÂÆåÊï¥ÂåπÈÖç\n            if images:\n                # ÈáçÊñ∞Âú®ÊñáÊú¨‰∏≠Áî® finditer ÊãøÂÆåÊï¥ÂåπÈÖç\n                iters = re.finditer(pattern, res[\"text\"], re.IGNORECASE)\n                images = [m.group(0) for m in iters]\n\n        # ÊúÄÁªàËøîÂõûÂõæÁâáÊï∞ÁªÑ\n        self.status = {\"count\": len(images)}\n        return Data(value=images)"
              },
              "extra_fields": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "È¢ùÂ§ñË°®ÂçïÂ≠óÊÆµ(JSON)",
                "dynamic": false,
                "info": "multipartÊ®°Âºè‰∏ãÁöÑÈ¢ùÂ§ñÂ≠óÊÆµÔºåJSONÂØπË±°Ê†ºÂºè",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "extra_fields",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{}"
              },
              "field_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Êñá‰ª∂Â≠óÊÆµÂêç",
                "dynamic": false,
                "info": "multipartÊ®°Âºè‰∏ãÊñá‰ª∂ÂØπÂ∫îÁöÑË°®ÂçïÂ≠óÊÆµÂêç",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "field_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "file"
              },
              "headers": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "ËØ∑Ê±ÇÂ§¥(JSON)",
                "dynamic": false,
                "info": "Ëá™ÂÆö‰πâËØ∑Ê±ÇÂ§¥ÔºåJSONÂØπË±°Ê†ºÂºè",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "headers",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{}"
              },
              "input_file": {
                "_input_type": "FileInput",
                "advanced": false,
                "display_name": "PPTXÊñá‰ª∂",
                "dynamic": false,
                "fileTypes": [
                  "pptx"
                ],
                "file_path": "948b61be-4560-4cea-86ef-76ab6289f206/test.pptx",
                "info": "ÈÄâÊã©Ë¶Å‰∏ä‰º†ÁöÑÊú¨Âú∞PPTXÊñá‰ª∂",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_file",
                "placeholder": "",
                "required": true,
                "show": true,
                "temp_file": false,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "post_url": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "POSTÁõÆÊ†áURL",
                "dynamic": false,
                "info": "Êñá‰ª∂Â∞ÜË¢´POSTÂà∞Ê≠§URL",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "post_url",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "return_json": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Â∞ùËØïËß£ÊûêJSONÂìçÂ∫î",
                "dynamic": false,
                "info": "Ëã•ÂìçÂ∫î‰∏∫JSONÔºåËøîÂõûÁªìÊûÑÂåñÊï∞ÊçÆ",
                "list": false,
                "list_add_label": "Add More",
                "name": "return_json",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Ë∂ÖÊó∂Êó∂Èó¥(Áßí)",
                "dynamic": false,
                "info": "ËØ∑Ê±ÇË∂ÖÊó∂Êó∂Èó¥",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 30
              },
              "upload_mode": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "‰∏ä‰º†Ê®°Âºè",
                "dynamic": false,
                "external_options": {},
                "info": "multipart‰Ωú‰∏∫Ë°®ÂçïÊñá‰ª∂‰∏ä‰º†Ôºõbinary‰ª•ÂéüÂßãÂ≠óËäÇ‰Ωú‰∏∫ËØ∑Ê±Ç‰Ωì",
                "name": "upload_mode",
                "options": [
                  "multipart",
                  "binary"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "multipart"
              }
            },
            "tool_mode": false
          },
          "selected_output": "response_text",
          "showNode": true,
          "type": "HttpFilePoster"
        },
        "dragging": false,
        "id": "HttpFilePoster-P1BCq",
        "measured": {
          "height": 320,
          "width": 320
        },
        "position": {
          "x": 9395.032790051344,
          "y": 4971.4371933480015
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-RuSjk",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep",
              "clean_data"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Clean Data",
                "dynamic": false,
                "info": "Enable to clean the data by removing empty rows and lines in each cell of the DataFrame/ Data object.",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Clean Data\",\n            info=(\n                \"Enable to clean the data by removing empty rows and lines \"\n                \"in each cell of the DataFrame/ Data object.\"\n            ),\n            value=True,\n            advanced=True,\n            required=False,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = field_value == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = field_value == \"Parser\"\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{value}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-RuSjk",
        "measured": {
          "height": 341,
          "width": 320
        },
        "position": {
          "x": 10225.422943422462,
          "y": 4925.524315022213
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "LanguageModelComponent-6o3Gn",
          "node": {
            "base_classes": [
              "Message",
              "NoneType"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Runs a language model given a specified provider.",
            "display_name": "Language Model",
            "documentation": "https://docs.langflow.org/components-models",
            "edited": true,
            "field_order": [
              "provider",
              "model_name",
              "input_value",
              "image_url",
              "system_message",
              "stream",
              "temperature"
            ],
            "frozen": false,
            "icon": "brain-circuit",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {
              "keywords": [
                "model",
                "llm",
                "language model",
                "large language model"
              ]
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Response Message",
                "group_outputs": false,
                "hidden": null,
                "method": "analyze_image_and_text",
                "name": "response_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Raw Result",
                "group_outputs": false,
                "hidden": null,
                "method": "analyze_image_and_text_raw",
                "name": "response_raw",
                "options": null,
                "required_inputs": null,
                "selected": "NoneType",
                "tool_mode": true,
                "types": [
                  "NoneType"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": 0,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import os\nfrom typing import Any\n\nfrom langchain_openai import ChatOpenAI\n\nfrom langflow.base.models.anthropic_constants import ANTHROPIC_MODELS\nfrom langflow.base.models.google_generative_ai_constants import GOOGLE_GENERATIVE_AI_MODELS\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import OPENAI_CHAT_MODEL_NAMES, OPENAI_REASONING_MODEL_NAMES\nfrom langflow.custom_flowteam.base.models.anthropic.chat_models import ChatAnthropic\nfrom langflow.custom_flowteam.base.models.google_genai.chat_models import CustomChatGoogleGenerativeAI\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.helpers.flow import retrieve_flow_name\nfrom langflow.inputs.inputs import BoolInput\nimport base64\nimport mimetypes\nfrom typing import List\nimport requests\nfrom langchain_core.messages import HumanMessage, SystemMessage\nfrom langflow.io import DropdownInput, MessageInput, MultilineInput, SliderInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI\nfrom langflow.schema.dotdict import dotdict\n\n\nclass LanguageModelComponent(LCModelComponent):\n    display_name = \"Language Model\"\n    description = \"Runs a language model given a specified provider.\"\n    documentation: str = \"https://docs.langflow.org/components-models\"\n    icon = \"brain-circuit\"\n    category = \"models\"\n    priority = 0  # Set priority to 0 to make it appear first\n\n    flow_token: str | None = None\n    flow_tenant: str | None = None\n    flow_domain_url: str = os.environ.get(\"FLOW_DOMAIN_URL\", \"https://flow.ciandt.com\")\n\n    inputs = [\n        DropdownInput(\n            name=\"provider\",\n            display_name=\"Model Provider\",\n            options=[\"OpenAI\", \"Anthropic\", \"Google\"],\n            value=\"OpenAI\",\n            info=\"Select the model provider\",\n            real_time_refresh=True,\n            options_metadata=[{\"icon\": \"OpenAI\"}, {\"icon\": \"Anthropic\"}, {\"icon\": \"GoogleGenerativeAI\"}],\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            options=OPENAI_CHAT_MODEL_NAMES + OPENAI_REASONING_MODEL_NAMES,\n            value=OPENAI_CHAT_MODEL_NAMES[0],\n            info=\"Select the model to use\",\n            real_time_refresh=True,\n        ),\n        # SecretStrInput(\n        #    name=\"api_key\",\n        #    display_name=\"OpenAI API Key\",\n        #    info=\"Model Provider API key\",\n        #    required=False,\n        #    show=True,\n        #    real_time_refresh=True,\n        # ),\n        MessageInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            info=\"The input text to send to the model\",\n        ),\n        MessageTextInput(\n            name=\"image_url\",\n            display_name=\"Image URL\",\n            info=\"Optional: If provided, the component will download the image and send it with the prompt.\",\n            advanced=False,\n        ),\n        MultilineInput(\n            name=\"system_message\",\n            display_name=\"System Message\",\n            info=\"A system message that helps set the behavior of the assistant\",\n            advanced=False,\n        ),\n        BoolInput(\n            name=\"stream\",\n            display_name=\"Stream\",\n            info=\"Whether to stream the response\",\n            value=False,\n            advanced=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            info=\"Controls randomness in responses\",\n            range_spec=RangeSpec(min=0, max=1, step=0.01),\n            advanced=False,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Response Message\", name=\"response_text\", method=\"analyze_image_and_text\"),\n        Output(display_name=\"Raw Result\", name=\"response_raw\", method=\"analyze_image_and_text_raw\"),\n    ]\n\n    def build_model(self) -> LanguageModel:\n        provider = self.provider\n        model_name = self.model_name\n        temperature = self.temperature\n        stream = self.stream\n\n        custom_headers = {\n            \"FlowTenant\": self.flow_tenant,\n            \"FlowAgent\": retrieve_flow_name(self),\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {self.flow_token}\",\n        }\n        custom_headers = {k: v for k, v in custom_headers.items() if v is not None}\n\n        if provider == \"OpenAI\":\n            # if not self.api_key:\n            #    msg = \"OpenAI API key is required when using OpenAI provider\"\n            #    raise ValueError(msg)\n\n            if model_name in OPENAI_REASONING_MODEL_NAMES:\n                # reasoning models do not support temperature (yet)\n                temperature = None\n\n            if \"gpt-5\" in model_name:\n                temperature = 1  # For gpt-5 models only value 1 is supported\n\n            base_domain = self.flow_domain_url.rstrip(\"/\")\n            proxy_path_base = \"/ai-orchestration-api/v1/openai\"\n            final_base_url = f\"{base_domain}{proxy_path_base}\"\n\n            return ChatOpenAI(\n                model_name=model_name,\n                temperature=temperature,\n                streaming=stream,\n                default_headers=custom_headers,\n                base_url=final_base_url,\n                openai_api_key=None,\n            )\n\n        if provider == \"Anthropic\":\n            # if not self.api_key:\n            #    msg = \"Anthropic API key is required when using Anthropic provider\"\n            #    raise ValueError(msg)\n\n            base_domain = self.flow_domain_url.rstrip(\"/\")\n            proxy_path_base = \"/ai-orchestration-api/v1/bedrock/\"\n            final_base_url = f\"{base_domain}{proxy_path_base}\"\n\n            extra_body_fields = {\n                \"extra_body\": {\n                    \"anthropic_version\": \"bedrock-2023-05-31\",\n                    \"allowedModels\": [model_name],\n                }\n            }\n\n            return ChatAnthropic(\n                model=model_name,\n                temperature=temperature,\n                streaming=stream,\n                anthropic_api_url=final_base_url,\n                default_headers=custom_headers,\n                anthropic_api_key=\"proxy-authentication-handled-by-headers\",\n                model_kwargs=extra_body_fields,\n            )\n\n        if provider == \"Google\":\n            return CustomChatGoogleGenerativeAI(\n                model=model_name,\n                temperature=temperature,\n                streaming=stream,\n                google_api_key=\"proxy-authentication-handled-by-headers\",\n                default_headers=custom_headers,\n                base_url=self.flow_domain_url.rstrip(\"/\"),\n            )\n        msg = f\"Unknown provider: {provider}\"\n        raise ValueError(msg)\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        if field_name == \"provider\":\n            if field_value == \"OpenAI\":\n                build_config[\"model_name\"][\"options\"] = OPENAI_CHAT_MODEL_NAMES + OPENAI_REASONING_MODEL_NAMES\n                build_config[\"model_name\"][\"value\"] = OPENAI_CHAT_MODEL_NAMES[0]\n                # build_config[\"api_key\"][\"display_name\"] = \"OpenAI API Key\"\n            elif field_value == \"Anthropic\":\n                build_config[\"model_name\"][\"options\"] = ANTHROPIC_MODELS\n                build_config[\"model_name\"][\"value\"] = ANTHROPIC_MODELS[0]\n                # build_config[\"api_key\"][\"display_name\"] = \"Anthropic API Key\"\n            elif field_value == \"Google\":\n                build_config[\"model_name\"][\"options\"] = GOOGLE_GENERATIVE_AI_MODELS\n                build_config[\"model_name\"][\"value\"] = GOOGLE_GENERATIVE_AI_MODELS[0]\n                # build_config[\"api_key\"][\"display_name\"] = \"Google API Key\"\n        elif field_name == \"model_name\" and field_value.startswith(\"o1\") and self.provider == \"OpenAI\":\n            # Hide system_message for o1 models - currently unsupported\n            if \"system_message\" in build_config:\n                build_config[\"system_message\"][\"show\"] = False\n        elif field_name == \"model_name\" and not field_value.startswith(\"o1\") and \"system_message\" in build_config:\n            build_config[\"system_message\"][\"show\"] = True\n        return build_config\n\n    # ------------------------------ Helpers -----------------------------------\n\n    def _download_image_as_data_uri(self, url: str) -> str | None:\n        try:\n            resp = requests.get(url, timeout=20)\n            resp.raise_for_status()\n            content = resp.content\n            mime = resp.headers.get(\"Content-Type\")\n            # sanitize MIME: keep only type/subtype and ensure image/*\n            if mime:\n                mime = mime.split(\";\")[0].strip()\n            guessed, _ = mimetypes.guess_type(url)\n            if not mime:\n                mime = guessed\n            if not mime or not mime.startswith(\"image/\"):\n                # default to PNG if unknown or non-image\n                mime = \"image/png\"\n            b64 = base64.b64encode(content).decode(\"ascii\")\n            return f\"data:{mime};base64,{b64}\"\n        except Exception:\n            return None\n\n    def _get_prompt_text(self) -> str:\n        val = getattr(self, \"input_value\", None)\n        # input_value may be a Message, dict-like, or plain string\n        try:\n            text = getattr(val, \"text\", None)\n            if isinstance(text, str):\n                return text\n        except Exception:\n            pass\n        if isinstance(val, str):\n            return val\n        return \"\"\n\n    def _build_messages(self, provider: str, prompt_text: str, data_uri_or_url: str) -> List[HumanMessage | SystemMessage]:\n        messages: List[HumanMessage | SystemMessage] = []\n        if self.system_message:\n            messages.append(SystemMessage(content=self.system_message))\n        # Construct provider-specific multimodal content\n        if provider == \"OpenAI\":\n            # Prefer data URI if available; otherwise use URL\n            content = []\n            if prompt_text:\n                content.append({\"type\": \"text\", \"text\": prompt_text})\n            content.append({\"type\": \"image_url\", \"image_url\": {\"url\": data_uri_or_url.strip(), \"detail\": \"auto\"}})\n            messages.append(HumanMessage(content=content))\n        elif provider == \"Anthropic\":\n            # Anthropic expects {type: \"image\", source: {type: \"base64\" | \"url\", media_type, data}}\n            source: dict\n            if data_uri_or_url.startswith(\"data:image/\"):\n                try:\n                    header, b64 = data_uri_or_url.split(\",\", 1)\n                    media_type = header.split(\";\")[0].split(\":\", 1)[1]\n                    source = {\"type\": \"base64\", \"media_type\": media_type, \"data\": b64}\n                except Exception:\n                    source = {\"type\": \"url\", \"url\": data_uri_or_url}\n            else:\n                source = {\"type\": \"url\", \"url\": data_uri_or_url}\n            content = []\n            if prompt_text:\n                content.append({\"type\": \"text\", \"text\": prompt_text})\n            content.append({\"type\": \"image\", \"source\": source})\n            messages.append(HumanMessage(content=content))\n        else:  # Google or others ‚Äì attempt OpenAI-style content\n            content = []\n            if prompt_text:\n                content.append({\"type\": \"text\", \"text\": prompt_text})\n            content.append({\"type\": \"image_url\", \"image_url\": {\"url\": data_uri_or_url.strip()}})\n            messages.append(HumanMessage(content=content))\n        return messages\n\n    # ------------------------------ Outputs -----------------------------------\n\n    def _resolve_image_url(self) -> str | None:\n        url = getattr(self, \"image_url\", None)\n        if isinstance(url, str) and url.strip():\n            return url.strip().strip(\"`\\\"<>\")\n        # Fallback: try to extract from input_value.files\n        val = getattr(self, \"input_value\", None)\n        try:\n            files = getattr(val, \"files\", None)\n            if files and isinstance(files, list) and len(files) > 0:\n                # treat first file path as local image, convert to data URI\n                path = files[0]\n                try:\n                    with open(path, \"rb\") as f:\n                        data = f.read()\n                    mime, _ = mimetypes.guess_type(path)\n                    mime = mime or \"image/png\"\n                    b64 = base64.b64encode(data).decode(\"ascii\")\n                    return f\"data:{mime};base64,{b64}\"\n                except Exception:\n                    return None\n        except Exception:\n            pass\n        return None\n\n    def _supports_vision(self, provider: str, model_name: str) -> bool:\n        name = (model_name or \"\").lower()\n        if provider == \"OpenAI\":\n            # Heuristics for common OpenAI vision-capable chat models\n            return any(k in name for k in [\"gpt-4o\", \"gpt-4o-mini\", \"gpt-4.1\", \"gpt-4.1-mini\", \"gpt-4-turbo\"])\n        if provider == \"Anthropic\":\n            # Claude 3 family supports vision\n            return \"claude-3\" in name or any(k in name for k in [\"opus\", \"sonnet\", \"haiku\"])  # v3 variants\n        if provider == \"Google\":\n            # Gemini family supports vision\n            return \"gemini\" in name\n        return False\n\n    async def analyze_image_and_text(self) -> Message:\n        provider = self.provider\n        model = self.build_model()\n        prompt = self._get_prompt_text()\n        image_url = self._resolve_image_url()\n        if not image_url:\n            # No image provided; fallback to pure text\n            res = model.invoke([HumanMessage(content=prompt)])\n            text_content = getattr(res, \"content\", str(res))\n            message = await Message.create(\n                text=text_content,\n                sender=MESSAGE_SENDER_AI,\n                sender_name=\"AI\",\n            )\n            self.status = {\"length\": len(text_content or \"\")}\n            return message\n        # If model doesn't support vision, gracefully degrade to text-only\n        if not self._supports_vision(provider, self.model_name):\n            text_only = prompt or \"\"\n            # Include the URL to give model context\n            if isinstance(image_url, str) and image_url:\n                text_only = f\"{text_only}\\nImage URL: {image_url.strip()}\" if text_only else f\"Image URL: {image_url.strip()}\"\n            res = model.invoke([HumanMessage(content=text_only)])\n            text_content = getattr(res, \"content\", str(res))\n            message = await Message.create(\n                text=text_content,\n                sender=MESSAGE_SENDER_AI,\n                sender_name=\"AI\",\n            )\n            self.status = {\"length\": len(text_content or \"\")}\n            return message\n        # Try downloading as data URI for robustness\n        data_uri = self._download_image_as_data_uri(image_url)\n        effective = (data_uri or image_url).strip()\n        messages = self._build_messages(provider, prompt, effective)\n        res = model.invoke(messages)\n        text_content = getattr(res, \"content\", str(res))\n        message = await Message.create(\n            text=text_content,\n            sender=MESSAGE_SENDER_AI,\n            sender_name=\"AI\",\n        )\n        self.status = {\"length\": len(text_content or \"\")}\n        return message\n\n    def analyze_image_and_text_raw(self):\n        provider = self.provider\n        model = self.build_model()\n        prompt = self._get_prompt_text()\n        image_url = self._resolve_image_url()\n        # Degrade if model doesn't support vision\n        if image_url and not self._supports_vision(provider, self.model_name):\n            text_only = prompt or \"\"\n            text_only = f\"{text_only}\\nImage URL: {image_url.strip()}\" if text_only else f\"Image URL: {image_url.strip()}\"\n            messages = [HumanMessage(content=text_only)]\n        else:\n            data_uri = self._download_image_as_data_uri(image_url) if image_url else None\n            effective = (data_uri or image_url).strip() if (data_uri or image_url) else None\n            messages = self._build_messages(provider, prompt, effective) if effective else [HumanMessage(content=prompt)]\n        res = model.invoke(messages)\n        # Return structured raw info\n        return dotdict({\n            \"value\": {\n                \"content\": getattr(res, \"content\", None),\n                \"additional_kwargs\": getattr(res, \"additional_kwargs\", {}),\n                \"id\": getattr(res, \"id\", None),\n            }\n        })\n"
              },
              "image_url": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Image URL",
                "dynamic": false,
                "info": "Optional: If provided, the component will download the image and send it with the prompt.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "image_url",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input text to send to the model",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Name",
                "dynamic": false,
                "external_options": {},
                "info": "Select the model to use",
                "load_from_db": false,
                "name": "model_name",
                "options": [
                  "gpt-4o",
                  "gpt-4.1",
                  "gpt-4o-mini",
                  "gpt-5",
                  "gpt-5-mini",
                  "gpt-5-nano",
                  "o1",
                  "o1-mini",
                  "o3-mini"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gpt-4o-mini"
              },
              "provider": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Provider",
                "dynamic": false,
                "external_options": {},
                "info": "Select the model provider",
                "name": "provider",
                "options": [
                  "OpenAI",
                  "Anthropic",
                  "Google"
                ],
                "options_metadata": [
                  {
                    "icon": "OpenAI"
                  },
                  {
                    "icon": "Anthropic"
                  },
                  {
                    "icon": "GoogleGenerativeAI"
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "OpenAI"
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Whether to stream the response",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "A system message that helps set the behavior of the assistant",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "ÂÆ¢ËßÇÊèèËø∞ÂõæÁâá‰∏äÁöÑÂÜÖÂÆπÔºåËØ∑ÊëòË¶ÅÊÄªÁªìÊàêÈÄÇÂêàÊí≠ÂÆ¢ÊºîËÆ≤ÁöÑËØùÊúØÔºåËøîÂõûÂÜÖÂÆπ‰∏∫jsonÊ†ºÂºèÔºåËØ∑Âè™ËøîÂõûjsonÂØπË±°Ôºå‰∏çË¶ÅËøîÂõûÊï∞ÁªÑ {{\"desc\":\"ÂõæÁâáÊèèËø∞\",\"oral_broadcast\":\"Âè£Êí≠ÂÜÖÂÆπ\"}}"
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness in responses",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 1,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              }
            },
            "tool_mode": false
          },
          "selected_output": "text_output",
          "showNode": true,
          "type": "LanguageModelComponent"
        },
        "dragging": false,
        "id": "LanguageModelComponent-6o3Gn",
        "measured": {
          "height": 634,
          "width": 320
        },
        "position": {
          "x": 11008.849087135322,
          "y": 4893.348935159364
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "LoopComponent-93yXb",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Êé•Êî∂‰∏Ä‰∏™ÂåÖÂê´ÂõæÁâáURLÂàóË°®ÁöÑDataÊàñDataFrameÔºåÊåâÈ°∫Â∫èÈÄê‰∏™ËæìÂá∫ÂõæÁâáURLÔºåÂπ∂ËÅöÂêà‰∏ãÊ∏∏Â§ÑÁêÜÁªìÊûú„ÄÇ",
            "display_name": "loop image URL",
            "documentation": "https://docs.langflow.org/components-logic#loop",
            "edited": true,
            "field_order": [
              "data"
            ],
            "frozen": false,
            "icon": "infinity",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": true,
                "cache": true,
                "display_name": "ÂΩìÂâçÂõæÁâáURL",
                "group_outputs": true,
                "hidden": null,
                "method": "item_output",
                "name": "item",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "ÂÆåÊàêËÅöÂêà",
                "group_outputs": true,
                "hidden": null,
                "method": "done_output",
                "name": "done",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.template.field.base import Output\n\n\nclass LoopComponent(Component):\n    display_name = \"loop image URL\"\n    description = (\n        \"Êé•Êî∂‰∏Ä‰∏™ÂåÖÂê´ÂõæÁâáURLÂàóË°®ÁöÑDataÊàñDataFrameÔºåÊåâÈ°∫Â∫èÈÄê‰∏™ËæìÂá∫ÂõæÁâáURLÔºåÂπ∂ËÅöÂêà‰∏ãÊ∏∏Â§ÑÁêÜÁªìÊûú„ÄÇ\"\n    )\n    documentation: str = \"https://docs.langflow.org/components-logic#loop\"\n    icon = \"infinity\"\n\n    inputs = [\n        HandleInput(\n            name=\"data\",\n            display_name=\"ÂõæÁâáÂàóË°®ËæìÂÖ•\",\n            info=\"Êù•Ëá™‰∏äÊ∏∏ÁöÑÂõæÁâáURLÂàóË°®ÔºåÊîØÊåÅData(value=list[str])ÊàñDataFrame(Data)„ÄÇ\",\n            input_types=[\"Data\", \"DataFrame\"],\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"ÂΩìÂâçÂõæÁâáURL\", name=\"item\", method=\"item_output\", allows_loop=True, group_outputs=True),\n        Output(display_name=\"ÂÆåÊàêËÅöÂêà\", name=\"done\", method=\"done_output\", group_outputs=True),\n    ]\n\n    def initialize_data(self) -> None:\n        \"\"\"Initialize the data list, context index, and aggregated list.\"\"\"\n        if self.ctx.get(f\"{self._id}_initialized\", False):\n            return\n\n        # Ensure data is a list of Data objects\n        data_list = self._validate_data(self.data)\n\n        # Store the initial data and context variables\n        self.update_ctx(\n            {\n                f\"{self._id}_data\": data_list,\n                f\"{self._id}_index\": 0,\n                f\"{self._id}_aggregated\": [],\n                f\"{self._id}_initialized\": True,\n            }\n        )\n\n    def _validate_data(self, data):\n        \"\"\"Normalize input to a list of Data objects.\n\n        ÊîØÊåÅÔºö\n        - DataFrame -> list[Data]\n        - Data(value=list[str]) -> list[Data(value=str)]\n        - Data -> [Data]\n        - list[Data]\n        \"\"\"\n        if isinstance(data, DataFrame):\n            return data.to_data_list()\n        if isinstance(data, Data):\n            # Â¶ÇÊûúÊòØ Data ‰∏î value ÊòØÂõæÁâáURLÂàóË°®\n            if isinstance(getattr(data, \"value\", None), list) and all(isinstance(x, str) for x in data.value):\n                return [Data(value=url) for url in data.value]\n            return [data]\n        if isinstance(data, list) and all(isinstance(item, Data) for item in data):\n            return data\n        msg = \"'data' ËæìÂÖ•ÂøÖÈ°ªÊòØ DataFrame„ÄÅÂåÖÂê´Â≠óÁ¨¶‰∏≤ÂàóË°®ÁöÑ DataÔºåÊàñ Data ÂàóË°®„ÄÇ\"\n        raise TypeError(msg)\n\n    def evaluate_stop_loop(self) -> bool:\n        \"\"\"Evaluate whether to stop item or done output.\"\"\"\n        current_index = self.ctx.get(f\"{self._id}_index\", 0)\n        data_length = len(self.ctx.get(f\"{self._id}_data\", []))\n        return current_index >= data_length\n\n    def item_output(self) -> Data:\n        \"\"\"ËæìÂá∫‰∏ã‰∏Ä‰∏™ÂõæÁâáURL‰∏∫ Data(value=str)ÔºåÊàñÂú®ÂÆåÊàêÊó∂ÂÅúÊ≠¢„ÄÇ\"\"\"\n        self.initialize_data()\n        current_item = Data(value=\"\")\n\n        if self.evaluate_stop_loop():\n            self.stop(\"item\")\n        else:\n            data_list, current_index = self.loop_variables()\n            if current_index < len(data_list):\n                try:\n                    current_item = data_list[current_index]\n                except IndexError:\n                    current_item = Data(value=\"\")\n            # ËÅöÂêà‰∏ãÊ∏∏Â§ÑÁêÜÁªìÊûúÔºàÂ¶ÇÊûúÊúâËøûÊé•Ôºâ\n            self.aggregated_output(current_item)\n            self.update_ctx({f\"{self._id}_index\": current_index + 1})\n\n        self.update_dependency()\n        return current_item\n\n    def update_dependency(self):\n        item_dependency_id = self.get_incoming_edge_by_target_param(\"item\")\n        if item_dependency_id not in self.graph.run_manager.run_predecessors[self._id]:\n            self.graph.run_manager.run_predecessors[self._id].append(item_dependency_id)\n\n    def done_output(self) -> DataFrame:\n        \"\"\"Ëø≠‰ª£ÂÆåÊàêÊó∂ËæìÂá∫ËÅöÂêàÁöÑ‰∏ãÊ∏∏ÁªìÊûú‰∏∫ DataFrameÔºàÊØèÈ°π‰∏∫Â≠óÁ¨¶‰∏≤Ôºâ„ÄÇ\"\"\"\n        self.initialize_data()\n\n        if self.evaluate_stop_loop():\n            self.stop(\"item\")\n            self.start(\"done\")\n            aggregated = self.ctx.get(f\"{self._id}_aggregated\", [])\n            # Â∞ÜÂ≠óÁ¨¶‰∏≤ÁªìÊûúÂåÖË£Ö‰∏∫ Data ‰ª•ÈÄÇÈÖç DataFrame\n            df_items = [Data(value=item) if not isinstance(item, Data) else item for item in aggregated]\n            return DataFrame(df_items)\n        self.stop(\"done\")\n        return DataFrame([])\n\n    def loop_variables(self):\n        \"\"\"Retrieve loop variables from context.\"\"\"\n        return (\n            self.ctx.get(f\"{self._id}_data\", []),\n            self.ctx.get(f\"{self._id}_index\", 0),\n        )\n\n    def aggregated_output(self, item: Data | str) -> list[str]:\n        \"\"\"ËÅöÂêàÂΩìÂâçÈ°πÁöÑÂ≠óÁ¨¶‰∏≤ÁªìÊûúÔºàÊó†Â§ñÈÉ®ËæìÂÖ•Ôºâ„ÄÇ\"\"\"\n        self.initialize_data()\n        data_list = self.ctx.get(f\"{self._id}_data\", [])\n        aggregated = self.ctx.get(f\"{self._id}_aggregated\", [])\n        if len(aggregated) < len(data_list):\n            # Â∞ÜÂΩìÂâçÈ°πÂΩí‰∏Ä‰∏∫Â≠óÁ¨¶‰∏≤\n            if isinstance(item, Data):\n                value = getattr(item, \"value\", None)\n                value = \"\" if value is None else (value if isinstance(value, str) else str(value))\n                aggregated.append(value)\n            else:\n                aggregated.append(str(item))\n            self.update_ctx({f\"{self._id}_aggregated\": aggregated})\n        return aggregated\n"
              },
              "data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "ÂõæÁâáÂàóË°®ËæìÂÖ•",
                "dynamic": false,
                "info": "Êù•Ëá™‰∏äÊ∏∏ÁöÑÂõæÁâáURLÂàóË°®ÔºåÊîØÊåÅData(value=list[str])ÊàñDataFrame(Data)„ÄÇ",
                "input_types": [
                  "Data",
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "LoopComponent"
        },
        "id": "LoopComponent-93yXb",
        "measured": {
          "height": 238,
          "width": 320
        },
        "position": {
          "x": 9777.040180712222,
          "y": 5527.0595909236
        },
        "selected": true,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "APIRequest-yuDNo",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Make HTTP requests using URL or cURL commands.",
            "display_name": "Context API Request",
            "documentation": "https://docs.langflow.org/components-data#api-request",
            "edited": true,
            "field_order": [
              "url_input",
              "img_url",
              "context",
              "curl_input",
              "method",
              "mode",
              "query_params",
              "body",
              "headers",
              "timeout",
              "follow_redirects",
              "save_to_file",
              "include_httpx_metadata"
            ],
            "frozen": false,
            "icon": "Globe",
            "last_updated": "2025-11-21T01:08:30.141Z",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "API Response",
                "group_outputs": false,
                "hidden": null,
                "method": "make_api_request",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "body": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Body",
                "dynamic": false,
                "info": "The body to send with the request as a dictionary (for POST, PATCH, PUT).",
                "input_types": [
                  "Data"
                ],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "body",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "description": "Parameter name",
                      "disable_edit": false,
                      "display_name": "Key",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "key",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "Parameter value",
                      "disable_edit": false,
                      "display_name": "Value",
                      "edit_mode": "popover",
                      "filterable": true,
                      "hidden": false,
                      "name": "value",
                      "sortable": true
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": []
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nimport re\nimport tempfile\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Any\nfrom urllib.parse import parse_qsl, urlencode, urlparse, urlunparse\n\nimport aiofiles\nimport aiofiles.os as aiofiles_os\nimport httpx\nimport validators\n\nfrom langflow.base.curl.parse import parse_context\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import TabInput\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    IntInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TableInput,\n)\nfrom langflow.schema.data import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.services.deps import get_settings_service\nfrom langflow.utils.component_utils import set_current_fields, set_field_advanced, set_field_display\n\n# Define fields for each mode\nMODE_FIELDS = {\n    \"URL\": [\n        \"url_input\",\n        \"method\",\n    ],\n    \"cURL\": [\"curl_input\"],\n}\n\n# Fields that should always be visible\nDEFAULT_FIELDS = [\"mode\"]\n\n\nclass APIRequestComponent(Component):\n    display_name = \"Context API Request\"\n    description = \"Make HTTP requests using URL or cURL commands.\"\n    documentation: str = \"https://docs.langflow.org/components-data#api-request\"\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"url_input\",\n            display_name=\"URL\",\n            info=\"Enter the URL for the request.\",\n            advanced=False,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"img_url\",\n            display_name=\"Image URL\",\n            info=(\n                \"ÂõæÁâáÂú∞ÂùÄÔºå‰ªÖÁî®‰∫éËá™Âä®ÊèêÂèñ uuid ‰∏éÈ°µÁ†ÅÔºõÁõÆÊ†á URL ËØ∑Âú®‰∏äÊñπ URL Â≠óÊÆµÂ°´ÂÜôÔºà‰∏çÂÜç‰ªéÂõæÁâá URL Êé®ÂØºÔºâ„ÄÇ\\n\"\n                \"Á§∫‰æã: http://8.137.117.155:8703/image?path=/tmp/ppt_images/<uuid>/images/page_10.png\"\n            ),\n            advanced=False,\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"context\",\n            display_name=\"Context JSON\",\n            info=(\n                \"‰∏ä‰∏ãÊñáÂ≠óÊÆµÔºåJSON Ê†ºÂºèÔºåËá≥Â∞ëÂåÖÂê´ desc ‰∏é oral_broadcast„ÄÇ\\n\"\n                \"Á§∫‰æã: {\\\"desc\\\": \\\"...\\\", \\\"oral_broadcast\\\": \\\"...\\\"}\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=False,\n        ),\n        MultilineInput(\n            name=\"curl_input\",\n            display_name=\"cURL\",\n            info=(\n                \"Paste a curl command to populate the fields. \"\n                \"This will fill in the dictionary fields for headers and body.\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=True,\n            show=False,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"],\n            value=\"GET\",\n            info=\"The HTTP method to use.\",\n            real_time_refresh=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"URL\", \"cURL\"],\n            value=\"URL\",\n            info=\"Enable cURL mode to populate fields from a cURL command.\",\n            real_time_refresh=True,\n        ),\n        DataInput(\n            name=\"query_params\",\n            display_name=\"Query Parameters\",\n            info=\"The query parameters to append to the URL.\",\n            advanced=True,\n        ),\n        TableInput(\n            name=\"body\",\n            display_name=\"Body\",\n            info=\"The body to send with the request as a dictionary (for POST, PATCH, PUT).\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Key\",\n                    \"type\": \"str\",\n                    \"description\": \"Parameter name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"description\": \"Parameter value\",\n                },\n            ],\n            value=[],\n            input_types=[\"Data\"],\n            advanced=True,\n            real_time_refresh=True,\n        ),\n        TableInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Header\",\n                    \"type\": \"str\",\n                    \"description\": \"Header name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"type\": \"str\",\n                    \"description\": \"Header value\",\n                },\n            ],\n            value=[{\"key\": \"User-Agent\", \"value\": get_settings_service().settings.user_agent}],\n            advanced=True,\n            input_types=[\"Data\"],\n            real_time_refresh=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            value=30,\n            info=\"The timeout to use for the request.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"follow_redirects\",\n            display_name=\"Follow Redirects\",\n            value=True,\n            info=\"Whether to follow http redirects.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"save_to_file\",\n            display_name=\"Save to File\",\n            value=False,\n            info=\"Save the API response to a temporary file\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_httpx_metadata\",\n            display_name=\"Include HTTPx Metadata\",\n            value=False,\n            info=(\n                \"Include properties such as headers, status_code, response_headers, \"\n                \"and redirection_history in the output.\"\n            ),\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"API Response\", name=\"data\", method=\"make_api_request\"),\n    ]\n\n    def _parse_json_value(self, value: Any) -> Any:\n        \"\"\"Parse a value that might be a JSON string.\"\"\"\n        if not isinstance(value, str):\n            return value\n\n        try:\n            parsed = json.loads(value)\n        except json.JSONDecodeError:\n            return value\n        else:\n            return parsed\n\n    def _process_body(self, body: Any) -> dict:\n        \"\"\"Process the body input into a valid dictionary.\"\"\"\n        if body is None:\n            return {}\n        if hasattr(body, \"data\"):\n            body = body.data\n        if isinstance(body, dict):\n            return self._process_dict_body(body)\n        if isinstance(body, str):\n            return self._process_string_body(body)\n        if isinstance(body, list):\n            return self._process_list_body(body)\n        return {}\n\n    def _process_dict_body(self, body: dict) -> dict:\n        \"\"\"Process dictionary body by parsing JSON values.\"\"\"\n        return {k: self._parse_json_value(v) for k, v in body.items()}\n\n    def _process_string_body(self, body: str) -> dict:\n        \"\"\"Process string body by attempting JSON parse.\"\"\"\n        try:\n            return self._process_body(json.loads(body))\n        except json.JSONDecodeError:\n            return {\"data\": body}\n\n    def _process_list_body(self, body: list) -> dict:\n        \"\"\"Process list body by converting to key-value dictionary.\"\"\"\n        processed_dict = {}\n        try:\n            for item in body:\n                # Unwrap Data objects\n                current_item = item\n                if hasattr(item, \"data\"):\n                    unwrapped_data = item.data\n                    # If the unwrapped data is a dict but not key-value format, use it directly\n                    if isinstance(unwrapped_data, dict) and not self._is_valid_key_value_item(unwrapped_data):\n                        return unwrapped_data\n                    current_item = unwrapped_data\n                if not self._is_valid_key_value_item(current_item):\n                    continue\n                key = current_item[\"key\"]\n                value = self._parse_json_value(current_item[\"value\"])\n                processed_dict[key] = value\n        except (KeyError, TypeError, ValueError) as e:\n            self.log(f\"Failed to process body list: {e}\")\n            return {}\n        return processed_dict\n\n    def _is_valid_key_value_item(self, item: Any) -> bool:\n        \"\"\"Check if an item is a valid key-value dictionary.\"\"\"\n        return isinstance(item, dict) and \"key\" in item and \"value\" in item\n\n    def parse_curl(self, curl: str, build_config: dotdict) -> dotdict:\n        \"\"\"Parse a cURL command and update build configuration.\"\"\"\n        try:\n            parsed = parse_context(curl)\n\n            # Update basic configuration\n            url = parsed.url\n            # Normalize URL before setting it\n            url = self._normalize_url(url)\n\n            build_config[\"url_input\"][\"value\"] = url\n            build_config[\"method\"][\"value\"] = parsed.method.upper()\n\n            # Process headers\n            headers_list = [{\"key\": k, \"value\": v} for k, v in parsed.headers.items()]\n            build_config[\"headers\"][\"value\"] = headers_list\n\n            # Process body data\n            if not parsed.data:\n                build_config[\"body\"][\"value\"] = []\n            elif parsed.data:\n                try:\n                    json_data = json.loads(parsed.data)\n                    if isinstance(json_data, dict):\n                        body_list = [\n                            {\"key\": k, \"value\": json.dumps(v) if isinstance(v, dict | list) else str(v)}\n                            for k, v in json_data.items()\n                        ]\n                        build_config[\"body\"][\"value\"] = body_list\n                    else:\n                        build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": json.dumps(json_data)}]\n                except json.JSONDecodeError:\n                    build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": parsed.data}]\n\n        except Exception as exc:\n            msg = f\"Error parsing curl: {exc}\"\n            self.log(msg)\n            raise ValueError(msg) from exc\n\n        return build_config\n\n    def _normalize_url(self, url: str) -> str:\n        \"\"\"Normalize URL by adding https:// if no protocol is specified.\"\"\"\n        if not url or not isinstance(url, str):\n            msg = \"URL cannot be empty\"\n            raise ValueError(msg)\n\n        url = url.strip()\n        if url.startswith((\"http://\", \"https://\")):\n            return url\n        return f\"https://{url}\"\n\n    def _extract_uuid_id_from_img(self, img_url: str) -> tuple[str, str, str]:\n        \"\"\"‰ªé img_url ‰∏≠ÊèêÂèñ (base_context_url, uuid, id_str)„ÄÇ\n\n        - base_context_url: ÈÄöËøá img_url ÁöÑ scheme+netloc ÊûÑÂª∫ /context ÁõÆÊ†áÂú∞ÂùÄ\n        - uuid: ‰ªé query ÂèÇÊï∞ path ÁöÑ '/ppt_images/<uuid>/images/' ‰∏≠ÊèêÂèñ\n        - id_str: ‰ªé 'page_<n>.png' ‰∏≠ÊèêÂèñÊï∞Â≠óÈÉ®ÂàÜ\n        \"\"\"\n        if not isinstance(img_url, str) or not img_url.strip():\n            raise ValueError(\"img_url ‰∏çËÉΩ‰∏∫Á©∫\")\n\n        parsed = urlparse(img_url)\n        if not parsed.scheme or not parsed.netloc:\n            raise ValueError(\"img_url ÈùûÊ≥ï: Áº∫Â∞ëÂçèËÆÆÊàñ‰∏ªÊú∫\")\n        base_context_url = f\"{parsed.scheme}://{parsed.netloc}/context\"\n\n        query_dict = dict(parse_qsl(parsed.query))\n        path_value = query_dict.get(\"path\", parsed.path or \"\")\n        if not path_value:\n            raise ValueError(\"img_url ‰∏≠Êú™ÊâæÂà∞ path ÂèÇÊï∞\")\n\n        # ÊèêÂèñ uuid\n        uuid_match = re.search(r\"/ppt_images/([^/]+)/images/\", path_value)\n        if not uuid_match:\n            raise ValueError(\"Êó†Ê≥ï‰ªé img_url ÁöÑ path ‰∏≠Ëß£Êûê uuid\")\n        uuid_val = uuid_match.group(1)\n\n        # ÊèêÂèñÈ°µÂè∑ id\n        id_match = re.search(r\"page_(\\d+)\\.png\", path_value)\n        if not id_match:\n            raise ValueError(\"Êó†Ê≥ï‰ªé img_url ÁöÑ path ‰∏≠Ëß£ÊûêÈ°µÂè∑ id\")\n        id_str = id_match.group(1)\n\n        return base_context_url, uuid_val, id_str\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: dict | None = None,\n        body: Any = None,\n        timeout: int = 5,\n        *,\n        follow_redirects: bool = True,\n        save_to_file: bool = False,\n        include_httpx_metadata: bool = False,\n    ) -> Data:\n        method = method.upper()\n        if method not in {\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"}:\n            msg = f\"Unsupported method: {method}\"\n            raise ValueError(msg)\n\n        processed_body = self._process_body(body)\n        redirection_history = []\n\n        try:\n            # Prepare request parameters\n            request_params = {\n                \"method\": method,\n                \"url\": url,\n                \"headers\": headers,\n                \"json\": processed_body,\n                \"timeout\": timeout,\n                \"follow_redirects\": follow_redirects,\n            }\n            response = await client.request(**request_params)\n\n            redirection_history = [\n                {\n                    \"url\": redirect.headers.get(\"Location\", str(redirect.url)),\n                    \"status_code\": redirect.status_code,\n                }\n                for redirect in response.history\n            ]\n\n            is_binary, file_path = await self._response_info(response, with_file_path=save_to_file)\n            response_headers = self._headers_to_dict(response.headers)\n\n            # Base metadata\n            metadata = {\n                \"source\": url,\n                \"status_code\": response.status_code,\n                \"response_headers\": response_headers,\n            }\n\n            if redirection_history:\n                metadata[\"redirection_history\"] = redirection_history\n\n            if save_to_file:\n                mode = \"wb\" if is_binary else \"w\"\n                encoding = response.encoding if mode == \"w\" else None\n                if file_path:\n                    await aiofiles_os.makedirs(file_path.parent, exist_ok=True)\n                    if is_binary:\n                        async with aiofiles.open(file_path, \"wb\") as f:\n                            await f.write(response.content)\n                            await f.flush()\n                    else:\n                        async with aiofiles.open(file_path, \"w\", encoding=encoding) as f:\n                            await f.write(response.text)\n                            await f.flush()\n                    metadata[\"file_path\"] = str(file_path)\n\n                if include_httpx_metadata:\n                    metadata.update({\"headers\": headers})\n                return Data(data=metadata)\n\n            # Handle response content\n            if is_binary:\n                result = response.content\n            else:\n                try:\n                    result = response.json()\n                except json.JSONDecodeError:\n                    self.log(\"Failed to decode JSON response\")\n                    result = response.text.encode(\"utf-8\")\n\n            metadata[\"result\"] = result\n\n            if include_httpx_metadata:\n                metadata.update({\"headers\": headers})\n\n            return Data(data=metadata)\n        except (httpx.HTTPError, httpx.RequestError, httpx.TimeoutException) as exc:\n            self.log(f\"Error making request to {url}\")\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 500,\n                    \"error\": str(exc),\n                    **({\"redirection_history\": redirection_history} if redirection_history else {}),\n                },\n            )\n\n    def add_query_params(self, url: str, params: dict) -> str:\n        \"\"\"Add query parameters to URL efficiently.\"\"\"\n        if not params:\n            return url\n        url_parts = list(urlparse(url))\n        query = dict(parse_qsl(url_parts[4]))\n        query.update(params)\n        url_parts[4] = urlencode(query)\n        return urlunparse(url_parts)\n\n    def _headers_to_dict(self, headers: httpx.Headers) -> dict[str, str]:\n        \"\"\"Convert HTTP headers to a dictionary with lowercased keys.\"\"\"\n        return {k.lower(): v for k, v in headers.items()}\n\n    def _process_headers(self, headers: Any) -> dict:\n        \"\"\"Process the headers input into a valid dictionary.\"\"\"\n        if headers is None:\n            return {}\n        if isinstance(headers, dict):\n            return headers\n        if isinstance(headers, list):\n            # Mudan√ßa para aceitar Flow Credentials\n            if isinstance(headers[0], Data):\n                return headers[0].data[\"headers\"]\n            return {item[\"key\"]: item[\"value\"] for item in headers if self._is_valid_key_value_item(item)}\n        return {}\n\n    async def make_api_request(self) -> Data:\n        \"\"\"Make HTTP request with optimized parameter handling.\"\"\"\n        method = self.method\n        url = self.url_input.strip() if isinstance(self.url_input, str) else \"\"\n        headers = self.headers or {}\n        body = self.body or {}\n        timeout = self.timeout\n        follow_redirects = self.follow_redirects\n        save_to_file = self.save_to_file\n        include_httpx_metadata = self.include_httpx_metadata\n\n        # if self.mode == \"cURL\" and self.curl_input:\n        #     self._build_config = self.parse_curl(self.curl_input, dotdict())\n        #     # After parsing curl, get the normalized URL\n        #     url = self._build_config[\"url_input\"][\"value\"]\n\n        # Â¶ÇÊûúÊèê‰æõ‰∫Ü contextÔºåÂàôËá™Âä®ÊûÑÂª∫ /context ÁöÑ POST ËØ∑Ê±ÇÔºõÂõæÁâáÂú∞ÂùÄ‰ºòÂÖà‰ªé context JSON Ëé∑Âèñ\n        use_ctx_builder = (\n            isinstance(getattr(self, \"context\", None), str)\n            and self.context.strip()\n        )\n\n        if use_ctx_builder:\n            # Âº∫Âà∂Ë¶ÅÊ±ÇÁî®Êà∑Êèê‰æõÁõÆÊ†á URLÔºà‰æãÂ¶Ç /context Êé•Âè£Âú∞ÂùÄÔºâ\n            if not isinstance(self.url_input, str) or not self.url_input.strip():\n                raise ValueError(\"Êú™Êèê‰æõÁõÆÊ†á URLÔºàURL Â≠óÊÆµÔºâ„ÄÇËØ∑Â°´ÂÜô /context Êé•Âè£Âú∞ÂùÄ„ÄÇ\")\n\n            # Ëß£Êûê context JSON\n            try:\n                ctx_obj = json.loads(self.context)\n            except json.JSONDecodeError:\n                raise ValueError(\"context ÂøÖÈ°ªÊòØÂêàÊ≥ïÁöÑ JSON Â≠óÁ¨¶‰∏≤Ôºå‰∏îËá≥Â∞ëÂåÖÂê´ audio_url„ÄÅvideo_url„ÄÅsubtitle_urlÔºõÊé®ËçêÂåÖÂê´ image_url\")\n\n            if not isinstance(ctx_obj, dict):\n                raise ValueError(\"context JSON ÂøÖÈ°ªËß£Êûê‰∏∫ÂØπË±°\")\n\n            # ËØªÂèñÂ™í‰Ωì URLÔºàÂøÖÈ°ªÔºâ\n            audio_url = ctx_obj.get(\"audio_url\")\n            video_url = ctx_obj.get(\"video_url\")\n            subtitle_url = ctx_obj.get(\"subtitle_url\")\n            if audio_url is None or video_url is None or subtitle_url is None:\n                raise ValueError(\"context JSON ÈúÄÂåÖÂê´ audio_url„ÄÅvideo_url„ÄÅsubtitle_url Â≠óÊÆµ\")\n\n            # ÂõæÁâáÂú∞ÂùÄ‰ºòÂÖà‰ªé context JSON ‰∏≠ËØªÂèñÔºåÁº∫Â§±ÂàôÂõûÈÄÄÂà∞ËæìÂÖ•Ê°Ü img_url\n            image_url = ctx_obj.get(\"img_url\")\n            if not image_url:\n                image_url = self.img_url.strip() if isinstance(self.img_url, str) and self.img_url.strip() else None\n            if not image_url:\n                raise ValueError(\"Êú™Êèê‰æõÂõæÁâáÂú∞ÂùÄ„ÄÇËØ∑Âú® context JSON ‰∏≠Âä†ÂÖ• image_urlÔºåÊàñÂú® Image URL Â≠óÊÆµÂ°´ÂÜô„ÄÇ\")\n\n            # ‰ªéÂõæÁâá URL ‰∏≠ÊèêÂèñ uuid ‰∏éÈ°µÁ†Å id\n            try:\n                _, uuid_val, id_str = self._extract_uuid_id_from_img(image_url)\n            except ValueError as e:\n                raise ValueError(f\"ÊûÑÂª∫ËØ∑Ê±ÇÂ§±Ë¥•: {e}\")\n\n            # ÊûÑÂª∫ÁõÆÊ†áËØ∑Ê±Ç\n            method = \"POST\"\n            url = self.url_input.strip()\n            # ÂÖàËßÑËåÉÂåñ headers ‰∏∫Â≠óÂÖ∏ÔºåÂÜçËÆæÁΩÆ Content-TypeÔºåÈÅøÂÖç‚Äúlist ‰∏çÊòØÊò†Â∞Ñ‚ÄùÈîôËØØ\n            headers = self._process_headers(headers)\n            headers[\"Content-Type\"] = \"application/json\"\n            body = {\n                \"uuid\": uuid_val,\n                \"item\": {\n                    \"id\": id_str,\n                    \"order\": id_str,\n                    \"image_url\": image_url,\n                    \"audio_url\": audio_url,\n                    \"video_url\": video_url,\n                    \"subtitle_url\": subtitle_url,\n                },\n            }\n\n        # Normalize URL before validationÔºàÊ≠§Êó∂ÂèØËÉΩÊòØÁî®Êà∑‰º†ÁöÑ URL ÊàñËá™Âä®ÊûÑÂª∫ÁöÑ /contextÔºâ\n        url = self._normalize_url(url)\n\n        # Validate URL\n        if not validators.url(url):\n            msg = f\"Invalid URL provided: {url}\"\n            raise ValueError(msg)\n\n        # Process query parameters\n        if isinstance(self.query_params, str):\n            query_params = dict(parse_qsl(self.query_params))\n        else:\n            query_params = self.query_params.data if self.query_params else {}\n\n        # Process headers and body\n        headers = self._process_headers(headers)\n        body = self._process_body(body)\n        url = self.add_query_params(url, query_params)\n\n        async with httpx.AsyncClient() as client:\n            result = await self.make_request(\n                client,\n                method,\n                url,\n                headers,\n                body,\n                timeout,\n                follow_redirects=follow_redirects,\n                save_to_file=save_to_file,\n                include_httpx_metadata=include_httpx_metadata,\n            )\n        self.status = result\n        return result\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        \"\"\"Update the build config based on the selected mode.\"\"\"\n        if field_name != \"mode\":\n            if field_name == \"curl_input\" and self.mode == \"cURL\" and self.curl_input:\n                return self.parse_curl(self.curl_input, build_config)\n            return build_config\n\n        if field_value == \"cURL\":\n            set_field_display(build_config, \"curl_input\", value=True)\n            if build_config[\"curl_input\"][\"value\"]:\n                build_config = self.parse_curl(build_config[\"curl_input\"][\"value\"], build_config)\n        else:\n            set_field_display(build_config, \"curl_input\", value=False)\n\n        return set_current_fields(\n            build_config=build_config,\n            action_fields=MODE_FIELDS,\n            selected_action=field_value,\n            default_fields=DEFAULT_FIELDS,\n            func=set_field_advanced,\n            default_value=True,\n        )\n\n    async def _response_info(\n        self, response: httpx.Response, *, with_file_path: bool = False\n    ) -> tuple[bool, Path | None]:\n        \"\"\"Determine the file path and whether the response content is binary.\n\n        Args:\n            response (Response): The HTTP response object.\n            with_file_path (bool): Whether to save the response content to a file.\n\n        Returns:\n            Tuple[bool, Path | None]:\n                A tuple containing a boolean indicating if the content is binary and the full file path (if applicable).\n        \"\"\"\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        is_binary = \"application/octet-stream\" in content_type or \"application/binary\" in content_type\n\n        if not with_file_path:\n            return is_binary, None\n\n        component_temp_dir = Path(tempfile.gettempdir()) / self.__class__.__name__\n\n        # Create directory asynchronously\n        await aiofiles_os.makedirs(component_temp_dir, exist_ok=True)\n\n        filename = None\n        if \"Content-Disposition\" in response.headers:\n            content_disposition = response.headers[\"Content-Disposition\"]\n            filename_match = re.search(r'filename=\"(.+?)\"', content_disposition)\n            if filename_match:\n                extracted_filename = filename_match.group(1)\n                filename = extracted_filename\n\n        # Step 3: Infer file extension or use part of the request URL if no filename\n        if not filename:\n            # Extract the last segment of the URL path\n            url_path = urlparse(str(response.request.url) if response.request else \"\").path\n            base_name = Path(url_path).name  # Get the last segment of the path\n            if not base_name:  # If the path ends with a slash or is empty\n                base_name = \"response\"\n\n            # Infer file extension\n            content_type_to_extension = {\n                \"text/plain\": \".txt\",\n                \"application/json\": \".json\",\n                \"image/jpeg\": \".jpg\",\n                \"image/png\": \".png\",\n                \"application/octet-stream\": \".bin\",\n            }\n            extension = content_type_to_extension.get(content_type, \".bin\" if is_binary else \".txt\")\n            filename = f\"{base_name}{extension}\"\n\n        # Step 4: Define the full file path\n        file_path = component_temp_dir / filename\n\n        # Step 5: Check if file exists asynchronously and handle accordingly\n        try:\n            # Try to create the file exclusively (x mode) to check existence\n            async with aiofiles.open(file_path, \"x\") as _:\n                pass  # File created successfully, we can use this path\n        except FileExistsError:\n            # If file exists, append a timestamp to the filename\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d%H%M%S%f\")\n            file_path = component_temp_dir / f\"{timestamp}-{filename}\"\n\n        return is_binary, file_path\nimport json\nimport re\nimport tempfile\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Any\nfrom urllib.parse import parse_qsl, urlencode, urlparse, urlunparse\n\nimport aiofiles\nimport aiofiles.os as aiofiles_os\nimport httpx\nimport validators\n\nfrom langflow.base.curl.parse import parse_context\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import TabInput\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    IntInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TableInput,\n)\nfrom langflow.schema.data import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.services.deps import get_settings_service\nfrom langflow.utils.component_utils import set_current_fields, set_field_advanced, set_field_display\n\n# Define fields for each mode\nMODE_FIELDS = {\n    \"URL\": [\n        \"url_input\",\n        \"method\",\n    ],\n    \"cURL\": [\"curl_input\"],\n}\n\n# Fields that should always be visible\nDEFAULT_FIELDS = [\"mode\"]\n\n\nclass APIRequestComponent(Component):\n    display_name = \"API Request\"\n    description = \"Make HTTP requests using URL or cURL commands.\"\n    documentation: str = \"https://docs.langflow.org/components-data#api-request\"\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"url_input\",\n            display_name=\"URL\",\n            info=\"Enter the URL for the request.\",\n            advanced=False,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"img_url\",\n            display_name=\"Image URL\",\n            info=(\n                \"ÂõæÁâáÂú∞ÂùÄÔºå‰ªÖÁî®‰∫éËá™Âä®ÊèêÂèñ uuid ‰∏éÈ°µÁ†ÅÔºõÁõÆÊ†á URL ËØ∑Âú®‰∏äÊñπ URL Â≠óÊÆµÂ°´ÂÜôÔºà‰∏çÂÜç‰ªéÂõæÁâá URL Êé®ÂØºÔºâ„ÄÇ\\n\"\n                \"Á§∫‰æã: http://8.137.117.155:8703/image?path=/tmp/ppt_images/<uuid>/images/page_10.png\"\n            ),\n            advanced=False,\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"context\",\n            display_name=\"Context JSON\",\n            info=(\n                \"‰∏ä‰∏ãÊñáÂ≠óÊÆµÔºåJSON Ê†ºÂºèÔºåËá≥Â∞ëÂåÖÂê´ desc ‰∏é oral_broadcast„ÄÇ\\n\"\n                \"Á§∫‰æã: {\\\"desc\\\": \\\"...\\\", \\\"oral_broadcast\\\": \\\"...\\\"}\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=False,\n        ),\n        MultilineInput(\n            name=\"curl_input\",\n            display_name=\"cURL\",\n            info=(\n                \"Paste a curl command to populate the fields. \"\n                \"This will fill in the dictionary fields for headers and body.\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=True,\n            show=False,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"],\n            value=\"GET\",\n            info=\"The HTTP method to use.\",\n            real_time_refresh=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"URL\", \"cURL\"],\n            value=\"URL\",\n            info=\"Enable cURL mode to populate fields from a cURL command.\",\n            real_time_refresh=True,\n        ),\n        DataInput(\n            name=\"query_params\",\n            display_name=\"Query Parameters\",\n            info=\"The query parameters to append to the URL.\",\n            advanced=True,\n        ),\n        TableInput(\n            name=\"body\",\n            display_name=\"Body\",\n            info=\"The body to send with the request as a dictionary (for POST, PATCH, PUT).\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Key\",\n                    \"type\": \"str\",\n                    \"description\": \"Parameter name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"description\": \"Parameter value\",\n                },\n            ],\n            value=[],\n            input_types=[\"Data\"],\n            advanced=True,\n            real_time_refresh=True,\n        ),\n        TableInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Header\",\n                    \"type\": \"str\",\n                    \"description\": \"Header name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"type\": \"str\",\n                    \"description\": \"Header value\",\n                },\n            ],\n            value=[{\"key\": \"User-Agent\", \"value\": get_settings_service().settings.user_agent}],\n            advanced=True,\n            input_types=[\"Data\"],\n            real_time_refresh=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            value=30,\n            info=\"The timeout to use for the request.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"follow_redirects\",\n            display_name=\"Follow Redirects\",\n            value=True,\n            info=\"Whether to follow http redirects.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"save_to_file\",\n            display_name=\"Save to File\",\n            value=False,\n            info=\"Save the API response to a temporary file\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_httpx_metadata\",\n            display_name=\"Include HTTPx Metadata\",\n            value=False,\n            info=(\n                \"Include properties such as headers, status_code, response_headers, \"\n                \"and redirection_history in the output.\"\n            ),\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"API Response\", name=\"data\", method=\"make_api_request\"),\n    ]\n\n    def _parse_json_value(self, value: Any) -> Any:\n        \"\"\"Parse a value that might be a JSON string.\"\"\"\n        if not isinstance(value, str):\n            return value\n\n        try:\n            parsed = json.loads(value)\n        except json.JSONDecodeError:\n            return value\n        else:\n            return parsed\n\n    def _process_body(self, body: Any) -> dict:\n        \"\"\"Process the body input into a valid dictionary.\"\"\"\n        if body is None:\n            return {}\n        if hasattr(body, \"data\"):\n            body = body.data\n        if isinstance(body, dict):\n            return self._process_dict_body(body)\n        if isinstance(body, str):\n            return self._process_string_body(body)\n        if isinstance(body, list):\n            return self._process_list_body(body)\n        return {}\n\n    def _process_dict_body(self, body: dict) -> dict:\n        \"\"\"Process dictionary body by parsing JSON values.\"\"\"\n        return {k: self._parse_json_value(v) for k, v in body.items()}\n\n    def _process_string_body(self, body: str) -> dict:\n        \"\"\"Process string body by attempting JSON parse.\"\"\"\n        try:\n            return self._process_body(json.loads(body))\n        except json.JSONDecodeError:\n            return {\"data\": body}\n\n    def _process_list_body(self, body: list) -> dict:\n        \"\"\"Process list body by converting to key-value dictionary.\"\"\"\n        processed_dict = {}\n        try:\n            for item in body:\n                # Unwrap Data objects\n                current_item = item\n                if hasattr(item, \"data\"):\n                    unwrapped_data = item.data\n                    # If the unwrapped data is a dict but not key-value format, use it directly\n                    if isinstance(unwrapped_data, dict) and not self._is_valid_key_value_item(unwrapped_data):\n                        return unwrapped_data\n                    current_item = unwrapped_data\n                if not self._is_valid_key_value_item(current_item):\n                    continue\n                key = current_item[\"key\"]\n                value = self._parse_json_value(current_item[\"value\"])\n                processed_dict[key] = value\n        except (KeyError, TypeError, ValueError) as e:\n            self.log(f\"Failed to process body list: {e}\")\n            return {}\n        return processed_dict\n\n    def _is_valid_key_value_item(self, item: Any) -> bool:\n        \"\"\"Check if an item is a valid key-value dictionary.\"\"\"\n        return isinstance(item, dict) and \"key\" in item and \"value\" in item\n\n    def parse_curl(self, curl: str, build_config: dotdict) -> dotdict:\n        \"\"\"Parse a cURL command and update build configuration.\"\"\"\n        try:\n            parsed = parse_context(curl)\n\n            # Update basic configuration\n            url = parsed.url\n            # Normalize URL before setting it\n            url = self._normalize_url(url)\n\n            build_config[\"url_input\"][\"value\"] = url\n            build_config[\"method\"][\"value\"] = parsed.method.upper()\n\n            # Process headers\n            headers_list = [{\"key\": k, \"value\": v} for k, v in parsed.headers.items()]\n            build_config[\"headers\"][\"value\"] = headers_list\n\n            # Process body data\n            if not parsed.data:\n                build_config[\"body\"][\"value\"] = []\n            elif parsed.data:\n                try:\n                    json_data = json.loads(parsed.data)\n                    if isinstance(json_data, dict):\n                        body_list = [\n                            {\"key\": k, \"value\": json.dumps(v) if isinstance(v, dict | list) else str(v)}\n                            for k, v in json_data.items()\n                        ]\n                        build_config[\"body\"][\"value\"] = body_list\n                    else:\n                        build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": json.dumps(json_data)}]\n                except json.JSONDecodeError:\n                    build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": parsed.data}]\n\n        except Exception as exc:\n            msg = f\"Error parsing curl: {exc}\"\n            self.log(msg)\n            raise ValueError(msg) from exc\n\n        return build_config\n\n    def _normalize_url(self, url: str) -> str:\n        \"\"\"Normalize URL by adding https:// if no protocol is specified.\"\"\"\n        if not url or not isinstance(url, str):\n            msg = \"URL cannot be empty\"\n            raise ValueError(msg)\n\n        url = url.strip()\n        if url.startswith((\"http://\", \"https://\")):\n            return url\n        return f\"https://{url}\"\n\n    def _extract_uuid_id_from_img(self, img_url: str) -> tuple[str, str, str]:\n        \"\"\"‰ªé img_url ‰∏≠ÊèêÂèñ (base_context_url, uuid, id_str)„ÄÇ\n\n        - base_context_url: ÈÄöËøá img_url ÁöÑ scheme+netloc ÊûÑÂª∫ /context ÁõÆÊ†áÂú∞ÂùÄ\n        - uuid: ‰ªé query ÂèÇÊï∞ path ÁöÑ '/ppt_images/<uuid>/images/' ‰∏≠ÊèêÂèñ\n        - id_str: ‰ªé 'page_<n>.png' ‰∏≠ÊèêÂèñÊï∞Â≠óÈÉ®ÂàÜ\n        \"\"\"\n        if not isinstance(img_url, str) or not img_url.strip():\n            raise ValueError(\"img_url ‰∏çËÉΩ‰∏∫Á©∫\")\n\n        parsed = urlparse(img_url)\n        if not parsed.scheme or not parsed.netloc:\n            raise ValueError(\"img_url ÈùûÊ≥ï: Áº∫Â∞ëÂçèËÆÆÊàñ‰∏ªÊú∫\")\n        base_context_url = f\"{parsed.scheme}://{parsed.netloc}/context\"\n\n        query_dict = dict(parse_qsl(parsed.query))\n        path_value = query_dict.get(\"path\", parsed.path or \"\")\n        if not path_value:\n            raise ValueError(\"img_url ‰∏≠Êú™ÊâæÂà∞ path ÂèÇÊï∞\")\n\n        # ÊèêÂèñ uuid\n        uuid_match = re.search(r\"/ppt_images/([^/]+)/images/\", path_value)\n        if not uuid_match:\n            raise ValueError(\"Êó†Ê≥ï‰ªé img_url ÁöÑ path ‰∏≠Ëß£Êûê uuid\")\n        uuid_val = uuid_match.group(1)\n\n        # ÊèêÂèñÈ°µÂè∑ id\n        id_match = re.search(r\"page_(\\d+)\\.png\", path_value)\n        if not id_match:\n            raise ValueError(\"Êó†Ê≥ï‰ªé img_url ÁöÑ path ‰∏≠Ëß£ÊûêÈ°µÂè∑ id\")\n        id_str = id_match.group(1)\n\n        return base_context_url, uuid_val, id_str\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: dict | None = None,\n        body: Any = None,\n        timeout: int = 5,\n        *,\n        follow_redirects: bool = True,\n        save_to_file: bool = False,\n        include_httpx_metadata: bool = False,\n    ) -> Data:\n        method = method.upper()\n        if method not in {\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"}:\n            msg = f\"Unsupported method: {method}\"\n            raise ValueError(msg)\n\n        processed_body = self._process_body(body)\n        redirection_history = []\n\n        try:\n            # Prepare request parameters\n            request_params = {\n                \"method\": method,\n                \"url\": url,\n                \"headers\": headers,\n                \"json\": processed_body,\n                \"timeout\": timeout,\n                \"follow_redirects\": follow_redirects,\n            }\n            response = await client.request(**request_params)\n\n            redirection_history = [\n                {\n                    \"url\": redirect.headers.get(\"Location\", str(redirect.url)),\n                    \"status_code\": redirect.status_code,\n                }\n                for redirect in response.history\n            ]\n\n            is_binary, file_path = await self._response_info(response, with_file_path=save_to_file)\n            response_headers = self._headers_to_dict(response.headers)\n\n            # Base metadata\n            metadata = {\n                \"source\": url,\n                \"status_code\": response.status_code,\n                \"response_headers\": response_headers,\n            }\n\n            if redirection_history:\n                metadata[\"redirection_history\"] = redirection_history\n\n            if save_to_file:\n                mode = \"wb\" if is_binary else \"w\"\n                encoding = response.encoding if mode == \"w\" else None\n                if file_path:\n                    await aiofiles_os.makedirs(file_path.parent, exist_ok=True)\n                    if is_binary:\n                        async with aiofiles.open(file_path, \"wb\") as f:\n                            await f.write(response.content)\n                            await f.flush()\n                    else:\n                        async with aiofiles.open(file_path, \"w\", encoding=encoding) as f:\n                            await f.write(response.text)\n                            await f.flush()\n                    metadata[\"file_path\"] = str(file_path)\n\n                if include_httpx_metadata:\n                    metadata.update({\"headers\": headers})\n                return Data(data=metadata)\n\n            # Handle response content\n            if is_binary:\n                result = response.content\n            else:\n                try:\n                    result = response.json()\n                except json.JSONDecodeError:\n                    self.log(\"Failed to decode JSON response\")\n                    result = response.text.encode(\"utf-8\")\n\n            metadata[\"result\"] = result\n\n            if include_httpx_metadata:\n                metadata.update({\"headers\": headers})\n\n            return Data(data=metadata)\n        except (httpx.HTTPError, httpx.RequestError, httpx.TimeoutException) as exc:\n            self.log(f\"Error making request to {url}\")\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 500,\n                    \"error\": str(exc),\n                    **({\"redirection_history\": redirection_history} if redirection_history else {}),\n                },\n            )\n\n    def add_query_params(self, url: str, params: dict) -> str:\n        \"\"\"Add query parameters to URL efficiently.\"\"\"\n        if not params:\n            return url\n        url_parts = list(urlparse(url))\n        query = dict(parse_qsl(url_parts[4]))\n        query.update(params)\n        url_parts[4] = urlencode(query)\n        return urlunparse(url_parts)\n\n    def _headers_to_dict(self, headers: httpx.Headers) -> dict[str, str]:\n        \"\"\"Convert HTTP headers to a dictionary with lowercased keys.\"\"\"\n        return {k.lower(): v for k, v in headers.items()}\n\n    def _process_headers(self, headers: Any) -> dict:\n        \"\"\"Process the headers input into a valid dictionary.\"\"\"\n        if headers is None:\n            return {}\n        if isinstance(headers, dict):\n            return headers\n        if isinstance(headers, list):\n            # Mudan√ßa para aceitar Flow Credentials\n            if isinstance(headers[0], Data):\n                return headers[0].data[\"headers\"]\n            return {item[\"key\"]: item[\"value\"] for item in headers if self._is_valid_key_value_item(item)}\n        return {}\n\n    async def make_api_request(self) -> Data:\n        \"\"\"Make HTTP request with optimized parameter handling.\"\"\"\n        method = self.method\n        url = self.url_input.strip() if isinstance(self.url_input, str) else \"\"\n        headers = self.headers or {}\n        body = self.body or {}\n        timeout = self.timeout\n        follow_redirects = self.follow_redirects\n        save_to_file = self.save_to_file\n        include_httpx_metadata = self.include_httpx_metadata\n\n        # if self.mode == \"cURL\" and self.curl_input:\n        #     self._build_config = self.parse_curl(self.curl_input, dotdict())\n        #     # After parsing curl, get the normalized URL\n        #     url = self._build_config[\"url_input\"][\"value\"]\n\n        # Â¶ÇÊûúÊèê‰æõ‰∫Ü img_url ‰∏é contextÔºåÂàôËá™Âä®ÊûÑÂª∫ /context ÁöÑ POST ËØ∑Ê±ÇÔºåÁõÆÊ†á URL ‰ΩøÁî®Áî®Êà∑Â°´ÂÜôÁöÑ URL\n        use_img_builder = (\n            isinstance(getattr(self, \"img_url\", None), str)\n            and self.img_url.strip()\n            and isinstance(getattr(self, \"context\", None), str)\n            and self.context.strip()\n        )\n\n        if use_img_builder:\n            try:\n                # ‰ªÖ‰ªéÂõæÁâá URL ‰∏≠ÊèêÂèñ uuid ‰∏éÈ°µÁ†Å idÔºõ‰∏çÂÜç‰ªéÂõæÁâá URL Êé®ÂØºÁõÆÊ†áÂú∞ÂùÄ\n                _, uuid_val, id_str = self._extract_uuid_id_from_img(self.img_url.strip())\n            except ValueError as e:\n                raise ValueError(f\"ÊûÑÂª∫ËØ∑Ê±ÇÂ§±Ë¥•: {e}\")\n\n            # Âº∫Âà∂Ë¶ÅÊ±ÇÁî®Êà∑Êèê‰æõÁõÆÊ†á URLÔºà‰æãÂ¶Ç /context Êé•Âè£Âú∞ÂùÄÔºâ\n            if not isinstance(self.url_input, str) or not self.url_input.strip():\n                raise ValueError(\"Êú™Êèê‰æõÁõÆÊ†á URLÔºàURL Â≠óÊÆµÔºâ„ÄÇËØ∑Â°´ÂÜô /context Êé•Âè£Âú∞ÂùÄ„ÄÇ\")\n\n            # Ëß£Êûê context JSON\n            try:\n                ctx_obj = json.loads(self.context)\n            except json.JSONDecodeError:\n                raise ValueError(\"context ÂøÖÈ°ªÊòØÂêàÊ≥ïÁöÑ JSON Â≠óÁ¨¶‰∏≤Ôºå‰∏îËá≥Â∞ëÂåÖÂê´ desc ‰∏é oral_broadcast\")\n\n            if not isinstance(ctx_obj, dict):\n                raise ValueError(\"context JSON ÂøÖÈ°ªËß£Êûê‰∏∫ÂØπË±°\")\n\n            desc_val = ctx_obj.get(\"desc\")\n            oral_val = ctx_obj.get(\"oral_broadcast\")\n            audio_url = ctx_obj.get(\"audio_url\")\n            video_url = ctx_obj.get(\"video_url\")\n            subtitle_url = ctx_obj.get(\"subtitle_url\")\n            if audio_url is None or video_url is None or subtitle_url is None:\n                raise ValueError(\"context JSON ÈúÄÂåÖÂê´ audio_url ‰∏é video_url subtitle_url Â≠óÊÆµ\")\n\n            # ÊûÑÂª∫ÁõÆÊ†áËØ∑Ê±Ç\n            method = \"POST\"\n            url = self.url_input.strip()\n            # ÂÖàËßÑËåÉÂåñ headers ‰∏∫Â≠óÂÖ∏ÔºåÂÜçËÆæÁΩÆ Content-TypeÔºåÈÅøÂÖç‚Äúlist ‰∏çÊòØÊò†Â∞Ñ‚ÄùÈîôËØØ\n            headers = self._process_headers(headers)\n            headers[\"Content-Type\"] = \"application/json\"\n            body = {\n                \"uuid\": uuid_val,\n                \"item\": {\n                    \"id\": id_str,\n                    \"order\": id_str,\n                    \"image_url\": self.img_url.strip(),\n                    \"audio_url\": audio_url,\n                    \"video_url\": video_url,\n                    \"subtitle_url\": subtitle_url,\n                },\n            }\n\n        # Normalize URL before validationÔºàÊ≠§Êó∂ÂèØËÉΩÊòØÁî®Êà∑‰º†ÁöÑ URL ÊàñËá™Âä®ÊûÑÂª∫ÁöÑ /contextÔºâ\n        url = self._normalize_url(url)\n\n        # Validate URL\n        if not validators.url(url):\n            msg = f\"Invalid URL provided: {url}\"\n            raise ValueError(msg)\n\n        # Process query parameters\n        if isinstance(self.query_params, str):\n            query_params = dict(parse_qsl(self.query_params))\n        else:\n            query_params = self.query_params.data if self.query_params else {}\n\n        # Process headers and body\n        headers = self._process_headers(headers)\n        body = self._process_body(body)\n        url = self.add_query_params(url, query_params)\n\n        async with httpx.AsyncClient() as client:\n            result = await self.make_request(\n                client,\n                method,\n                url,\n                headers,\n                body,\n                timeout,\n                follow_redirects=follow_redirects,\n                save_to_file=save_to_file,\n                include_httpx_metadata=include_httpx_metadata,\n            )\n        self.status = result\n        return result\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        \"\"\"Update the build config based on the selected mode.\"\"\"\n        if field_name != \"mode\":\n            if field_name == \"curl_input\" and self.mode == \"cURL\" and self.curl_input:\n                return self.parse_curl(self.curl_input, build_config)\n            return build_config\n\n        if field_value == \"cURL\":\n            set_field_display(build_config, \"curl_input\", value=True)\n            if build_config[\"curl_input\"][\"value\"]:\n                build_config = self.parse_curl(build_config[\"curl_input\"][\"value\"], build_config)\n        else:\n            set_field_display(build_config, \"curl_input\", value=False)\n\n        return set_current_fields(\n            build_config=build_config,\n            action_fields=MODE_FIELDS,\n            selected_action=field_value,\n            default_fields=DEFAULT_FIELDS,\n            func=set_field_advanced,\n            default_value=True,\n        )\n\n    async def _response_info(\n        self, response: httpx.Response, *, with_file_path: bool = False\n    ) -> tuple[bool, Path | None]:\n        \"\"\"Determine the file path and whether the response content is binary.\n\n        Args:\n            response (Response): The HTTP response object.\n            with_file_path (bool): Whether to save the response content to a file.\n\n        Returns:\n            Tuple[bool, Path | None]:\n                A tuple containing a boolean indicating if the content is binary and the full file path (if applicable).\n        \"\"\"\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        is_binary = \"application/octet-stream\" in content_type or \"application/binary\" in content_type\n\n        if not with_file_path:\n            return is_binary, None\n\n        component_temp_dir = Path(tempfile.gettempdir()) / self.__class__.__name__\n\n        # Create directory asynchronously\n        await aiofiles_os.makedirs(component_temp_dir, exist_ok=True)\n\n        filename = None\n        if \"Content-Disposition\" in response.headers:\n            content_disposition = response.headers[\"Content-Disposition\"]\n            filename_match = re.search(r'filename=\"(.+?)\"', content_disposition)\n            if filename_match:\n                extracted_filename = filename_match.group(1)\n                filename = extracted_filename\n\n        # Step 3: Infer file extension or use part of the request URL if no filename\n        if not filename:\n            # Extract the last segment of the URL path\n            url_path = urlparse(str(response.request.url) if response.request else \"\").path\n            base_name = Path(url_path).name  # Get the last segment of the path\n            if not base_name:  # If the path ends with a slash or is empty\n                base_name = \"response\"\n\n            # Infer file extension\n            content_type_to_extension = {\n                \"text/plain\": \".txt\",\n                \"application/json\": \".json\",\n                \"image/jpeg\": \".jpg\",\n                \"image/png\": \".png\",\n                \"application/octet-stream\": \".bin\",\n            }\n            extension = content_type_to_extension.get(content_type, \".bin\" if is_binary else \".txt\")\n            filename = f\"{base_name}{extension}\"\n\n        # Step 4: Define the full file path\n        file_path = component_temp_dir / filename\n\n        # Step 5: Check if file exists asynchronously and handle accordingly\n        try:\n            # Try to create the file exclusively (x mode) to check existence\n            async with aiofiles.open(file_path, \"x\") as _:\n                pass  # File created successfully, we can use this path\n        except FileExistsError:\n            # If file exists, append a timestamp to the filename\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d%H%M%S%f\")\n            file_path = component_temp_dir / f\"{timestamp}-{filename}\"\n\n        return is_binary, file_path\nimport json\nimport re\nimport tempfile\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Any\nfrom urllib.parse import parse_qsl, urlencode, urlparse, urlunparse\n\nimport aiofiles\nimport aiofiles.os as aiofiles_os\nimport httpx\nimport validators\n\nfrom langflow.base.curl.parse import parse_context\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import TabInput\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    IntInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TableInput,\n)\nfrom langflow.schema.data import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.services.deps import get_settings_service\nfrom langflow.utils.component_utils import set_current_fields, set_field_advanced, set_field_display\n\n# Define fields for each mode\nMODE_FIELDS = {\n    \"URL\": [\n        \"url_input\",\n        \"method\",\n    ],\n    \"cURL\": [\"curl_input\"],\n}\n\n# Fields that should always be visible\nDEFAULT_FIELDS = [\"mode\"]\n\n\nclass APIRequestComponent(Component):\n    display_name = \"API Request\"\n    description = \"Make HTTP requests using URL or cURL commands.\"\n    documentation: str = \"https://docs.langflow.org/components-data#api-request\"\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"url_input\",\n            display_name=\"URL\",\n            info=\"Enter the URL for the request.\",\n            advanced=False,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"img_url\",\n            display_name=\"Image URL\",\n            info=(\n                \"ÂõæÁâáÂú∞ÂùÄÔºå‰ªÖÁî®‰∫éËá™Âä®ÊèêÂèñ uuid ‰∏éÈ°µÁ†ÅÔºõÁõÆÊ†á URL ËØ∑Âú®‰∏äÊñπ URL Â≠óÊÆµÂ°´ÂÜôÔºà‰∏çÂÜç‰ªéÂõæÁâá URL Êé®ÂØºÔºâ„ÄÇ\\n\"\n                \"Á§∫‰æã: http://8.137.117.155:8703/image?path=/tmp/ppt_images/<uuid>/images/page_10.png\"\n            ),\n            advanced=False,\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"context\",\n            display_name=\"Context JSON\",\n            info=(\n                \"‰∏ä‰∏ãÊñáÂ≠óÊÆµÔºåJSON Ê†ºÂºèÔºåËá≥Â∞ëÂåÖÂê´ desc ‰∏é oral_broadcast„ÄÇ\\n\"\n                \"Á§∫‰æã: {\\\"desc\\\": \\\"...\\\", \\\"oral_broadcast\\\": \\\"...\\\"}\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=False,\n        ),\n        MultilineInput(\n            name=\"curl_input\",\n            display_name=\"cURL\",\n            info=(\n                \"Paste a curl command to populate the fields. \"\n                \"This will fill in the dictionary fields for headers and body.\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=True,\n            show=False,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"],\n            value=\"GET\",\n            info=\"The HTTP method to use.\",\n            real_time_refresh=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"URL\", \"cURL\"],\n            value=\"URL\",\n            info=\"Enable cURL mode to populate fields from a cURL command.\",\n            real_time_refresh=True,\n        ),\n        DataInput(\n            name=\"query_params\",\n            display_name=\"Query Parameters\",\n            info=\"The query parameters to append to the URL.\",\n            advanced=True,\n        ),\n        TableInput(\n            name=\"body\",\n            display_name=\"Body\",\n            info=\"The body to send with the request as a dictionary (for POST, PATCH, PUT).\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Key\",\n                    \"type\": \"str\",\n                    \"description\": \"Parameter name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"description\": \"Parameter value\",\n                },\n            ],\n            value=[],\n            input_types=[\"Data\"],\n            advanced=True,\n            real_time_refresh=True,\n        ),\n        TableInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Header\",\n                    \"type\": \"str\",\n                    \"description\": \"Header name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"type\": \"str\",\n                    \"description\": \"Header value\",\n                },\n            ],\n            value=[{\"key\": \"User-Agent\", \"value\": get_settings_service().settings.user_agent}],\n            advanced=True,\n            input_types=[\"Data\"],\n            real_time_refresh=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            value=30,\n            info=\"The timeout to use for the request.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"follow_redirects\",\n            display_name=\"Follow Redirects\",\n            value=True,\n            info=\"Whether to follow http redirects.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"save_to_file\",\n            display_name=\"Save to File\",\n            value=False,\n            info=\"Save the API response to a temporary file\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_httpx_metadata\",\n            display_name=\"Include HTTPx Metadata\",\n            value=False,\n            info=(\n                \"Include properties such as headers, status_code, response_headers, \"\n                \"and redirection_history in the output.\"\n            ),\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"API Response\", name=\"data\", method=\"make_api_request\"),\n    ]\n\n    def _parse_json_value(self, value: Any) -> Any:\n        \"\"\"Parse a value that might be a JSON string.\"\"\"\n        if not isinstance(value, str):\n            return value\n\n        try:\n            parsed = json.loads(value)\n        except json.JSONDecodeError:\n            return value\n        else:\n            return parsed\n\n    def _process_body(self, body: Any) -> dict:\n        \"\"\"Process the body input into a valid dictionary.\"\"\"\n        if body is None:\n            return {}\n        if hasattr(body, \"data\"):\n            body = body.data\n        if isinstance(body, dict):\n            return self._process_dict_body(body)\n        if isinstance(body, str):\n            return self._process_string_body(body)\n        if isinstance(body, list):\n            return self._process_list_body(body)\n        return {}\n\n    def _process_dict_body(self, body: dict) -> dict:\n        \"\"\"Process dictionary body by parsing JSON values.\"\"\"\n        return {k: self._parse_json_value(v) for k, v in body.items()}\n\n    def _process_string_body(self, body: str) -> dict:\n        \"\"\"Process string body by attempting JSON parse.\"\"\"\n        try:\n            return self._process_body(json.loads(body))\n        except json.JSONDecodeError:\n            return {\"data\": body}\n\n    def _process_list_body(self, body: list) -> dict:\n        \"\"\"Process list body by converting to key-value dictionary.\"\"\"\n        processed_dict = {}\n        try:\n            for item in body:\n                # Unwrap Data objects\n                current_item = item\n                if hasattr(item, \"data\"):\n                    unwrapped_data = item.data\n                    # If the unwrapped data is a dict but not key-value format, use it directly\n                    if isinstance(unwrapped_data, dict) and not self._is_valid_key_value_item(unwrapped_data):\n                        return unwrapped_data\n                    current_item = unwrapped_data\n                if not self._is_valid_key_value_item(current_item):\n                    continue\n                key = current_item[\"key\"]\n                value = self._parse_json_value(current_item[\"value\"])\n                processed_dict[key] = value\n        except (KeyError, TypeError, ValueError) as e:\n            self.log(f\"Failed to process body list: {e}\")\n            return {}\n        return processed_dict\n\n    def _is_valid_key_value_item(self, item: Any) -> bool:\n        \"\"\"Check if an item is a valid key-value dictionary.\"\"\"\n        return isinstance(item, dict) and \"key\" in item and \"value\" in item\n\n    def parse_curl(self, curl: str, build_config: dotdict) -> dotdict:\n        \"\"\"Parse a cURL command and update build configuration.\"\"\"\n        try:\n            parsed = parse_context(curl)\n\n            # Update basic configuration\n            url = parsed.url\n            # Normalize URL before setting it\n            url = self._normalize_url(url)\n\n            build_config[\"url_input\"][\"value\"] = url\n            build_config[\"method\"][\"value\"] = parsed.method.upper()\n\n            # Process headers\n            headers_list = [{\"key\": k, \"value\": v} for k, v in parsed.headers.items()]\n            build_config[\"headers\"][\"value\"] = headers_list\n\n            # Process body data\n            if not parsed.data:\n                build_config[\"body\"][\"value\"] = []\n            elif parsed.data:\n                try:\n                    json_data = json.loads(parsed.data)\n                    if isinstance(json_data, dict):\n                        body_list = [\n                            {\"key\": k, \"value\": json.dumps(v) if isinstance(v, dict | list) else str(v)}\n                            for k, v in json_data.items()\n                        ]\n                        build_config[\"body\"][\"value\"] = body_list\n                    else:\n                        build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": json.dumps(json_data)}]\n                except json.JSONDecodeError:\n                    build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": parsed.data}]\n\n        except Exception as exc:\n            msg = f\"Error parsing curl: {exc}\"\n            self.log(msg)\n            raise ValueError(msg) from exc\n\n        return build_config\n\n    def _normalize_url(self, url: str) -> str:\n        \"\"\"Normalize URL by adding https:// if no protocol is specified.\"\"\"\n        if not url or not isinstance(url, str):\n            msg = \"URL cannot be empty\"\n            raise ValueError(msg)\n\n        url = url.strip()\n        if url.startswith((\"http://\", \"https://\")):\n            return url\n        return f\"https://{url}\"\n\n    def _extract_uuid_id_from_img(self, img_url: str) -> tuple[str, str, str]:\n        \"\"\"‰ªé img_url ‰∏≠ÊèêÂèñ (base_context_url, uuid, id_str)„ÄÇ\n\n        - base_context_url: ÈÄöËøá img_url ÁöÑ scheme+netloc ÊûÑÂª∫ /context ÁõÆÊ†áÂú∞ÂùÄ\n        - uuid: ‰ªé query ÂèÇÊï∞ path ÁöÑ '/ppt_images/<uuid>/images/' ‰∏≠ÊèêÂèñ\n        - id_str: ‰ªé 'page_<n>.png' ‰∏≠ÊèêÂèñÊï∞Â≠óÈÉ®ÂàÜ\n        \"\"\"\n        if not isinstance(img_url, str) or not img_url.strip():\n            raise ValueError(\"img_url ‰∏çËÉΩ‰∏∫Á©∫\")\n\n        parsed = urlparse(img_url)\n        if not parsed.scheme or not parsed.netloc:\n            raise ValueError(\"img_url ÈùûÊ≥ï: Áº∫Â∞ëÂçèËÆÆÊàñ‰∏ªÊú∫\")\n        base_context_url = f\"{parsed.scheme}://{parsed.netloc}/context\"\n\n        query_dict = dict(parse_qsl(parsed.query))\n        path_value = query_dict.get(\"path\", parsed.path or \"\")\n        if not path_value:\n            raise ValueError(\"img_url ‰∏≠Êú™ÊâæÂà∞ path ÂèÇÊï∞\")\n\n        # ÊèêÂèñ uuid\n        uuid_match = re.search(r\"/ppt_images/([^/]+)/images/\", path_value)\n        if not uuid_match:\n            raise ValueError(\"Êó†Ê≥ï‰ªé img_url ÁöÑ path ‰∏≠Ëß£Êûê uuid\")\n        uuid_val = uuid_match.group(1)\n\n        # ÊèêÂèñÈ°µÂè∑ id\n        id_match = re.search(r\"page_(\\d+)\\.png\", path_value)\n        if not id_match:\n            raise ValueError(\"Êó†Ê≥ï‰ªé img_url ÁöÑ path ‰∏≠Ëß£ÊûêÈ°µÂè∑ id\")\n        id_str = id_match.group(1)\n\n        return base_context_url, uuid_val, id_str\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: dict | None = None,\n        body: Any = None,\n        timeout: int = 5,\n        *,\n        follow_redirects: bool = True,\n        save_to_file: bool = False,\n        include_httpx_metadata: bool = False,\n    ) -> Data:\n        method = method.upper()\n        if method not in {\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"}:\n            msg = f\"Unsupported method: {method}\"\n            raise ValueError(msg)\n\n        processed_body = self._process_body(body)\n        redirection_history = []\n\n        try:\n            # Prepare request parameters\n            request_params = {\n                \"method\": method,\n                \"url\": url,\n                \"headers\": headers,\n                \"json\": processed_body,\n                \"timeout\": timeout,\n                \"follow_redirects\": follow_redirects,\n            }\n            response = await client.request(**request_params)\n\n            redirection_history = [\n                {\n                    \"url\": redirect.headers.get(\"Location\", str(redirect.url)),\n                    \"status_code\": redirect.status_code,\n                }\n                for redirect in response.history\n            ]\n\n            is_binary, file_path = await self._response_info(response, with_file_path=save_to_file)\n            response_headers = self._headers_to_dict(response.headers)\n\n            # Base metadata\n            metadata = {\n                \"source\": url,\n                \"status_code\": response.status_code,\n                \"response_headers\": response_headers,\n            }\n\n            if redirection_history:\n                metadata[\"redirection_history\"] = redirection_history\n\n            if save_to_file:\n                mode = \"wb\" if is_binary else \"w\"\n                encoding = response.encoding if mode == \"w\" else None\n                if file_path:\n                    await aiofiles_os.makedirs(file_path.parent, exist_ok=True)\n                    if is_binary:\n                        async with aiofiles.open(file_path, \"wb\") as f:\n                            await f.write(response.content)\n                            await f.flush()\n                    else:\n                        async with aiofiles.open(file_path, \"w\", encoding=encoding) as f:\n                            await f.write(response.text)\n                            await f.flush()\n                    metadata[\"file_path\"] = str(file_path)\n\n                if include_httpx_metadata:\n                    metadata.update({\"headers\": headers})\n                return Data(data=metadata)\n\n            # Handle response content\n            if is_binary:\n                result = response.content\n            else:\n                try:\n                    result = response.json()\n                except json.JSONDecodeError:\n                    self.log(\"Failed to decode JSON response\")\n                    result = response.text.encode(\"utf-8\")\n\n            metadata[\"result\"] = result\n\n            if include_httpx_metadata:\n                metadata.update({\"headers\": headers})\n\n            return Data(data=metadata)\n        except (httpx.HTTPError, httpx.RequestError, httpx.TimeoutException) as exc:\n            self.log(f\"Error making request to {url}\")\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 500,\n                    \"error\": str(exc),\n                    **({\"redirection_history\": redirection_history} if redirection_history else {}),\n                },\n            )\n\n    def add_query_params(self, url: str, params: dict) -> str:\n        \"\"\"Add query parameters to URL efficiently.\"\"\"\n        if not params:\n            return url\n        url_parts = list(urlparse(url))\n        query = dict(parse_qsl(url_parts[4]))\n        query.update(params)\n        url_parts[4] = urlencode(query)\n        return urlunparse(url_parts)\n\n    def _headers_to_dict(self, headers: httpx.Headers) -> dict[str, str]:\n        \"\"\"Convert HTTP headers to a dictionary with lowercased keys.\"\"\"\n        return {k.lower(): v for k, v in headers.items()}\n\n    def _process_headers(self, headers: Any) -> dict:\n        \"\"\"Process the headers input into a valid dictionary.\"\"\"\n        if headers is None:\n            return {}\n        if isinstance(headers, dict):\n            return headers\n        if isinstance(headers, list):\n            # Mudan√ßa para aceitar Flow Credentials\n            if isinstance(headers[0], Data):\n                return headers[0].data[\"headers\"]\n            return {item[\"key\"]: item[\"value\"] for item in headers if self._is_valid_key_value_item(item)}\n        return {}\n\n    async def make_api_request(self) -> Data:\n        \"\"\"Make HTTP request with optimized parameter handling.\"\"\"\n        method = self.method\n        url = self.url_input.strip() if isinstance(self.url_input, str) else \"\"\n        headers = self.headers or {}\n        body = self.body or {}\n        timeout = self.timeout\n        follow_redirects = self.follow_redirects\n        save_to_file = self.save_to_file\n        include_httpx_metadata = self.include_httpx_metadata\n\n        # if self.mode == \"cURL\" and self.curl_input:\n        #     self._build_config = self.parse_curl(self.curl_input, dotdict())\n        #     # After parsing curl, get the normalized URL\n        #     url = self._build_config[\"url_input\"][\"value\"]\n\n        # Â¶ÇÊûúÊèê‰æõ‰∫Ü img_url ‰∏é contextÔºåÂàôËá™Âä®ÊûÑÂª∫ /context ÁöÑ POST ËØ∑Ê±ÇÔºåÁõÆÊ†á URL ‰ΩøÁî®Áî®Êà∑Â°´ÂÜôÁöÑ URL\n        use_img_builder = (\n            isinstance(getattr(self, \"img_url\", None), str)\n            and self.img_url.strip()\n            and isinstance(getattr(self, \"context\", None), str)\n            and self.context.strip()\n        )\n\n        if use_img_builder:\n            try:\n                # ‰ªÖ‰ªéÂõæÁâá URL ‰∏≠ÊèêÂèñ uuid ‰∏éÈ°µÁ†Å idÔºõ‰∏çÂÜç‰ªéÂõæÁâá URL Êé®ÂØºÁõÆÊ†áÂú∞ÂùÄ\n                _, uuid_val, id_str = self._extract_uuid_id_from_img(self.img_url.strip())\n            except ValueError as e:\n                raise ValueError(f\"ÊûÑÂª∫ËØ∑Ê±ÇÂ§±Ë¥•: {e}\")\n\n            # Âº∫Âà∂Ë¶ÅÊ±ÇÁî®Êà∑Êèê‰æõÁõÆÊ†á URLÔºà‰æãÂ¶Ç /context Êé•Âè£Âú∞ÂùÄÔºâ\n            if not isinstance(self.url_input, str) or not self.url_input.strip():\n                raise ValueError(\"Êú™Êèê‰æõÁõÆÊ†á URLÔºàURL Â≠óÊÆµÔºâ„ÄÇËØ∑Â°´ÂÜô /context Êé•Âè£Âú∞ÂùÄ„ÄÇ\")\n\n            # Ëß£Êûê context JSON\n            try:\n                ctx_obj = json.loads(self.context)\n            except json.JSONDecodeError:\n                raise ValueError(\"context ÂøÖÈ°ªÊòØÂêàÊ≥ïÁöÑ JSON Â≠óÁ¨¶‰∏≤Ôºå‰∏îËá≥Â∞ëÂåÖÂê´ desc ‰∏é oral_broadcast\")\n\n            if not isinstance(ctx_obj, dict):\n                raise ValueError(\"context JSON ÂøÖÈ°ªËß£Êûê‰∏∫ÂØπË±°\")\n\n            desc_val = ctx_obj.get(\"desc\")\n            oral_val = ctx_obj.get(\"oral_broadcast\")\n            audio_url = ctx_obj.get(\"audio_url\")\n            video_url = ctx_obj.get(\"video_url\")\n            subtitle_url = ctx_obj.get(\"subtitle_url\")\n            if audio_url is None or video_url is None or subtitle_url is None:\n                raise ValueError(\"context JSON ÈúÄÂåÖÂê´ audio_url ‰∏é video_url subtitle_url Â≠óÊÆµ\")\n\n            # ÊûÑÂª∫ÁõÆÊ†áËØ∑Ê±Ç\n            method = \"POST\"\n            url = self.url_input.strip()\n            # ÂÖàËßÑËåÉÂåñ headers ‰∏∫Â≠óÂÖ∏ÔºåÂÜçËÆæÁΩÆ Content-TypeÔºåÈÅøÂÖç‚Äúlist ‰∏çÊòØÊò†Â∞Ñ‚ÄùÈîôËØØ\n            headers = self._process_headers(headers)\n            headers[\"Content-Type\"] = \"application/json\"\n            body = {\n                \"uuid\": uuid_val,\n                \"item\": {\n                    \"id\": id_str,\n                    \"order\": id_str,\n                    \"image_url\": self.img_url.strip(),\n                    \"audio_url\": audio_url,\n                    \"video_url\": video_url,\n                    \"subtitle_url\": subtitle_url,\n                },\n            }\n\n        # Normalize URL before validationÔºàÊ≠§Êó∂ÂèØËÉΩÊòØÁî®Êà∑‰º†ÁöÑ URL ÊàñËá™Âä®ÊûÑÂª∫ÁöÑ /contextÔºâ\n        url = self._normalize_url(url)\n\n        # Validate URL\n        if not validators.url(url):\n            msg = f\"Invalid URL provided: {url}\"\n            raise ValueError(msg)\n\n        # Process query parameters\n        if isinstance(self.query_params, str):\n            query_params = dict(parse_qsl(self.query_params))\n        else:\n            query_params = self.query_params.data if self.query_params else {}\n\n        # Process headers and body\n        headers = self._process_headers(headers)\n        body = self._process_body(body)\n        url = self.add_query_params(url, query_params)\n\n        async with httpx.AsyncClient() as client:\n            result = await self.make_request(\n                client,\n                method,\n                url,\n                headers,\n                body,\n                timeout,\n                follow_redirects=follow_redirects,\n                save_to_file=save_to_file,\n                include_httpx_metadata=include_httpx_metadata,\n            )\n        self.status = result\n        return result\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        \"\"\"Update the build config based on the selected mode.\"\"\"\n        if field_name != \"mode\":\n            if field_name == \"curl_input\" and self.mode == \"cURL\" and self.curl_input:\n                return self.parse_curl(self.curl_input, build_config)\n            return build_config\n\n        if field_value == \"cURL\":\n            set_field_display(build_config, \"curl_input\", value=True)\n            if build_config[\"curl_input\"][\"value\"]:\n                build_config = self.parse_curl(build_config[\"curl_input\"][\"value\"], build_config)\n        else:\n            set_field_display(build_config, \"curl_input\", value=False)\n\n        return set_current_fields(\n            build_config=build_config,\n            action_fields=MODE_FIELDS,\n            selected_action=field_value,\n            default_fields=DEFAULT_FIELDS,\n            func=set_field_advanced,\n            default_value=True,\n        )\n\n    async def _response_info(\n        self, response: httpx.Response, *, with_file_path: bool = False\n    ) -> tuple[bool, Path | None]:\n        \"\"\"Determine the file path and whether the response content is binary.\n\n        Args:\n            response (Response): The HTTP response object.\n            with_file_path (bool): Whether to save the response content to a file.\n\n        Returns:\n            Tuple[bool, Path | None]:\n                A tuple containing a boolean indicating if the content is binary and the full file path (if applicable).\n        \"\"\"\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        is_binary = \"application/octet-stream\" in content_type or \"application/binary\" in content_type\n\n        if not with_file_path:\n            return is_binary, None\n\n        component_temp_dir = Path(tempfile.gettempdir()) / self.__class__.__name__\n\n        # Create directory asynchronously\n        await aiofiles_os.makedirs(component_temp_dir, exist_ok=True)\n\n        filename = None\n        if \"Content-Disposition\" in response.headers:\n            content_disposition = response.headers[\"Content-Disposition\"]\n            filename_match = re.search(r'filename=\"(.+?)\"', content_disposition)\n            if filename_match:\n                extracted_filename = filename_match.group(1)\n                filename = extracted_filename\n\n        # Step 3: Infer file extension or use part of the request URL if no filename\n        if not filename:\n            # Extract the last segment of the URL path\n            url_path = urlparse(str(response.request.url) if response.request else \"\").path\n            base_name = Path(url_path).name  # Get the last segment of the path\n            if not base_name:  # If the path ends with a slash or is empty\n                base_name = \"response\"\n\n            # Infer file extension\n            content_type_to_extension = {\n                \"text/plain\": \".txt\",\n                \"application/json\": \".json\",\n                \"image/jpeg\": \".jpg\",\n                \"image/png\": \".png\",\n                \"application/octet-stream\": \".bin\",\n            }\n            extension = content_type_to_extension.get(content_type, \".bin\" if is_binary else \".txt\")\n            filename = f\"{base_name}{extension}\"\n\n        # Step 4: Define the full file path\n        file_path = component_temp_dir / filename\n\n        # Step 5: Check if file exists asynchronously and handle accordingly\n        try:\n            # Try to create the file exclusively (x mode) to check existence\n            async with aiofiles.open(file_path, \"x\") as _:\n                pass  # File created successfully, we can use this path\n        except FileExistsError:\n            # If file exists, append a timestamp to the filename\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d%H%M%S%f\")\n            file_path = component_temp_dir / f\"{timestamp}-{filename}\"\n\n        return is_binary, file_path\nimport json\nimport re\nimport tempfile\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Any\nfrom urllib.parse import parse_qsl, urlencode, urlparse, urlunparse\n\nimport aiofiles\nimport aiofiles.os as aiofiles_os\nimport httpx\nimport validators\n\nfrom langflow.base.curl.parse import parse_context\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import TabInput\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    IntInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TableInput,\n)\nfrom langflow.schema.data import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.services.deps import get_settings_service\nfrom langflow.utils.component_utils import set_current_fields, set_field_advanced, set_field_display\n\n# Define fields for each mode\nMODE_FIELDS = {\n    \"URL\": [\n        \"url_input\",\n        \"method\",\n    ],\n    \"cURL\": [\"curl_input\"],\n}\n\n# Fields that should always be visible\nDEFAULT_FIELDS = [\"mode\"]\n\n\nclass APIRequestComponent(Component):\n    display_name = \"API Request\"\n    description = \"Make HTTP requests using URL or cURL commands.\"\n    documentation: str = \"https://docs.langflow.org/components-data#api-request\"\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"url_input\",\n            display_name=\"URL\",\n            info=\"Enter the URL for the request.\",\n            advanced=False,\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"img_url\",\n            display_name=\"Image URL\",\n            info=(\n                \"ÂõæÁâáÂú∞ÂùÄÔºå‰ªÖÁî®‰∫éËá™Âä®ÊèêÂèñ uuid ‰∏éÈ°µÁ†ÅÔºõÁõÆÊ†á URL ËØ∑Âú®‰∏äÊñπ URL Â≠óÊÆµÂ°´ÂÜôÔºà‰∏çÂÜç‰ªéÂõæÁâá URL Êé®ÂØºÔºâ„ÄÇ\\n\"\n                \"Á§∫‰æã: http://8.137.117.155:8703/image?path=/tmp/ppt_images/<uuid>/images/page_10.png\"\n            ),\n            advanced=False,\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"context\",\n            display_name=\"Context JSON\",\n            info=(\n                \"‰∏ä‰∏ãÊñáÂ≠óÊÆµÔºåJSON Ê†ºÂºèÔºåËá≥Â∞ëÂåÖÂê´ desc ‰∏é oral_broadcast„ÄÇ\\n\"\n                \"Á§∫‰æã: {\\\"desc\\\": \\\"...\\\", \\\"oral_broadcast\\\": \\\"...\\\"}\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=False,\n        ),\n        MultilineInput(\n            name=\"curl_input\",\n            display_name=\"cURL\",\n            info=(\n                \"Paste a curl command to populate the fields. \"\n                \"This will fill in the dictionary fields for headers and body.\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=True,\n            show=False,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"],\n            value=\"GET\",\n            info=\"The HTTP method to use.\",\n            real_time_refresh=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"URL\", \"cURL\"],\n            value=\"URL\",\n            info=\"Enable cURL mode to populate fields from a cURL command.\",\n            real_time_refresh=True,\n        ),\n        DataInput(\n            name=\"query_params\",\n            display_name=\"Query Parameters\",\n            info=\"The query parameters to append to the URL.\",\n            advanced=True,\n        ),\n        TableInput(\n            name=\"body\",\n            display_name=\"Body\",\n            info=\"The body to send with the request as a dictionary (for POST, PATCH, PUT).\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Key\",\n                    \"type\": \"str\",\n                    \"description\": \"Parameter name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"description\": \"Parameter value\",\n                },\n            ],\n            value=[],\n            input_types=[\"Data\"],\n            advanced=True,\n            real_time_refresh=True,\n        ),\n        TableInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Header\",\n                    \"type\": \"str\",\n                    \"description\": \"Header name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"type\": \"str\",\n                    \"description\": \"Header value\",\n                },\n            ],\n            value=[{\"key\": \"User-Agent\", \"value\": get_settings_service().settings.user_agent}],\n            advanced=True,\n            input_types=[\"Data\"],\n            real_time_refresh=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            value=30,\n            info=\"The timeout to use for the request.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"follow_redirects\",\n            display_name=\"Follow Redirects\",\n            value=True,\n            info=\"Whether to follow http redirects.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"save_to_file\",\n            display_name=\"Save to File\",\n            value=False,\n            info=\"Save the API response to a temporary file\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_httpx_metadata\",\n            display_name=\"Include HTTPx Metadata\",\n            value=False,\n            info=(\n                \"Include properties such as headers, status_code, response_headers, \"\n                \"and redirection_history in the output.\"\n            ),\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"API Response\", name=\"data\", method=\"make_api_request\"),\n    ]\n\n    def _parse_json_value(self, value: Any) -> Any:\n        \"\"\"Parse a value that might be a JSON string.\"\"\"\n        if not isinstance(value, str):\n            return value\n\n        try:\n            parsed = json.loads(value)\n        except json.JSONDecodeError:\n            return value\n        else:\n            return parsed\n\n    def _process_body(self, body: Any) -> dict:\n        \"\"\"Process the body input into a valid dictionary.\"\"\"\n        if body is None:\n            return {}\n        if hasattr(body, \"data\"):\n            body = body.data\n        if isinstance(body, dict):\n            return self._process_dict_body(body)\n        if isinstance(body, str):\n            return self._process_string_body(body)\n        if isinstance(body, list):\n            return self._process_list_body(body)\n        return {}\n\n    def _process_dict_body(self, body: dict) -> dict:\n        \"\"\"Process dictionary body by parsing JSON values.\"\"\"\n        return {k: self._parse_json_value(v) for k, v in body.items()}\n\n    def _process_string_body(self, body: str) -> dict:\n        \"\"\"Process string body by attempting JSON parse.\"\"\"\n        try:\n            return self._process_body(json.loads(body))\n        except json.JSONDecodeError:\n            return {\"data\": body}\n\n    def _process_list_body(self, body: list) -> dict:\n        \"\"\"Process list body by converting to key-value dictionary.\"\"\"\n        processed_dict = {}\n        try:\n            for item in body:\n                # Unwrap Data objects\n                current_item = item\n                if hasattr(item, \"data\"):\n                    unwrapped_data = item.data\n                    # If the unwrapped data is a dict but not key-value format, use it directly\n                    if isinstance(unwrapped_data, dict) and not self._is_valid_key_value_item(unwrapped_data):\n                        return unwrapped_data\n                    current_item = unwrapped_data\n                if not self._is_valid_key_value_item(current_item):\n                    continue\n                key = current_item[\"key\"]\n                value = self._parse_json_value(current_item[\"value\"])\n                processed_dict[key] = value\n        except (KeyError, TypeError, ValueError) as e:\n            self.log(f\"Failed to process body list: {e}\")\n            return {}\n        return processed_dict\n\n    def _is_valid_key_value_item(self, item: Any) -> bool:\n        \"\"\"Check if an item is a valid key-value dictionary.\"\"\"\n        return isinstance(item, dict) and \"key\" in item and \"value\" in item\n\n    def parse_curl(self, curl: str, build_config: dotdict) -> dotdict:\n        \"\"\"Parse a cURL command and update build configuration.\"\"\"\n        try:\n            parsed = parse_context(curl)\n\n            # Update basic configuration\n            url = parsed.url\n            # Normalize URL before setting it\n            url = self._normalize_url(url)\n\n            build_config[\"url_input\"][\"value\"] = url\n            build_config[\"method\"][\"value\"] = parsed.method.upper()\n\n            # Process headers\n            headers_list = [{\"key\": k, \"value\": v} for k, v in parsed.headers.items()]\n            build_config[\"headers\"][\"value\"] = headers_list\n\n            # Process body data\n            if not parsed.data:\n                build_config[\"body\"][\"value\"] = []\n            elif parsed.data:\n                try:\n                    json_data = json.loads(parsed.data)\n                    if isinstance(json_data, dict):\n                        body_list = [\n                            {\"key\": k, \"value\": json.dumps(v) if isinstance(v, dict | list) else str(v)}\n                            for k, v in json_data.items()\n                        ]\n                        build_config[\"body\"][\"value\"] = body_list\n                    else:\n                        build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": json.dumps(json_data)}]\n                except json.JSONDecodeError:\n                    build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": parsed.data}]\n\n        except Exception as exc:\n            msg = f\"Error parsing curl: {exc}\"\n            self.log(msg)\n            raise ValueError(msg) from exc\n\n        return build_config\n\n    def _normalize_url(self, url: str) -> str:\n        \"\"\"Normalize URL by adding https:// if no protocol is specified.\"\"\"\n        if not url or not isinstance(url, str):\n            msg = \"URL cannot be empty\"\n            raise ValueError(msg)\n\n        url = url.strip()\n        if url.startswith((\"http://\", \"https://\")):\n            return url\n        return f\"https://{url}\"\n\n    def _extract_uuid_id_from_img(self, img_url: str) -> tuple[str, str, str]:\n        \"\"\"‰ªé img_url ‰∏≠ÊèêÂèñ (base_context_url, uuid, id_str)„ÄÇ\n\n        - base_context_url: ÈÄöËøá img_url ÁöÑ scheme+netloc ÊûÑÂª∫ /context ÁõÆÊ†áÂú∞ÂùÄ\n        - uuid: ‰ªé query ÂèÇÊï∞ path ÁöÑ '/ppt_images/<uuid>/images/' ‰∏≠ÊèêÂèñ\n        - id_str: ‰ªé 'page_<n>.png' ‰∏≠ÊèêÂèñÊï∞Â≠óÈÉ®ÂàÜ\n        \"\"\"\n        if not isinstance(img_url, str) or not img_url.strip():\n            raise ValueError(\"img_url ‰∏çËÉΩ‰∏∫Á©∫\")\n\n        parsed = urlparse(img_url)\n        if not parsed.scheme or not parsed.netloc:\n            raise ValueError(\"img_url ÈùûÊ≥ï: Áº∫Â∞ëÂçèËÆÆÊàñ‰∏ªÊú∫\")\n        base_context_url = f\"{parsed.scheme}://{parsed.netloc}/context\"\n\n        query_dict = dict(parse_qsl(parsed.query))\n        path_value = query_dict.get(\"path\", parsed.path or \"\")\n        if not path_value:\n            raise ValueError(\"img_url ‰∏≠Êú™ÊâæÂà∞ path ÂèÇÊï∞\")\n\n        # ÊèêÂèñ uuid\n        uuid_match = re.search(r\"/ppt_images/([^/]+)/images/\", path_value)\n        if not uuid_match:\n            raise ValueError(\"Êó†Ê≥ï‰ªé img_url ÁöÑ path ‰∏≠Ëß£Êûê uuid\")\n        uuid_val = uuid_match.group(1)\n\n        # ÊèêÂèñÈ°µÂè∑ id\n        id_match = re.search(r\"page_(\\d+)\\.png\", path_value)\n        if not id_match:\n            raise ValueError(\"Êó†Ê≥ï‰ªé img_url ÁöÑ path ‰∏≠Ëß£ÊûêÈ°µÂè∑ id\")\n        id_str = id_match.group(1)\n\n        return base_context_url, uuid_val, id_str\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: dict | None = None,\n        body: Any = None,\n        timeout: int = 5,\n        *,\n        follow_redirects: bool = True,\n        save_to_file: bool = False,\n        include_httpx_metadata: bool = False,\n    ) -> Data:\n        method = method.upper()\n        if method not in {\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"}:\n            msg = f\"Unsupported method: {method}\"\n            raise ValueError(msg)\n\n        processed_body = self._process_body(body)\n        redirection_history = []\n\n        try:\n            # Prepare request parameters\n            request_params = {\n                \"method\": method,\n                \"url\": url,\n                \"headers\": headers,\n                \"json\": processed_body,\n                \"timeout\": timeout,\n                \"follow_redirects\": follow_redirects,\n            }\n            response = await client.request(**request_params)\n\n            redirection_history = [\n                {\n                    \"url\": redirect.headers.get(\"Location\", str(redirect.url)),\n                    \"status_code\": redirect.status_code,\n                }\n                for redirect in response.history\n            ]\n\n            is_binary, file_path = await self._response_info(response, with_file_path=save_to_file)\n            response_headers = self._headers_to_dict(response.headers)\n\n            # Base metadata\n            metadata = {\n                \"source\": url,\n                \"status_code\": response.status_code,\n                \"response_headers\": response_headers,\n            }\n\n            if redirection_history:\n                metadata[\"redirection_history\"] = redirection_history\n\n            if save_to_file:\n                mode = \"wb\" if is_binary else \"w\"\n                encoding = response.encoding if mode == \"w\" else None\n                if file_path:\n                    await aiofiles_os.makedirs(file_path.parent, exist_ok=True)\n                    if is_binary:\n                        async with aiofiles.open(file_path, \"wb\") as f:\n                            await f.write(response.content)\n                            await f.flush()\n                    else:\n                        async with aiofiles.open(file_path, \"w\", encoding=encoding) as f:\n                            await f.write(response.text)\n                            await f.flush()\n                    metadata[\"file_path\"] = str(file_path)\n\n                if include_httpx_metadata:\n                    metadata.update({\"headers\": headers})\n                return Data(data=metadata)\n\n            # Handle response content\n            if is_binary:\n                result = response.content\n            else:\n                try:\n                    result = response.json()\n                except json.JSONDecodeError:\n                    self.log(\"Failed to decode JSON response\")\n                    result = response.text.encode(\"utf-8\")\n\n            metadata[\"result\"] = result\n\n            if include_httpx_metadata:\n                metadata.update({\"headers\": headers})\n\n            return Data(data=metadata)\n        except (httpx.HTTPError, httpx.RequestError, httpx.TimeoutException) as exc:\n            self.log(f\"Error making request to {url}\")\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 500,\n                    \"error\": str(exc),\n                    **({\"redirection_history\": redirection_history} if redirection_history else {}),\n                },\n            )\n\n    def add_query_params(self, url: str, params: dict) -> str:\n        \"\"\"Add query parameters to URL efficiently.\"\"\"\n        if not params:\n            return url\n        url_parts = list(urlparse(url))\n        query = dict(parse_qsl(url_parts[4]))\n        query.update(params)\n        url_parts[4] = urlencode(query)\n        return urlunparse(url_parts)\n\n    def _headers_to_dict(self, headers: httpx.Headers) -> dict[str, str]:\n        \"\"\"Convert HTTP headers to a dictionary with lowercased keys.\"\"\"\n        return {k.lower(): v for k, v in headers.items()}\n\n    def _process_headers(self, headers: Any) -> dict:\n        \"\"\"Process the headers input into a valid dictionary.\"\"\"\n        if headers is None:\n            return {}\n        if isinstance(headers, dict):\n            return headers\n        if isinstance(headers, list):\n            # Mudan√ßa para aceitar Flow Credentials\n            if isinstance(headers[0], Data):\n                return headers[0].data[\"headers\"]\n            return {item[\"key\"]: item[\"value\"] for item in headers if self._is_valid_key_value_item(item)}\n        return {}\n\n    async def make_api_request(self) -> Data:\n        \"\"\"Make HTTP request with optimized parameter handling.\"\"\"\n        method = self.method\n        url = self.url_input.strip() if isinstance(self.url_input, str) else \"\"\n        headers = self.headers or {}\n        body = self.body or {}\n        timeout = self.timeout\n        follow_redirects = self.follow_redirects\n        save_to_file = self.save_to_file\n        include_httpx_metadata = self.include_httpx_metadata\n\n        # if self.mode == \"cURL\" and self.curl_input:\n        #     self._build_config = self.parse_curl(self.curl_input, dotdict())\n        #     # After parsing curl, get the normalized URL\n        #     url = self._build_config[\"url_input\"][\"value\"]\n\n        # Â¶ÇÊûúÊèê‰æõ‰∫Ü img_url ‰∏é contextÔºåÂàôËá™Âä®ÊûÑÂª∫ /context ÁöÑ POST ËØ∑Ê±ÇÔºåÁõÆÊ†á URL ‰ΩøÁî®Áî®Êà∑Â°´ÂÜôÁöÑ URL\n        use_img_builder = (\n            isinstance(getattr(self, \"img_url\", None), str)\n            and self.img_url.strip()\n            and isinstance(getattr(self, \"context\", None), str)\n            and self.context.strip()\n        )\n\n        if use_img_builder:\n            try:\n                # ‰ªÖ‰ªéÂõæÁâá URL ‰∏≠ÊèêÂèñ uuid ‰∏éÈ°µÁ†Å idÔºõ‰∏çÂÜç‰ªéÂõæÁâá URL Êé®ÂØºÁõÆÊ†áÂú∞ÂùÄ\n                _, uuid_val, id_str = self._extract_uuid_id_from_img(self.img_url.strip())\n            except ValueError as e:\n                raise ValueError(f\"ÊûÑÂª∫ËØ∑Ê±ÇÂ§±Ë¥•: {e}\")\n\n            # Âº∫Âà∂Ë¶ÅÊ±ÇÁî®Êà∑Êèê‰æõÁõÆÊ†á URLÔºà‰æãÂ¶Ç /context Êé•Âè£Âú∞ÂùÄÔºâ\n            if not isinstance(self.url_input, str) or not self.url_input.strip():\n                raise ValueError(\"Êú™Êèê‰æõÁõÆÊ†á URLÔºàURL Â≠óÊÆµÔºâ„ÄÇËØ∑Â°´ÂÜô /context Êé•Âè£Âú∞ÂùÄ„ÄÇ\")\n\n            # Ëß£Êûê context JSON\n            try:\n                ctx_obj = json.loads(self.context)\n            except json.JSONDecodeError:\n                raise ValueError(\"context ÂøÖÈ°ªÊòØÂêàÊ≥ïÁöÑ JSON Â≠óÁ¨¶‰∏≤Ôºå‰∏îËá≥Â∞ëÂåÖÂê´ desc ‰∏é oral_broadcast\")\n\n            if not isinstance(ctx_obj, dict):\n                raise ValueError(\"context JSON ÂøÖÈ°ªËß£Êûê‰∏∫ÂØπË±°\")\n\n            desc_val = ctx_obj.get(\"desc\")\n            oral_val = ctx_obj.get(\"oral_broadcast\")\n            audio_url = ctx_obj.get(\"audio_url\")\n            video_url = ctx_obj.get(\"video_url\")\n            subtitle_url = ctx_obj.get(\"subtitle_url\")\n            if audio_url is None or video_url is None or subtitle_url is None:\n                raise ValueError(\"context JSON ÈúÄÂåÖÂê´ audio_url ‰∏é video_url subtitle_url Â≠óÊÆµ\")\n\n            # ÊûÑÂª∫ÁõÆÊ†áËØ∑Ê±Ç\n            method = \"POST\"\n            url = self.url_input.strip()\n            # ÂÖàËßÑËåÉÂåñ headers ‰∏∫Â≠óÂÖ∏ÔºåÂÜçËÆæÁΩÆ Content-TypeÔºåÈÅøÂÖç‚Äúlist ‰∏çÊòØÊò†Â∞Ñ‚ÄùÈîôËØØ\n            headers = self._process_headers(headers)\n            headers[\"Content-Type\"] = \"application/json\"\n            body = {\n                \"uuid\": uuid_val,\n                \"item\": {\n                    \"id\": id_str,\n                    \"order\": id_str,\n                    \"image_url\": self.img_url.strip(),\n                    \"audio_url\": audio_url,\n                    \"video_url\": video_url,\n                    \"subtitle_url\": subtitle_url,\n                },\n            }\n\n        # Normalize URL before validationÔºàÊ≠§Êó∂ÂèØËÉΩÊòØÁî®Êà∑‰º†ÁöÑ URL ÊàñËá™Âä®ÊûÑÂª∫ÁöÑ /contextÔºâ\n        url = self._normalize_url(url)\n\n        # Validate URL\n        if not validators.url(url):\n            msg = f\"Invalid URL provided: {url}\"\n            raise ValueError(msg)\n\n        # Process query parameters\n        if isinstance(self.query_params, str):\n            query_params = dict(parse_qsl(self.query_params))\n        else:\n            query_params = self.query_params.data if self.query_params else {}\n\n        # Process headers and body\n        headers = self._process_headers(headers)\n        body = self._process_body(body)\n        url = self.add_query_params(url, query_params)\n\n        async with httpx.AsyncClient() as client:\n            result = await self.make_request(\n                client,\n                method,\n                url,\n                headers,\n                body,\n                timeout,\n                follow_redirects=follow_redirects,\n                save_to_file=save_to_file,\n                include_httpx_metadata=include_httpx_metadata,\n            )\n        self.status = result\n        return result\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        \"\"\"Update the build config based on the selected mode.\"\"\"\n        if field_name != \"mode\":\n            if field_name == \"curl_input\" and self.mode == \"cURL\" and self.curl_input:\n                return self.parse_curl(self.curl_input, build_config)\n            return build_config\n\n        if field_value == \"cURL\":\n            set_field_display(build_config, \"curl_input\", value=True)\n            if build_config[\"curl_input\"][\"value\"]:\n                build_config = self.parse_curl(build_config[\"curl_input\"][\"value\"], build_config)\n        else:\n            set_field_display(build_config, \"curl_input\", value=False)\n\n        return set_current_fields(\n            build_config=build_config,\n            action_fields=MODE_FIELDS,\n            selected_action=field_value,\n            default_fields=DEFAULT_FIELDS,\n            func=set_field_advanced,\n            default_value=True,\n        )\n\n    async def _response_info(\n        self, response: httpx.Response, *, with_file_path: bool = False\n    ) -> tuple[bool, Path | None]:\n        \"\"\"Determine the file path and whether the response content is binary.\n\n        Args:\n            response (Response): The HTTP response object.\n            with_file_path (bool): Whether to save the response content to a file.\n\n        Returns:\n            Tuple[bool, Path | None]:\n                A tuple containing a boolean indicating if the content is binary and the full file path (if applicable).\n        \"\"\"\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        is_binary = \"application/octet-stream\" in content_type or \"application/binary\" in content_type\n\n        if not with_file_path:\n            return is_binary, None\n\n        component_temp_dir = Path(tempfile.gettempdir()) / self.__class__.__name__\n\n        # Create directory asynchronously\n        await aiofiles_os.makedirs(component_temp_dir, exist_ok=True)\n\n        filename = None\n        if \"Content-Disposition\" in response.headers:\n            content_disposition = response.headers[\"Content-Disposition\"]\n            filename_match = re.search(r'filename=\"(.+?)\"', content_disposition)\n            if filename_match:\n                extracted_filename = filename_match.group(1)\n                filename = extracted_filename\n\n        # Step 3: Infer file extension or use part of the request URL if no filename\n        if not filename:\n            # Extract the last segment of the URL path\n            url_path = urlparse(str(response.request.url) if response.request else \"\").path\n            base_name = Path(url_path).name  # Get the last segment of the path\n            if not base_name:  # If the path ends with a slash or is empty\n                base_name = \"response\"\n\n            # Infer file extension\n            content_type_to_extension = {\n                \"text/plain\": \".txt\",\n                \"application/json\": \".json\",\n                \"image/jpeg\": \".jpg\",\n                \"image/png\": \".png\",\n                \"application/octet-stream\": \".bin\",\n            }\n            extension = content_type_to_extension.get(content_type, \".bin\" if is_binary else \".txt\")\n            filename = f\"{base_name}{extension}\"\n\n        # Step 4: Define the full file path\n        file_path = component_temp_dir / filename\n\n        # Step 5: Check if file exists asynchronously and handle accordingly\n        try:\n            # Try to create the file exclusively (x mode) to check existence\n            async with aiofiles.open(file_path, \"x\") as _:\n                pass  # File created successfully, we can use this path\n        except FileExistsError:\n            # If file exists, append a timestamp to the filename\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d%H%M%S%f\")\n            file_path = component_temp_dir / f\"{timestamp}-{filename}\"\n\n        return is_binary, file_path\n"
              },
              "context": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Context JSON",
                "dynamic": false,
                "info": "‰∏ä‰∏ãÊñáÂ≠óÊÆµÔºåJSON Ê†ºÂºèÔºåËá≥Â∞ëÂåÖÂê´ desc ‰∏é oral_broadcast„ÄÇ\nÁ§∫‰æã: {\"desc\": \"...\", \"oral_broadcast\": \"...\"}",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "context",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "curl_input": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "cURL",
                "dynamic": false,
                "info": "Paste a curl command to populate the fields. This will fill in the dictionary fields for headers and body.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "curl_input",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "follow_redirects": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Follow Redirects",
                "dynamic": false,
                "info": "Whether to follow http redirects.",
                "list": false,
                "list_add_label": "Add More",
                "name": "follow_redirects",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "headers": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Headers",
                "dynamic": false,
                "info": "The headers to send with the request",
                "input_types": [
                  "Data"
                ],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "headers",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "description": "Header name",
                      "disable_edit": false,
                      "display_name": "Header",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "key",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "Header value",
                      "disable_edit": false,
                      "display_name": "Value",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "value",
                      "sortable": true,
                      "type": "str"
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": [
                  {
                    "key": "User-Agent",
                    "value": "langflow"
                  }
                ]
              },
              "img_url": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Image URL",
                "dynamic": false,
                "info": "ÂõæÁâáÂú∞ÂùÄÔºå‰ªÖÁî®‰∫éËá™Âä®ÊèêÂèñ uuid ‰∏éÈ°µÁ†ÅÔºõÁõÆÊ†á URL ËØ∑Âú®‰∏äÊñπ URL Â≠óÊÆµÂ°´ÂÜôÔºà‰∏çÂÜç‰ªéÂõæÁâá URL Êé®ÂØºÔºâ„ÄÇ\nÁ§∫‰æã: http://8.137.117.155:8703/image?path=/tmp/ppt_images/<uuid>/images/page_10.png",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "img_url",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "include_httpx_metadata": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Include HTTPx Metadata",
                "dynamic": false,
                "info": "Include properties such as headers, status_code, response_headers, and redirection_history in the output.",
                "list": false,
                "list_add_label": "Add More",
                "name": "include_httpx_metadata",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "method": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Method",
                "dynamic": false,
                "external_options": {},
                "info": "The HTTP method to use.",
                "load_from_db": false,
                "name": "method",
                "options": [
                  "GET",
                  "POST",
                  "PATCH",
                  "PUT",
                  "DELETE"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "POST"
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Enable cURL mode to populate fields from a cURL command.",
                "name": "mode",
                "options": [
                  "URL",
                  "cURL"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "URL"
              },
              "query_params": {
                "_input_type": "DataInput",
                "advanced": true,
                "display_name": "Query Parameters",
                "dynamic": false,
                "info": "The query parameters to append to the URL.",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "query_params",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "save_to_file": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Save to File",
                "dynamic": false,
                "info": "Save the API response to a temporary file",
                "list": false,
                "list_add_label": "Add More",
                "name": "save_to_file",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "The timeout to use for the request.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 300
              },
              "url_input": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "URL",
                "dynamic": false,
                "info": "Enter the URL for the request.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "url_input",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "APIRequest"
        },
        "dragging": false,
        "id": "APIRequest-yuDNo",
        "measured": {
          "height": 560,
          "width": 320
        },
        "position": {
          "x": 13946.408419525922,
          "y": 5244.631596325317
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "TypeConverterComponent-bQpta",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert between different types (Message, Data, DataFrame)",
            "display_name": "Type Convert",
            "documentation": "https://docs.langflow.org/components-processing#type-convert",
            "edited": false,
            "field_order": [
              "input_data",
              "output_type"
            ],
            "frozen": false,
            "icon": "repeat",
            "last_updated": "2025-11-19T12:04:36.763Z",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data Output",
                "group_outputs": false,
                "hidden": null,
                "method": "convert_to_data",
                "name": "data_output",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import HandleInput, Output, TabInput\nfrom langflow.schema import Data, DataFrame, Message\n\n\ndef convert_to_message(v) -> Message:\n    \"\"\"Convert input to Message type.\n\n    Args:\n        v: Input to convert (Message, Data, DataFrame, or dict)\n\n    Returns:\n        Message: Converted Message object\n    \"\"\"\n    return v if isinstance(v, Message) else v.to_message()\n\n\ndef convert_to_data(v: DataFrame | Data | Message | dict) -> Data:\n    \"\"\"Convert input to Data type.\n\n    Args:\n        v: Input to convert (Message, Data, DataFrame, or dict)\n\n    Returns:\n        Data: Converted Data object\n    \"\"\"\n    if isinstance(v, dict):\n        return Data(v)\n    if isinstance(v, Message):\n        return v.to_data()\n    return v if isinstance(v, Data) else v.to_data()\n\n\ndef convert_to_dataframe(v: DataFrame | Data | Message | dict) -> DataFrame:\n    \"\"\"Convert input to DataFrame type.\n\n    Args:\n        v: Input to convert (Message, Data, DataFrame, or dict)\n\n    Returns:\n        DataFrame: Converted DataFrame object\n    \"\"\"\n    if isinstance(v, dict):\n        return DataFrame([v])\n    return v if isinstance(v, DataFrame) else v.to_dataframe()\n\n\nclass TypeConverterComponent(Component):\n    display_name = \"Type Convert\"\n    description = \"Convert between different types (Message, Data, DataFrame)\"\n    documentation: str = \"https://docs.langflow.org/components-processing#type-convert\"\n    icon = \"repeat\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Input\",\n            input_types=[\"Message\", \"Data\", \"DataFrame\"],\n            info=\"Accept Message, Data or DataFrame as input\",\n            required=True,\n        ),\n        TabInput(\n            name=\"output_type\",\n            display_name=\"Output Type\",\n            options=[\"Message\", \"Data\", \"DataFrame\"],\n            info=\"Select the desired output data type\",\n            real_time_refresh=True,\n            value=\"Message\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Message Output\",\n            name=\"message_output\",\n            method=\"convert_to_message\",\n        )\n    ]\n\n    def update_outputs(self, frontend_node: dict, field_name: str, field_value: Any) -> dict:\n        \"\"\"Dynamically show only the relevant output based on the selected output type.\"\"\"\n        if field_name == \"output_type\":\n            # Start with empty outputs\n            frontend_node[\"outputs\"] = []\n\n            # Add only the selected output type\n            if field_value == \"Message\":\n                frontend_node[\"outputs\"].append(\n                    Output(\n                        display_name=\"Message Output\",\n                        name=\"message_output\",\n                        method=\"convert_to_message\",\n                    ).to_dict()\n                )\n            elif field_value == \"Data\":\n                frontend_node[\"outputs\"].append(\n                    Output(\n                        display_name=\"Data Output\",\n                        name=\"data_output\",\n                        method=\"convert_to_data\",\n                    ).to_dict()\n                )\n            elif field_value == \"DataFrame\":\n                frontend_node[\"outputs\"].append(\n                    Output(\n                        display_name=\"DataFrame Output\",\n                        name=\"dataframe_output\",\n                        method=\"convert_to_dataframe\",\n                    ).to_dict()\n                )\n\n        return frontend_node\n\n    def convert_to_message(self) -> Message:\n        \"\"\"Convert input to Message type.\"\"\"\n        input_value = self.input_data[0] if isinstance(self.input_data, list) else self.input_data\n\n        # Handle string input by converting to Message first\n        if isinstance(input_value, str):\n            input_value = Message(text=input_value)\n\n        result = convert_to_message(input_value)\n        self.status = result\n        return result\n\n    def convert_to_data(self) -> Data:\n        \"\"\"Convert input to Data type.\"\"\"\n        input_value = self.input_data[0] if isinstance(self.input_data, list) else self.input_data\n\n        # Handle string input by converting to Message first\n        if isinstance(input_value, str):\n            input_value = Message(text=input_value)\n\n        result = convert_to_data(input_value)\n        self.status = result\n        return result\n\n    def convert_to_dataframe(self) -> DataFrame:\n        \"\"\"Convert input to DataFrame type.\"\"\"\n        input_value = self.input_data[0] if isinstance(self.input_data, list) else self.input_data\n\n        # Handle string input by converting to Message first\n        if isinstance(input_value, str):\n            input_value = Message(text=input_value)\n\n        result = convert_to_dataframe(input_value)\n        self.status = result\n        return result\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "Accept Message, Data or DataFrame as input",
                "input_types": [
                  "Message",
                  "Data",
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "output_type": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Output Type",
                "dynamic": false,
                "info": "Select the desired output data type",
                "name": "output_type",
                "options": [
                  "Message",
                  "Data",
                  "DataFrame"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Data"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "TypeConverterComponent"
        },
        "dragging": false,
        "id": "TypeConverterComponent-bQpta",
        "measured": {
          "height": 274,
          "width": 320
        },
        "position": {
          "x": 10239.415611514152,
          "y": 5899.581684530609
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-NR60l",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep",
              "clean_data"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Clean Data",
                "dynamic": false,
                "info": "Enable to clean the data by removing empty rows and lines in each cell of the DataFrame/ Data object.",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Clean Data\",\n            info=(\n                \"Enable to clean the data by removing empty rows and lines \"\n                \"in each cell of the DataFrame/ Data object.\"\n            ),\n            value=True,\n            advanced=True,\n            required=False,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = field_value == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = field_value == \"Parser\"\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "ÂèñËøôÊù°Êï∞ÊçÆ‰∏≠ppt_imagesÂíåimages‰∏≠Èó¥ÁöÑÂ≠óÁ¨¶‰∏≤: {results[0][value]}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-NR60l",
        "measured": {
          "height": 341,
          "width": 320
        },
        "position": {
          "x": 11056.810310331024,
          "y": 5925.023221888631
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "LanguageModelComponent-vkYKd",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Runs a language model given a specified provider.",
            "display_name": "Language Model",
            "documentation": "https://docs.langflow.org/components-models",
            "edited": false,
            "field_order": [
              "provider",
              "model_name",
              "input_value",
              "system_message",
              "stream",
              "temperature"
            ],
            "frozen": false,
            "icon": "brain-circuit",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {
              "keywords": [
                "model",
                "llm",
                "language model",
                "large language model"
              ]
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Model Response",
                "group_outputs": false,
                "method": "text_response",
                "name": "text_output",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "group_outputs": false,
                "method": "build_model",
                "name": "model_output",
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": 0,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import os\nfrom typing import Any\n\nfrom langchain_openai import ChatOpenAI\n\nfrom langflow.base.models.anthropic_constants import ANTHROPIC_MODELS\nfrom langflow.base.models.google_generative_ai_constants import GOOGLE_GENERATIVE_AI_MODELS\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import OPENAI_CHAT_MODEL_NAMES, OPENAI_REASONING_MODEL_NAMES\nfrom langflow.custom_flowteam.base.models.anthropic.chat_models import ChatAnthropic\nfrom langflow.custom_flowteam.base.models.google_genai.chat_models import CustomChatGoogleGenerativeAI\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.helpers.flow import retrieve_flow_name\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.io import DropdownInput, MessageInput, MultilineInput, SliderInput\nfrom langflow.schema.dotdict import dotdict\n\n\nclass LanguageModelComponent(LCModelComponent):\n    display_name = \"Language Model\"\n    description = \"Runs a language model given a specified provider.\"\n    documentation: str = \"https://docs.langflow.org/components-models\"\n    icon = \"brain-circuit\"\n    category = \"models\"\n    priority = 0  # Set priority to 0 to make it appear first\n\n    flow_token: str | None = None\n    flow_tenant: str | None = None\n    flow_domain_url: str = os.environ.get(\"FLOW_DOMAIN_URL\", \"https://flow.ciandt.com\")\n\n    inputs = [\n        DropdownInput(\n            name=\"provider\",\n            display_name=\"Model Provider\",\n            options=[\"OpenAI\", \"Anthropic\", \"Google\"],\n            value=\"OpenAI\",\n            info=\"Select the model provider\",\n            real_time_refresh=True,\n            options_metadata=[{\"icon\": \"OpenAI\"}, {\"icon\": \"Anthropic\"}, {\"icon\": \"GoogleGenerativeAI\"}],\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            options=OPENAI_CHAT_MODEL_NAMES + OPENAI_REASONING_MODEL_NAMES,\n            value=OPENAI_CHAT_MODEL_NAMES[0],\n            info=\"Select the model to use\",\n            real_time_refresh=True,\n        ),\n        # SecretStrInput(\n        #    name=\"api_key\",\n        #    display_name=\"OpenAI API Key\",\n        #    info=\"Model Provider API key\",\n        #    required=False,\n        #    show=True,\n        #    real_time_refresh=True,\n        # ),\n        MessageInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            info=\"The input text to send to the model\",\n        ),\n        MultilineInput(\n            name=\"system_message\",\n            display_name=\"System Message\",\n            info=\"A system message that helps set the behavior of the assistant\",\n            advanced=False,\n        ),\n        BoolInput(\n            name=\"stream\",\n            display_name=\"Stream\",\n            info=\"Whether to stream the response\",\n            value=False,\n            advanced=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            info=\"Controls randomness in responses\",\n            range_spec=RangeSpec(min=0, max=1, step=0.01),\n            advanced=False,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:\n        provider = self.provider\n        model_name = self.model_name\n        temperature = self.temperature\n        stream = self.stream\n\n        custom_headers = {\n            \"FlowTenant\": self.flow_tenant,\n            \"FlowAgent\": retrieve_flow_name(self),\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {self.flow_token}\",\n        }\n        custom_headers = {k: v for k, v in custom_headers.items() if v is not None}\n\n        if provider == \"OpenAI\":\n            # if not self.api_key:\n            #    msg = \"OpenAI API key is required when using OpenAI provider\"\n            #    raise ValueError(msg)\n\n            if model_name in OPENAI_REASONING_MODEL_NAMES:\n                # reasoning models do not support temperature (yet)\n                temperature = None\n\n            if \"gpt-5\" in model_name:\n                temperature = 1  # For gpt-5 models only value 1 is supported\n\n            base_domain = self.flow_domain_url.rstrip(\"/\")\n            proxy_path_base = \"/ai-orchestration-api/v1/openai\"\n            final_base_url = f\"{base_domain}{proxy_path_base}\"\n\n            return ChatOpenAI(\n                model_name=model_name,\n                temperature=temperature,\n                streaming=stream,\n                default_headers=custom_headers,\n                base_url=final_base_url,\n                openai_api_key=None,\n            )\n\n        if provider == \"Anthropic\":\n            # if not self.api_key:\n            #    msg = \"Anthropic API key is required when using Anthropic provider\"\n            #    raise ValueError(msg)\n\n            base_domain = self.flow_domain_url.rstrip(\"/\")\n            proxy_path_base = \"/ai-orchestration-api/v1/bedrock/\"\n            final_base_url = f\"{base_domain}{proxy_path_base}\"\n\n            extra_body_fields = {\n                \"extra_body\": {\n                    \"anthropic_version\": \"bedrock-2023-05-31\",\n                    \"allowedModels\": [model_name],\n                }\n            }\n\n            return ChatAnthropic(\n                model=model_name,\n                temperature=temperature,\n                streaming=stream,\n                anthropic_api_url=final_base_url,\n                default_headers=custom_headers,\n                anthropic_api_key=\"proxy-authentication-handled-by-headers\",\n                model_kwargs=extra_body_fields,\n            )\n\n        if provider == \"Google\":\n            return CustomChatGoogleGenerativeAI(\n                model=model_name,\n                temperature=temperature,\n                streaming=stream,\n                google_api_key=\"proxy-authentication-handled-by-headers\",\n                default_headers=custom_headers,\n                base_url=self.flow_domain_url.rstrip(\"/\"),\n            )\n        msg = f\"Unknown provider: {provider}\"\n        raise ValueError(msg)\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        if field_name == \"provider\":\n            if field_value == \"OpenAI\":\n                build_config[\"model_name\"][\"options\"] = OPENAI_CHAT_MODEL_NAMES + OPENAI_REASONING_MODEL_NAMES\n                build_config[\"model_name\"][\"value\"] = OPENAI_CHAT_MODEL_NAMES[0]\n                # build_config[\"api_key\"][\"display_name\"] = \"OpenAI API Key\"\n            elif field_value == \"Anthropic\":\n                build_config[\"model_name\"][\"options\"] = ANTHROPIC_MODELS\n                build_config[\"model_name\"][\"value\"] = ANTHROPIC_MODELS[0]\n                # build_config[\"api_key\"][\"display_name\"] = \"Anthropic API Key\"\n            elif field_value == \"Google\":\n                build_config[\"model_name\"][\"options\"] = GOOGLE_GENERATIVE_AI_MODELS\n                build_config[\"model_name\"][\"value\"] = GOOGLE_GENERATIVE_AI_MODELS[0]\n                # build_config[\"api_key\"][\"display_name\"] = \"Google API Key\"\n        elif field_name == \"model_name\" and field_value.startswith(\"o1\") and self.provider == \"OpenAI\":\n            # Hide system_message for o1 models - currently unsupported\n            if \"system_message\" in build_config:\n                build_config[\"system_message\"][\"show\"] = False\n        elif field_name == \"model_name\" and not field_value.startswith(\"o1\") and \"system_message\" in build_config:\n            build_config[\"system_message\"][\"show\"] = True\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input text to send to the model",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Name",
                "dynamic": false,
                "external_options": {},
                "info": "Select the model to use",
                "name": "model_name",
                "options": [
                  "gpt-4o",
                  "gpt-4.1",
                  "gpt-4o-mini",
                  "gpt-5",
                  "gpt-5-mini",
                  "gpt-5-nano",
                  "o1",
                  "o1-mini",
                  "o3-mini"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gpt-4o"
              },
              "provider": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Provider",
                "dynamic": false,
                "external_options": {},
                "info": "Select the model provider",
                "name": "provider",
                "options": [
                  "OpenAI",
                  "Anthropic",
                  "Google"
                ],
                "options_metadata": [
                  {
                    "icon": "OpenAI"
                  },
                  {
                    "icon": "Anthropic"
                  },
                  {
                    "icon": "GoogleGenerativeAI"
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "OpenAI"
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Whether to stream the response",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "A system message that helps set the behavior of the assistant",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "ÂèñËøôÊù°Êï∞ÊçÆ‰∏≠ppt_imagesÂíåimages‰∏≠Èó¥ÁöÑÂ≠óÁ¨¶‰∏≤"
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Controls randomness in responses",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 1,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              }
            },
            "tool_mode": false
          },
          "selected_output": "text_output",
          "showNode": true,
          "type": "LanguageModelComponent"
        },
        "dragging": false,
        "id": "LanguageModelComponent-vkYKd",
        "measured": {
          "height": 552,
          "width": 320
        },
        "position": {
          "x": 11053.757731828622,
          "y": 6471.958353241264
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "APIRequest-B5UnD",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Make HTTP requests using URL or cURL commands.",
            "display_name": "Aggregation results API Request",
            "documentation": "https://docs.langflow.org/components-data#api-request",
            "edited": true,
            "field_order": [
              "url_input",
              "curl_input",
              "method",
              "mode",
              "query_params",
              "body",
              "headers",
              "timeout",
              "follow_redirects",
              "save_to_file",
              "include_httpx_metadata"
            ],
            "frozen": false,
            "icon": "Globe",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "API Response",
                "group_outputs": false,
                "hidden": null,
                "method": "make_api_request",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "body": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Body",
                "dynamic": false,
                "info": "The body to send with the request as a dictionary (for POST, PATCH, PUT).",
                "input_types": [
                  "Data"
                ],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "body",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "description": "Parameter name",
                      "disable_edit": false,
                      "display_name": "Key",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "key",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "Parameter value",
                      "disable_edit": false,
                      "display_name": "Value",
                      "edit_mode": "popover",
                      "filterable": true,
                      "hidden": false,
                      "name": "value",
                      "sortable": true
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": []
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nimport re\nimport tempfile\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Any\nfrom urllib.parse import parse_qsl, urlencode, urlparse, urlunparse\n\nimport aiofiles\nimport aiofiles.os as aiofiles_os\nimport httpx\nimport validators\n\nfrom langflow.base.curl.parse import parse_context\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import TabInput\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    IntInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TableInput,\n)\nfrom langflow.schema.data import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.services.deps import get_settings_service\nfrom langflow.utils.component_utils import set_current_fields, set_field_advanced, set_field_display\n\n# Define fields for each mode\nMODE_FIELDS = {\n    \"URL\": [\n        \"url_input\",\n        \"method\",\n    ],\n    \"cURL\": [\"curl_input\"],\n}\n\n# Fields that should always be visible\nDEFAULT_FIELDS = [\"mode\"]\n\n\nclass APIRequestComponent(Component):\n    display_name = \"Aggregation results API Request\"\n    description = \"Make HTTP requests using URL or cURL commands.\"\n    documentation: str = \"https://docs.langflow.org/components-data#api-request\"\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"url_input\",\n            display_name=\"URL\",\n            info=\"Enter the URL for the request.\",\n            advanced=False,\n            tool_mode=True,\n        ),\n        MultilineInput(\n            name=\"curl_input\",\n            display_name=\"cURL\",\n            info=(\n                \"Paste a curl command to populate the fields. \"\n                \"This will fill in the dictionary fields for headers and body.\"\n            ),\n            real_time_refresh=True,\n            tool_mode=True,\n            advanced=True,\n            show=False,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"],\n            value=\"GET\",\n            info=\"The HTTP method to use.\",\n            real_time_refresh=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"URL\", \"cURL\"],\n            value=\"URL\",\n            info=\"Enable cURL mode to populate fields from a cURL command.\",\n            real_time_refresh=True,\n        ),\n        DataInput(\n            name=\"query_params\",\n            display_name=\"Query Parameters\",\n            info=\"The query parameters to append to the URL.\",\n            advanced=True,\n        ),\n        TableInput(\n            name=\"body\",\n            display_name=\"Body\",\n            info=\"The body to send with the request as a dictionary (for POST, PATCH, PUT).\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Key\",\n                    \"type\": \"str\",\n                    \"description\": \"Parameter name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"description\": \"Parameter value\",\n                },\n            ],\n            value=[],\n            input_types=[\"Data\"],\n            advanced=True,\n            real_time_refresh=True,\n        ),\n        TableInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Header\",\n                    \"type\": \"str\",\n                    \"description\": \"Header name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"type\": \"str\",\n                    \"description\": \"Header value\",\n                },\n            ],\n            value=[{\"key\": \"User-Agent\", \"value\": get_settings_service().settings.user_agent}],\n            advanced=True,\n            input_types=[\"Data\"],\n            real_time_refresh=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            value=30,\n            info=\"The timeout to use for the request.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"follow_redirects\",\n            display_name=\"Follow Redirects\",\n            value=True,\n            info=\"Whether to follow http redirects.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"save_to_file\",\n            display_name=\"Save to File\",\n            value=False,\n            info=\"Save the API response to a temporary file\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_httpx_metadata\",\n            display_name=\"Include HTTPx Metadata\",\n            value=False,\n            info=(\n                \"Include properties such as headers, status_code, response_headers, \"\n                \"and redirection_history in the output.\"\n            ),\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"API Response\", name=\"data\", method=\"make_api_request\"),\n    ]\n\n    def _parse_json_value(self, value: Any) -> Any:\n        \"\"\"Parse a value that might be a JSON string.\"\"\"\n        if not isinstance(value, str):\n            return value\n\n        try:\n            parsed = json.loads(value)\n        except json.JSONDecodeError:\n            return value\n        else:\n            return parsed\n\n    def _process_body(self, body: Any) -> dict:\n        \"\"\"Process the body input into a valid dictionary.\"\"\"\n        if body is None:\n            return {}\n        if hasattr(body, \"data\"):\n            body = body.data\n        if isinstance(body, dict):\n            return self._process_dict_body(body)\n        if isinstance(body, str):\n            return self._process_string_body(body)\n        if isinstance(body, list):\n            return self._process_list_body(body)\n        return {}\n\n    def _process_dict_body(self, body: dict) -> dict:\n        \"\"\"Process dictionary body by parsing JSON values.\"\"\"\n        return {k: self._parse_json_value(v) for k, v in body.items()}\n\n    def _process_string_body(self, body: str) -> dict:\n        \"\"\"Process string body by attempting JSON parse.\"\"\"\n        try:\n            return self._process_body(json.loads(body))\n        except json.JSONDecodeError:\n            return {\"data\": body}\n\n    def _process_list_body(self, body: list) -> dict:\n        \"\"\"Process list body by converting to key-value dictionary.\"\"\"\n        processed_dict = {}\n        try:\n            for item in body:\n                # Unwrap Data objects\n                current_item = item\n                if hasattr(item, \"data\"):\n                    unwrapped_data = item.data\n                    # If the unwrapped data is a dict but not key-value format, use it directly\n                    if isinstance(unwrapped_data, dict) and not self._is_valid_key_value_item(unwrapped_data):\n                        return unwrapped_data\n                    current_item = unwrapped_data\n                if not self._is_valid_key_value_item(current_item):\n                    continue\n                key = current_item[\"key\"]\n                value = self._parse_json_value(current_item[\"value\"])\n                processed_dict[key] = value\n        except (KeyError, TypeError, ValueError) as e:\n            self.log(f\"Failed to process body list: {e}\")\n            return {}\n        return processed_dict\n\n    def _is_valid_key_value_item(self, item: Any) -> bool:\n        \"\"\"Check if an item is a valid key-value dictionary.\"\"\"\n        return isinstance(item, dict) and \"key\" in item and \"value\" in item\n\n    def parse_curl(self, curl: str, build_config: dotdict) -> dotdict:\n        \"\"\"Parse a cURL command and update build configuration.\"\"\"\n        try:\n            parsed = parse_context(curl)\n\n            # Update basic configuration\n            url = parsed.url\n            # Normalize URL before setting it\n            url = self._normalize_url(url)\n\n            build_config[\"url_input\"][\"value\"] = url\n            build_config[\"method\"][\"value\"] = parsed.method.upper()\n\n            # Process headers\n            headers_list = [{\"key\": k, \"value\": v} for k, v in parsed.headers.items()]\n            build_config[\"headers\"][\"value\"] = headers_list\n\n            # Process body data\n            if not parsed.data:\n                build_config[\"body\"][\"value\"] = []\n            elif parsed.data:\n                try:\n                    json_data = json.loads(parsed.data)\n                    if isinstance(json_data, dict):\n                        body_list = [\n                            {\"key\": k, \"value\": json.dumps(v) if isinstance(v, dict | list) else str(v)}\n                            for k, v in json_data.items()\n                        ]\n                        build_config[\"body\"][\"value\"] = body_list\n                    else:\n                        build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": json.dumps(json_data)}]\n                except json.JSONDecodeError:\n                    build_config[\"body\"][\"value\"] = [{\"key\": \"data\", \"value\": parsed.data}]\n\n        except Exception as exc:\n            msg = f\"Error parsing curl: {exc}\"\n            self.log(msg)\n            raise ValueError(msg) from exc\n\n        return build_config\n\n    def _normalize_url(self, url: str) -> str:\n        \"\"\"Normalize URL by adding https:// if no protocol is specified.\"\"\"\n        if not url or not isinstance(url, str):\n            msg = \"URL cannot be empty\"\n            raise ValueError(msg)\n\n        url = url.strip()\n        if url.startswith((\"http://\", \"https://\")):\n            return url\n        return f\"https://{url}\"\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: dict | None = None,\n        body: Any = None,\n        timeout: int = 5,\n        *,\n        follow_redirects: bool = True,\n        save_to_file: bool = False,\n        include_httpx_metadata: bool = False,\n    ) -> Data:\n        method = method.upper()\n        if method not in {\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"}:\n            msg = f\"Unsupported method: {method}\"\n            raise ValueError(msg)\n\n        processed_body = self._process_body(body)\n        redirection_history = []\n\n        try:\n            # Prepare request parameters\n            request_params = {\n                \"method\": method,\n                \"url\": url,\n                \"headers\": headers,\n                \"json\": processed_body,\n                \"timeout\": timeout,\n                \"follow_redirects\": follow_redirects,\n            }\n            response = await client.request(**request_params)\n\n            redirection_history = [\n                {\n                    \"url\": redirect.headers.get(\"Location\", str(redirect.url)),\n                    \"status_code\": redirect.status_code,\n                }\n                for redirect in response.history\n            ]\n\n            is_binary, file_path = await self._response_info(response, with_file_path=save_to_file)\n            response_headers = self._headers_to_dict(response.headers)\n\n            # Base metadata\n            metadata = {\n                \"source\": url,\n                \"status_code\": response.status_code,\n                \"response_headers\": response_headers,\n            }\n\n            if redirection_history:\n                metadata[\"redirection_history\"] = redirection_history\n\n            if save_to_file:\n                mode = \"wb\" if is_binary else \"w\"\n                encoding = response.encoding if mode == \"w\" else None\n                if file_path:\n                    await aiofiles_os.makedirs(file_path.parent, exist_ok=True)\n                    if is_binary:\n                        async with aiofiles.open(file_path, \"wb\") as f:\n                            await f.write(response.content)\n                            await f.flush()\n                    else:\n                        async with aiofiles.open(file_path, \"w\", encoding=encoding) as f:\n                            await f.write(response.text)\n                            await f.flush()\n                    metadata[\"file_path\"] = str(file_path)\n\n                if include_httpx_metadata:\n                    metadata.update({\"headers\": headers})\n                return Data(data=metadata)\n\n            # Handle response content\n            if is_binary:\n                result = response.content\n            else:\n                try:\n                    result = response.json()\n                except json.JSONDecodeError:\n                    self.log(\"Failed to decode JSON response\")\n                    result = response.text.encode(\"utf-8\")\n\n            metadata[\"result\"] = result\n\n            if include_httpx_metadata:\n                metadata.update({\"headers\": headers})\n\n            return Data(data=metadata)\n        except (httpx.HTTPError, httpx.RequestError, httpx.TimeoutException) as exc:\n            self.log(f\"Error making request to {url}\")\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 500,\n                    \"error\": str(exc),\n                    **({\"redirection_history\": redirection_history} if redirection_history else {}),\n                },\n            )\n\n    def add_query_params(self, url: str, params: dict) -> str:\n        \"\"\"Add query parameters to URL efficiently.\"\"\"\n        if not params:\n            return url\n        url_parts = list(urlparse(url))\n        query = dict(parse_qsl(url_parts[4]))\n        query.update(params)\n        url_parts[4] = urlencode(query)\n        return urlunparse(url_parts)\n\n    def _headers_to_dict(self, headers: httpx.Headers) -> dict[str, str]:\n        \"\"\"Convert HTTP headers to a dictionary with lowercased keys.\"\"\"\n        return {k.lower(): v for k, v in headers.items()}\n\n    def _process_headers(self, headers: Any) -> dict:\n        \"\"\"Process the headers input into a valid dictionary.\"\"\"\n        if headers is None:\n            return {}\n        if isinstance(headers, dict):\n            return headers\n        if isinstance(headers, list):\n            # Mudan√ßa para aceitar Flow Credentials\n            if isinstance(headers[0], Data):\n                return headers[0].data[\"headers\"]\n            return {item[\"key\"]: item[\"value\"] for item in headers if self._is_valid_key_value_item(item)}\n        return {}\n\n    async def make_api_request(self) -> Data:\n        \"\"\"Make HTTP request with optimized parameter handling.\"\"\"\n        method = self.method\n        url = self.url_input.strip() if isinstance(self.url_input, str) else \"\"\n        headers = self.headers or {}\n        body = self.body or {}\n        timeout = self.timeout\n        follow_redirects = self.follow_redirects\n        save_to_file = self.save_to_file\n        include_httpx_metadata = self.include_httpx_metadata\n\n        # if self.mode == \"cURL\" and self.curl_input:\n        #     self._build_config = self.parse_curl(self.curl_input, dotdict())\n        #     # After parsing curl, get the normalized URL\n        #     url = self._build_config[\"url_input\"][\"value\"]\n\n        # Normalize URL before validation\n        url = self._normalize_url(url)\n\n        # Validate URL\n        if not validators.url(url):\n            msg = f\"Invalid URL provided: {url}\"\n            raise ValueError(msg)\n\n        # Process query parameters\n        if isinstance(self.query_params, str):\n            query_params = dict(parse_qsl(self.query_params))\n        else:\n            query_params = self.query_params.data if self.query_params else {}\n\n        # Process headers and body\n        headers = self._process_headers(headers)\n        body = self._process_body(body)\n        url = self.add_query_params(url, query_params)\n\n        async with httpx.AsyncClient() as client:\n            result = await self.make_request(\n                client,\n                method,\n                url,\n                headers,\n                body,\n                timeout,\n                follow_redirects=follow_redirects,\n                save_to_file=save_to_file,\n                include_httpx_metadata=include_httpx_metadata,\n            )\n        self.status = result\n        return result\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None) -> dotdict:\n        \"\"\"Update the build config based on the selected mode.\"\"\"\n        if field_name != \"mode\":\n            if field_name == \"curl_input\" and self.mode == \"cURL\" and self.curl_input:\n                return self.parse_curl(self.curl_input, build_config)\n            return build_config\n\n        if field_value == \"cURL\":\n            set_field_display(build_config, \"curl_input\", value=True)\n            if build_config[\"curl_input\"][\"value\"]:\n                build_config = self.parse_curl(build_config[\"curl_input\"][\"value\"], build_config)\n        else:\n            set_field_display(build_config, \"curl_input\", value=False)\n\n        return set_current_fields(\n            build_config=build_config,\n            action_fields=MODE_FIELDS,\n            selected_action=field_value,\n            default_fields=DEFAULT_FIELDS,\n            func=set_field_advanced,\n            default_value=True,\n        )\n\n    async def _response_info(\n        self, response: httpx.Response, *, with_file_path: bool = False\n    ) -> tuple[bool, Path | None]:\n        \"\"\"Determine the file path and whether the response content is binary.\n\n        Args:\n            response (Response): The HTTP response object.\n            with_file_path (bool): Whether to save the response content to a file.\n\n        Returns:\n            Tuple[bool, Path | None]:\n                A tuple containing a boolean indicating if the content is binary and the full file path (if applicable).\n        \"\"\"\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        is_binary = \"application/octet-stream\" in content_type or \"application/binary\" in content_type\n\n        if not with_file_path:\n            return is_binary, None\n\n        component_temp_dir = Path(tempfile.gettempdir()) / self.__class__.__name__\n\n        # Create directory asynchronously\n        await aiofiles_os.makedirs(component_temp_dir, exist_ok=True)\n\n        filename = None\n        if \"Content-Disposition\" in response.headers:\n            content_disposition = response.headers[\"Content-Disposition\"]\n            filename_match = re.search(r'filename=\"(.+?)\"', content_disposition)\n            if filename_match:\n                extracted_filename = filename_match.group(1)\n                filename = extracted_filename\n\n        # Step 3: Infer file extension or use part of the request URL if no filename\n        if not filename:\n            # Extract the last segment of the URL path\n            url_path = urlparse(str(response.request.url) if response.request else \"\").path\n            base_name = Path(url_path).name  # Get the last segment of the path\n            if not base_name:  # If the path ends with a slash or is empty\n                base_name = \"response\"\n\n            # Infer file extension\n            content_type_to_extension = {\n                \"text/plain\": \".txt\",\n                \"application/json\": \".json\",\n                \"image/jpeg\": \".jpg\",\n                \"image/png\": \".png\",\n                \"application/octet-stream\": \".bin\",\n            }\n            extension = content_type_to_extension.get(content_type, \".bin\" if is_binary else \".txt\")\n            filename = f\"{base_name}{extension}\"\n\n        # Step 4: Define the full file path\n        file_path = component_temp_dir / filename\n\n        # Step 5: Check if file exists asynchronously and handle accordingly\n        try:\n            # Try to create the file exclusively (x mode) to check existence\n            async with aiofiles.open(file_path, \"x\") as _:\n                pass  # File created successfully, we can use this path\n        except FileExistsError:\n            # If file exists, append a timestamp to the filename\n            timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d%H%M%S%f\")\n            file_path = component_temp_dir / f\"{timestamp}-{filename}\"\n\n        return is_binary, file_path\n"
              },
              "curl_input": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "cURL",
                "dynamic": false,
                "info": "Paste a curl command to populate the fields. This will fill in the dictionary fields for headers and body.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "curl_input",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "follow_redirects": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Follow Redirects",
                "dynamic": false,
                "info": "Whether to follow http redirects.",
                "list": false,
                "list_add_label": "Add More",
                "name": "follow_redirects",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "headers": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Headers",
                "dynamic": false,
                "info": "The headers to send with the request",
                "input_types": [
                  "Data"
                ],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "headers",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "description": "Header name",
                      "disable_edit": false,
                      "display_name": "Header",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "key",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "Header value",
                      "disable_edit": false,
                      "display_name": "Value",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "value",
                      "sortable": true,
                      "type": "str"
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": [
                  {
                    "key": "User-Agent",
                    "value": "langflow"
                  }
                ]
              },
              "include_httpx_metadata": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Include HTTPx Metadata",
                "dynamic": false,
                "info": "Include properties such as headers, status_code, response_headers, and redirection_history in the output.",
                "list": false,
                "list_add_label": "Add More",
                "name": "include_httpx_metadata",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "method": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Method",
                "dynamic": false,
                "external_options": {},
                "info": "The HTTP method to use.",
                "name": "method",
                "options": [
                  "GET",
                  "POST",
                  "PATCH",
                  "PUT",
                  "DELETE"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "GET"
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Enable cURL mode to populate fields from a cURL command.",
                "name": "mode",
                "options": [
                  "URL",
                  "cURL"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "URL"
              },
              "query_params": {
                "_input_type": "DataInput",
                "advanced": true,
                "display_name": "Query Parameters",
                "dynamic": false,
                "info": "The query parameters to append to the URL.",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "query_params",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "save_to_file": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Save to File",
                "dynamic": false,
                "info": "Save the API response to a temporary file",
                "list": false,
                "list_add_label": "Add More",
                "name": "save_to_file",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "The timeout to use for the request.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 30
              },
              "url_input": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "URL",
                "dynamic": false,
                "info": "Enter the URL for the request.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "url_input",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "APIRequest"
        },
        "dragging": false,
        "id": "APIRequest-B5UnD",
        "measured": {
          "height": 395,
          "width": 320
        },
        "position": {
          "x": 11709.420915986611,
          "y": 6472.147132319554
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-4MaHk",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep",
              "clean_data"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Clean Data",
                "dynamic": false,
                "info": "Enable to clean the data by removing empty rows and lines in each cell of the DataFrame/ Data object.",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Clean Data\",\n            info=(\n                \"Enable to clean the data by removing empty rows and lines \"\n                \"in each cell of the DataFrame/ Data object.\"\n            ),\n            value=True,\n            advanced=True,\n            required=False,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = field_value == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = field_value == \"Parser\"\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{{'segments': {result[items]}}}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-4MaHk",
        "measured": {
          "height": 341,
          "width": 320
        },
        "position": {
          "x": 11705.919813502922,
          "y": 7158.293392192775
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "JsonFormatter-UQUk3",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Parses and outputs clean JSON data.",
            "display_name": "JSON Formatter",
            "documentation": "",
            "edited": true,
            "field_order": [
              "input_value"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "JSON Data",
                "group_outputs": false,
                "hidden": null,
                "method": "format_json",
                "name": "formatted_output",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Table View",
                "group_outputs": false,
                "hidden": null,
                "method": "build_dataframe",
                "name": "dataframe_output",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nimport re\nimport ast\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\n\n\nclass JsonFormatterComponent(Component):\n    display_name = \"JSON Formatter\"\n    description = \"Parses and outputs clean JSON data.\"\n    name = \"JsonFormatter\"\n    icon = \"braces\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input JSON\",\n            info=\"Paste your raw JSON string here.\",\n            value='{\"segments\": []}',\n            tool_mode=True,\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            name=\"formatted_output\",\n            display_name=\"JSON Data\",\n            method=\"format_json\",\n        ),\n        Output(\n            name=\"dataframe_output\",\n            display_name=\"Table View\",\n            method=\"build_dataframe\",\n        ),\n    ]\n\n    def parse_input(self):\n        \"\"\"\n        Ëß£ÊûêËæìÂÖ•ÔºåÁ°Æ‰øùËøîÂõû Python Â≠óÂÖ∏ÊàñÂàóË°®\n        \"\"\"\n        value = self.input_value\n\n        # 1. Â¶ÇÊûúÂ∑≤ÁªèÊòØÂ≠óÂÖ∏ÔºåÁõ¥Êé•ËøîÂõû\n        if isinstance(value, dict):\n            return value\n        \n        # 2. Â¶ÇÊûúÊòØ Data ÂØπË±°ÔºåÊèêÂèñ data\n        if hasattr(value, \"data\") and isinstance(value.data, dict):\n             return value.data\n        \n        # 3. Â¶ÇÊûúÊòØÂ≠óÁ¨¶‰∏≤ÔºåÂ∞ùËØïËß£Êûê\n        if isinstance(value, str):\n            # ÂÖàËøõË°åÊ†áÂáÜ JSON Ëß£Êûê\n            clean_value = value.strip()\n            try:\n                return json.loads(clean_value)\n            except json.JSONDecodeError:\n                pass\n\n            # Â∞ùËØï‰øÆÂ§çÔºö\n            # 1) ÂéªÈô§ Markdown ‰ª£Á†ÅÂùó‰∏éÂèçÂºïÂè∑ÂåÖË£π\n            fixed = clean_value.replace(\"```json\", \"\").replace(\"```\", \"\")\n            fixed = fixed.replace(\"`\", \"\")\n            # 2) ÊõøÊç¢ Python ÂºèÂçïÂºïÂè∑Â≠óÁ¨¶‰∏≤‰∏∫ÂèåÂºïÂè∑\n            #    Ê≥®ÊÑèÔºöÊ≠§Êìç‰ΩúÂØπÂê´ÊúâÂçïÂºïÂè∑ÁöÑËá™ÁÑ∂ËØ≠Ë®ÄÂèØËÉΩ‰∏çÂÆåÂÖ®ÂÆâÂÖ®Ôºå‰ΩÜÂØπÁªìÊûÑÂåñÈîÆÂÄºÊúâÊïà\n            fixed = re.sub(r\"'([^']*)'\", r'\"\\1\"', fixed)\n            # 3) ÊõøÊç¢ Python Â∏ÉÂ∞î/Á©∫ÂÄº‰∏∫ JSON ËßÑËåÉ\n            fixed = re.sub(r\"\\bTrue\\b\", \"true\", fixed)\n            fixed = re.sub(r\"\\bFalse\\b\", \"false\", fixed)\n            fixed = re.sub(r\"\\bNone\\b\", \"null\", fixed)\n\n            try:\n                return json.loads(fixed)\n            except json.JSONDecodeError:\n                # 4) ÂõûÈÄÄ‰ΩøÁî® ast.literal_eval Ëß£Êûê Python È£éÊ†ºÂ≠óÈù¢Èáè\n                try:\n                    py_obj = ast.literal_eval(clean_value)\n                    if isinstance(py_obj, (dict, list)):\n                        return py_obj\n                except Exception:\n                    pass\n\n                # ÊúÄÁªàÂ§±Ë¥•ÔºöÊäõÂá∫ÊòéÁ°ÆÈîôËØØ\n                raise ValueError(\n                    \"Invalid JSON format: Expecting property name enclosed in double quotes\"\n                )\n        \n        return value\n\n    def format_json(self) -> Data:\n        try:\n            data_obj = self.parse_input()\n            \n            # ÈáçÁÇπ‰øÆÊîπÔºöÁõ¥Êé•Â∞ÜÂØπË±°‰º†Áªô data ÂèÇÊï∞\n            # ‰∏çÂÜçÊâãÂä®Ê∑ªÂä† \"text\" Â≠óÊÆµÔºåËøôÊ†∑ËæìÂá∫ÁïåÈù¢Â∞±ÊòØÂπ≤ÂáÄÁöÑ JSON ÁªìÊûÑ\n            if isinstance(data_obj, dict):\n                return Data(data=data_obj)\n            \n            elif isinstance(data_obj, list):\n                # Â¶ÇÊûúÊòØÂàóË°®ÔºåLangflow Data ÈúÄË¶Å‰∏Ä‰∏™Ê†πÂ≠óÂÖ∏ÔºåÊàë‰ª¨Áî® \"result\" ÂåÖË£π\n                # ÊàñËÄÖÂ¶ÇÊûú‰Ω†ÊÉ≥ËÆ©ÂàóË°®‰Ωú‰∏∫ valueÔºå‰πüÂèØ‰ª•‰∏çÂÅöÂ§ÑÁêÜËßÜÂÖ∑‰ΩìÊÉÖÂÜµËÄåÂÆö\n                # ‰ΩÜÈíàÂØπ‰Ω†ÁöÑ segments Ê°à‰æãÔºåËæìÂÖ•ÊòØ dictÔºå‰ºöËµ∞‰∏äÈù¢ÁöÑÈÄªËæë\n                return Data(data={\"result\": data_obj})\n            \n            else:\n                # ÂÖ∂‰ªñÁ±ªÂûã\n                return Data(data={\"result\": data_obj})\n\n        except Exception as e:\n            self.log(f\"Error formatting JSON: {e}\")\n            return Data(data={\"error\": str(e)})\n\n    def build_dataframe(self) -> DataFrame:\n        \"\"\"\n        Ë°®Ê†ºËßÜÂõæÈÄªËæë\n        \"\"\"\n        try:\n            data_obj = self.parse_input()\n            \n            if isinstance(data_obj, dict):\n                if \"segments\" in data_obj and isinstance(data_obj[\"segments\"], list):\n                    return DataFrame(data_obj[\"segments\"])\n                return DataFrame([data_obj])\n                \n            if isinstance(data_obj, list):\n                return DataFrame(data_obj)\n                \n            return DataFrame()\n        except Exception:\n            return DataFrame()"
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Input JSON",
                "dynamic": false,
                "info": "Paste your raw JSON string here.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{\"segments\": []}"
              }
            },
            "tool_mode": false
          },
          "selected_output": "formatted_output",
          "showNode": true,
          "type": "JsonFormatter"
        },
        "dragging": false,
        "id": "JsonFormatter-UQUk3",
        "measured": {
          "height": 216,
          "width": 320
        },
        "position": {
          "x": 12396.78681618247,
          "y": 5929.0005520584145
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "APIRequest-J2FTE",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Make HTTP requests. Supports long-running tasks like video generation.",
            "display_name": "Video generation API Request",
            "documentation": "https://docs.langflow.org/components-data#api-request",
            "edited": true,
            "field_order": [
              "url_input",
              "method",
              "json_connection",
              "json_manual",
              "headers",
              "timeout",
              "follow_redirects",
              "save_to_file"
            ],
            "frozen": false,
            "icon": "Globe",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Response Data",
                "group_outputs": false,
                "hidden": null,
                "method": "make_api_request",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nimport tempfile\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any\n\nimport aiofiles\nimport aiofiles.os as aiofiles_os\nimport httpx\nimport validators\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.io import (\n    BoolInput,\n    DataInput,\n    DropdownInput,\n    IntInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n    TableInput,\n)\nfrom langflow.schema.data import Data\n\n\nclass APIRequestComponent(Component):\n    display_name = \"Video generation API Request\"\n    description = \"Make HTTP requests. Supports long-running tasks like video generation.\"\n    documentation: str = \"https://docs.langflow.org/components-data#api-request\"\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"url_input\",\n            display_name=\"URL\",\n            info=\"Enter the URL for the request.\",\n            value=\"http://192.168.20.140:8201/api/v1/video/synthesize\",\n            tool_mode=True,\n            required=True,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"],\n            value=\"POST\",\n            info=\"The HTTP method to use.\",\n        ),\n        DataInput(\n            name=\"json_connection\",\n            display_name=\"JSON Connection\",\n            info=\"Connect the output from 'JSON Formatter' here.\",\n            tool_mode=True, \n        ),\n        MultilineInput(\n            name=\"json_manual\",\n            display_name=\"Manual JSON\",\n            info=\"Paste raw JSON here. Ignored if 'JSON Connection' is connected.\",\n            value=\"\",\n        ),\n        TableInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request.\",\n            table_schema=[\n                {\"name\": \"key\", \"display_name\": \"Header\", \"type\": \"str\"},\n                {\"name\": \"value\", \"display_name\": \"Value\", \"type\": \"str\"},\n            ],\n            value=[],\n            advanced=True,\n        ),\n        # --- ÂÖ≥ÈîÆ‰øÆÊîπÁÇπ 1: ÈªòËÆ§Ë∂ÖÊó∂Êîπ‰∏∫ 300 Áßí ---\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout (Seconds)\",\n            value=300, # ÈªòËÆ§ 5 ÂàÜÈíüÔºåÈò≤Ê≠¢ËßÜÈ¢ëÁîüÊàê‰∏≠Êñ≠\n            info=\"Increase this value if the API takes a long time to respond.\",\n            advanced=False, # ÊääÂÆÉÊîæÂà∞ÊôÆÈÄöÈÄâÈ°πÈáåÔºåÊñπ‰æø‰Ω†‰øÆÊîπ\n        ),\n        BoolInput(\n            name=\"follow_redirects\",\n            display_name=\"Follow Redirects\",\n            value=True,\n            info=\"Whether to follow http redirects.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"save_to_file\",\n            display_name=\"Save Response to File\",\n            value=False,\n            info=\"Save the API response to a temporary file (useful for binary data).\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Response Data\", name=\"data\", method=\"make_api_request\"),\n    ]\n\n    def _normalize_url(self, url: str) -> str:\n        if not url or not isinstance(url, str):\n            msg = \"URL cannot be empty\"\n            raise ValueError(msg)\n        url = url.strip()\n        if url.startswith((\"http://\", \"https://\")):\n            return url\n        return f\"https://{url}\"\n\n    def _process_json_data(self) -> Any:\n        if self.json_connection:\n            data_payload = self.json_connection\n            if hasattr(data_payload, \"data\"):\n                data_payload = data_payload.data\n            if isinstance(data_payload, dict) and \"result\" in data_payload and len(data_payload) == 1:\n                 if isinstance(data_payload[\"result\"], (list, dict)):\n                     return data_payload[\"result\"]\n            return data_payload\n\n        manual_text = self.json_manual\n        if isinstance(manual_text, str):\n            clean_str = manual_text.strip()\n            if clean_str:\n                try:\n                    return json.loads(clean_str)\n                except json.JSONDecodeError as e:\n                    self.log(f\"Manual input is not valid JSON: {e}\")\n                    return None\n        return None\n\n    def _process_headers(self, headers: Any) -> dict:\n        if not headers:\n            return {}\n        if hasattr(headers, \"data\") and isinstance(headers.data, dict):\n            return headers.data\n        if isinstance(headers, dict):\n            return headers\n        if isinstance(headers, list):\n            processed = {}\n            for item in headers:\n                if isinstance(item, dict) and \"key\" in item and \"value\" in item:\n                    processed[item[\"key\"]] = item[\"value\"]\n            return processed\n        return {}\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: dict | None = None,\n        json_body: Any = None,\n        timeout: int = 300,\n        *,\n        follow_redirects: bool = True,\n        save_to_file: bool = False,\n    ) -> Data:\n        \n        try:\n            if headers is None:\n                headers = {}\n            \n            headers_lower = {k.lower(): v for k, v in headers.items()}\n            if json_body is not None and \"content-type\" not in headers_lower:\n                headers[\"Content-Type\"] = \"application/json\"\n\n            request_kwargs = {\n                \"method\": method,\n                \"url\": url,\n                \"headers\": headers,\n                \"timeout\": float(timeout), # Á°Æ‰øùÊòØ float\n                \"follow_redirects\": follow_redirects,\n            }\n\n            if json_body is not None:\n                request_kwargs[\"json\"] = json_body\n\n            # ÂèëËµ∑ËØ∑Ê±Ç\n            response = await client.request(**request_kwargs)\n            \n            is_binary, file_path = await self._response_info(response, with_file_path=save_to_file)\n            \n            content_result = None\n            try:\n                content_result = response.json()\n            except json.JSONDecodeError:\n                content_result = response.text\n\n            output_data = {}\n            if isinstance(content_result, dict):\n                output_data = content_result\n            elif isinstance(content_result, list):\n                output_data = {\"result\": content_result}\n            else:\n                output_data = {\"result\": content_result}\n            \n            output_data[\"_status_code\"] = response.status_code\n            \n            return Data(data=output_data)\n\n        # --- ÂÖ≥ÈîÆ‰øÆÊîπÁÇπ 2: ÊòéÁ°ÆÊçïËé∑Ë∂ÖÊó∂Âπ∂ËøîÂõûÊ∏ÖÊô∞ÁöÑÈîôËØØ ---\n        except httpx.TimeoutException:\n            error_msg = f\"Request timed out after {timeout} seconds.\"\n            self.log(error_msg)\n            return Data(data={\"error\": error_msg, \"status_code\": 408}) # 408 Request Timeout\n            \n        except Exception as exc:\n            self.log(f\"Error making request to {url}: {exc}\")\n            return Data(data={\"error\": str(exc), \"status_code\": 500})\n\n    async def make_api_request(self) -> Data:\n        method = self.method\n        url = self._normalize_url(self.url_input)\n        headers = self._process_headers(self.headers)\n        json_body = self._process_json_data()\n\n        # ‰ΩøÁî®Êó†ÈôêÂà∂ÁöÑ timeout ÈÖçÁΩÆ ClientÔºåÂÖ∑‰ΩìÁöÑ timeout Áî± request ÂèÇÊï∞ÊéßÂà∂\n        async with httpx.AsyncClient(timeout=None) as client:\n            return await self.make_request(\n                client,\n                method,\n                url,\n                headers,\n                json_body,\n                self.timeout,\n                follow_redirects=self.follow_redirects,\n                save_to_file=self.save_to_file,\n            )\n\n    async def _response_info(self, response: httpx.Response, *, with_file_path: bool = False) -> tuple[bool, Path | None]:\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        is_binary = \"application/octet-stream\" in content_type or \"application/binary\" in content_type or \"image\" in content_type\n\n        if not with_file_path:\n            return is_binary, None\n\n        component_temp_dir = Path(tempfile.gettempdir()) / self.__class__.__name__\n        await aiofiles_os.makedirs(component_temp_dir, exist_ok=True)\n\n        filename = f\"response_{datetime.now().strftime('%Y%m%d%H%M%S')}.bin\"\n        file_path = component_temp_dir / filename\n        \n        if is_binary:\n            async with aiofiles.open(file_path, \"wb\") as f:\n                await f.write(response.content)\n        else:\n            async with aiofiles.open(file_path, \"w\", encoding='utf-8') as f:\n                await f.write(response.text)\n                \n        return is_binary, file_path"
              },
              "follow_redirects": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Follow Redirects",
                "dynamic": false,
                "info": "Whether to follow http redirects.",
                "list": false,
                "list_add_label": "Add More",
                "name": "follow_redirects",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "headers": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Headers",
                "dynamic": false,
                "info": "The headers to send with the request.",
                "is_list": true,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "headers",
                "placeholder": "",
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "disable_edit": false,
                      "display_name": "Header",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "key",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "disable_edit": false,
                      "display_name": "Value",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "value",
                      "sortable": true,
                      "type": "str"
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": [
                  {
                    "key": "User-Agent",
                    "value": "langflow"
                  }
                ]
              },
              "json_connection": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "JSON Connection",
                "dynamic": false,
                "info": "Connect the output from 'JSON Formatter' here.",
                "input_types": [
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "json_connection",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "json_manual": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Manual JSON",
                "dynamic": false,
                "info": "Paste raw JSON here. Ignored if 'JSON Connection' is connected.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "json_manual",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "method": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Method",
                "dynamic": false,
                "external_options": {},
                "info": "The HTTP method to use.",
                "name": "method",
                "options": [
                  "GET",
                  "POST",
                  "PATCH",
                  "PUT",
                  "DELETE"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "POST"
              },
              "save_to_file": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Save Response to File",
                "dynamic": false,
                "info": "Save the API response to a temporary file (useful for binary data).",
                "list": false,
                "list_add_label": "Add More",
                "name": "save_to_file",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Timeout (Seconds)",
                "dynamic": false,
                "info": "Increase this value if the API takes a long time to respond.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 300
              },
              "url_input": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "URL",
                "dynamic": false,
                "info": "Enter the URL for the request.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "url_input",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "APIRequest"
        },
        "dragging": false,
        "id": "APIRequest-J2FTE",
        "measured": {
          "height": 524,
          "width": 320
        },
        "position": {
          "x": 13037.328597701444,
          "y": 5924.68298818196
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-XNusb",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Oral Broadcast Prompt",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": true,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep",
              "clean_data"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "hidden": null,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Clean Data",
                "dynamic": false,
                "info": "Enable to clean the data by removing empty rows and lines in each cell of the DataFrame/ Data object.",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Oral Broadcast Prompt\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Clean Data\",\n            info=(\n                \"Enable to clean the data by removing empty rows and lines \"\n                \"in each cell of the DataFrame/ Data object.\"\n            ),\n            value=True,\n            advanced=True,\n            required=False,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = field_value == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = field_value == \"Parser\"\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "### Role:‰∏ì‰∏öÁöÑPPTÂõæÁâáÂÜÖÂÆπËØÜÂà´‰∏éÂè£Êí≠ËΩ¨Âåñ‰∏ìÂÆ∂\n\n#### Profile:\n- Language: {text1}\n- Description: ÊòØ‰∏Ä‰ΩçÁªèÈ™å‰∏∞ÂØå„ÄÅ‰∏ì‰∏öËÉΩÂäõÂçìË∂äÁöÑ‰∏ìÂÆ∂ÔºåÊìÖÈïøÁ≤æÂáÜËØÜÂà´PPTÊØè‰∏ÄÈ°µÂõæÁâáÁöÑÂÜÖÂÆπÔºåÂπ∂Â∞ÜÂÖ∂ËΩ¨Âåñ‰∏∫ËøûË¥Ø„ÄÅÊµÅÁïÖÁöÑÂè£Êí≠ÂÜÖÂÆπ„ÄÇËÉΩÂ§üÂáÜÁ°ÆÊääÊè°ÂõæÁâáÊ†∏ÂøÉ‰ø°ÊÅØÔºåË∑≥ËøáÊó†ÂÖ≥ËÉåÊôØÊèèËø∞ÔºåÈíàÂØπ‰∏çÂêåÁ±ªÂûãÁöÑPPTÂÜÖÂÆπÔºåÂ¶ÇÊ†áÈ¢òÈ°µ„ÄÅÂõæË°®È°µÁ≠âÔºåÁîüÊàêÊÅ∞ÂΩì‰∏îËá™ÁÑ∂ÁöÑË°®Ëø∞„ÄÇ\n\n#### Skill:\n1. Á≤æÂáÜËØÜÂà´PPTÂçïÂº†ÂõæÁâá‰∏≠ÁöÑÊñáÂ≠ó„ÄÅÂõæË°®Á≠âÂÖ≥ÈîÆ‰ø°ÊÅØ„ÄÇ\n2. ËÉΩÂ§üÂØπÊ†áÈ¢òÁ±ªÁÆÄÂçïPPTÂõæÁâáÁîüÊàêÁÆÄÊ¥ÅÂºÄÂ§¥„ÄÇ\n3. ÂêàÁêÜÊèèËø∞ÂõæË°®ÊâÄÂ±ïÁ§∫ÁöÑ‰ø°ÊÅØ„ÄÇ\n4. Â∞ÜÂçïÈ°µÂõæÁâáÂÜÖÂÆπËΩ¨Âåñ‰∏∫Áã¨Á´ã‰∏îËøûË¥ØÁöÑÂè£Êí≠ËØ≠Âè•„ÄÇ\n5. ÊääÂ§öÈ°µÂè£Êí≠ÂÜÖÂÆπÊãºÊé•ÊàêÈÄªËæëÈ°∫ÁïÖÁöÑÊï¥‰Ωì„ÄÇ\n\n#### Goals:\n1. ÂáÜÁ°ÆËØÜÂà´ÊØèÂº†PPTÂõæÁâáÂÜÖÂÆπ„ÄÇ\n2. ‰∏∫Ê†áÈ¢òÁ±ªPPTÂõæÁâáÁîüÊàêÂêàÈÄÇÁÆÄÁü≠ÂºÄÂ§¥„ÄÇ\n3. ÊÅ∞ÂΩìÊèèËø∞ÂõæË°®‰ø°ÊÅØÔºå‰∏çÈÅóÊºèÂÖ≥ÈîÆÊï∞ÊçÆ„ÄÇ\n4. Á°Æ‰øùÂçïÈ°µÂè£Êí≠ÂÜÖÂÆπÁã¨Á´ã‰∏îÊó†ÂÜó‰ΩôË°®Ëø∞„ÄÇ\n5. ‰ΩøÊï¥‰ΩìÊãºÊé•ÂêéÁöÑÂè£Êí≠ÂÜÖÂÆπÊµÅÁïÖËøûË¥Ø„ÄÇ\n\n#### Constrains:\n1. ‰∏çËÉΩ‰ª•‚ÄúËøôÈ°µpptÁöÑ‰∏ªË¶ÅÂÜÖÂÆπ‚ÄùÁ≠âÁ±ª‰ººË°®Ëø∞ÂºÄÂ§¥„ÄÇ\n2. ‰∏çÊèèËø∞PPTÂõæÁâáÁöÑËÉåÊôØÁ≠âÊó†ÂÖ≥‰ø°ÊÅØ„ÄÇ\n3. ÂøÖÈ°ªÂü∫‰∫éÂçïÂº†ÂõæÁâáÁã¨Á´ãËΩ¨ÂåñÂÜÖÂÆπ„ÄÇ\n4. ‰øùËØÅÂ§öÈ°µÂÜÖÂÆπÊãºÊé•ÂêéÈÄªËæëËøûË¥Ø„ÄÇ\n5. ÁîüÊàêÁöÑÂè£Êí≠ÂÜÖÂÆπÈúÄÁ¨¶ÂêàÊ≠£Â∏∏ËØ≠Ë®ÄË°®Ëææ‰π†ÊÉØ„ÄÇ\n\n#### OutputFormat:\n1. ËæìÂá∫ÂçïÈ°µÂè£Êí≠ÂÜÖÂÆπÊó∂ËØ≠Ë®ÄÁÆÄÊ¥ÅÊòé‰∫Ü„ÄÇ\n2. Êï¥‰ΩìÊãºÊé•ÂêéÁöÑÂè£Êí≠ÂÜÖÂÆπË¶ÅÊúâÂêàÁêÜÁöÑÈÄªËæëË°îÊé•„ÄÇ\n3. ÂõæË°®ÊèèËø∞ÈúÄÂáÜÁ°ÆÂëàÁé∞ÂÖ≥ÈîÆÊï∞ÊçÆÂíåË∂ãÂäø„ÄÇ\n4. Ê†áÈ¢òÁ±ªÂè£Êí≠ÂºÄÂ§¥Ë¶ÅÁÆÄÊ¥Å‰∏îËá™ÁÑ∂„ÄÇ\n5. ÂõûÂ§çÂÜÖÂÆπÊó†ËØ≠Ê≥ïÈîôËØØÂíåÊ≠ß‰πâ„ÄÇ\n\n#### Workflow:\n1. First, ‰ªîÁªÜÊü•ÁúãÊØè‰∏ÄÂº†PPTÂõæÁâáÔºåÂå∫ÂàÜÊòØÊ†áÈ¢òÁ±ªÂõæÁâá„ÄÅÂê´ÂõæË°®ÂõæÁâáËøòÊòØÊôÆÈÄöÊñáÂ≠óÂõæÁâá„ÄÇ\n2. Then, ÂØπ‰∫éÊ†áÈ¢òÁ±ªÂõæÁâáÔºåÂø´ÈÄüÊûÑÊÄùÁÆÄÊ¥ÅËá™ÁÑ∂ÁöÑÂºÄÂ§¥Ë°®Ëø∞„ÄÇ\n3. Next, Ëã•ÊòØÂê´ÂõæË°®ÂõæÁâáÔºåÁ≤æÂáÜÊèêÂèñÂõæË°®ÂÖ≥ÈîÆ‰ø°ÊÅØÂπ∂ÂêàÁêÜÁªÑÁªáËØ≠Ë®ÄÊèèËø∞„ÄÇ\n4. After that, Â∞ÜÊôÆÈÄöÊñáÂ≠óÂõæÁâáÁöÑÊ†∏ÂøÉÂÜÖÂÆπËΩ¨Âåñ‰∏∫ÈÄöÈ°∫ÁöÑÂè£Êí≠ËØ≠Âè•„ÄÇ\n5. Finally, ÊåâÁÖßÂõæÁâáÈ°∫Â∫èÂ∞ÜÂêÑÂçïÈ°µÂè£Êí≠ÂÜÖÂÆπÊãºÊé•Ëµ∑Êù•ÔºåÊ£ÄÊü•Êï¥‰ΩìËøûË¥ØÊÄß„ÄÇ\n\n#### Initialization:\n‰Ωú‰∏∫‰∏ì‰∏öÁöÑPPTÂõæÁâáÂÜÖÂÆπËØÜÂà´ÂíåÈÖçÈü≥ËΩ¨Êç¢‰∏ìÂÆ∂ÔºåÂøÖÈ°ªÈÅµÂæ™Â∞ÜÊØèÂº†PPTÂõæÁâáÂáÜÁ°ÆËΩ¨Êç¢‰∏∫ÊµÅÁïÖÁöÑÈÖçÈü≥ÂÜÖÂÆπÁöÑË¶ÅÊ±Ç„ÄÇÊÇ®ÂøÖÈ°ªÁî®‰∏≠Êñá‰∏éÁî®Êà∑‰∫§Ë∞à„ÄÇÈ¶ñÂÖàÂêëÁî®Êà∑ÊâìÊãõÂëº„ÄÇÁÑ∂Âêé‰ªãÁªç‰∏Ä‰∏ãËá™Â∑±Ôºå‰Ωú‰∏∫ËØ•È¢ÜÂüüÁöÑ‰∏ìÂÆ∂ÔºåËÉΩÂ§üÁ≤æÂáÜÂ§ÑÁêÜPPTÂõæÁâáËØÜÂà´ÂíåÈÖçÈü≥ËΩ¨Êç¢‰ªªÂä°„ÄÇÂπ∂‰ªãÁªç‰∫Ü‰ªîÁªÜÊ£ÄÊü•ÂõæÁâá„ÄÅÂØπÂÖ∂ËøõË°åÂàÜÁ±ª„ÄÅ‰∏∫ÊØèÁßçÁ±ªÂûãÁîüÊàêÈÄÇÂΩìÁöÑÂÜÖÂÆπ„ÄÅÊúÄÂêéÂ∞ÜÂÆÉ‰ª¨ÊãºÊé•Êàê‰∏Ä‰∏™ËøûË¥ØÁöÑÊï¥‰ΩìÁöÑÂ∑•‰ΩúÊµÅÁ®ã„ÄÇ\n\n#### Âè£Êí≠ÂÜÖÂÆπÁöÑËØ≠Ë®ÄÂ¶Ç‰∏ãÔºåoral_broadcastÂ≠óÊÆµË¶Å‰∏•Ê†º‰ΩøÁî®ÁõÆÊ†áËØ≠Ë®ÄÔºö\nÁõÆÊ†áËØ≠Ë®ÄÔºö{text1}\n\n####ËæìÂá∫Ê†ºÂºè\n{{\"desc\":\"ÂõæÁâáÊèèËø∞\",\"oral_broadcast\":\"Âè£Êí≠ÂÜÖÂÆπ\",\"img_url\":\"{text}\"}}\n\n## Ê≥®ÊÑè\nÂõæÁâáÂú∞ÂùÄÂéüÊ†∑ËæìÂá∫Ôºå‰∏çË¶ÅÂÅö‰ªª‰Ωï‰øÆÊîπ"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-XNusb",
        "measured": {
          "height": 341,
          "width": 320
        },
        "position": {
          "x": 10640.389724759621,
          "y": 5397.463969050827
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "TypeConverterComponent-rttuM",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert types and merge 'text1' field into the result.",
            "display_name": "Type Convert + Merge",
            "documentation": "https://docs.langflow.org/components-processing#type-convert",
            "edited": true,
            "field_order": [
              "input_data",
              "text1",
              "output_type"
            ],
            "frozen": false,
            "icon": "repeat",
            "last_updated": "2025-11-20T09:42:18.374Z",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data Output",
                "group_outputs": false,
                "hidden": null,
                "method": "convert_to_data",
                "name": "data_output",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import HandleInput, Output, TabInput, MessageTextInput\nfrom langflow.schema import Data, DataFrame, Message\n\n\n# --- Helper Functions (Global) ---\n\ndef convert_to_message(v) -> Message:\n    \"\"\"Convert input to Message type.\"\"\"\n    return v if isinstance(v, Message) else v.to_message()\n\n\ndef convert_to_data(v: DataFrame | Data | Message | dict) -> Data:\n    \"\"\"Convert input to Data type.\"\"\"\n    if isinstance(v, dict):\n        return Data(v)\n    if isinstance(v, Message):\n        return v.to_data()\n    return v if isinstance(v, Data) else v.to_data()\n\n\ndef convert_to_dataframe(v: DataFrame | Data | Message | dict) -> DataFrame:\n    \"\"\"Convert input to DataFrame type.\"\"\"\n    if isinstance(v, dict):\n        return DataFrame([v])\n    return v if isinstance(v, DataFrame) else v.to_dataframe()\n\n\n# --- Component Class ---\n\nclass TypeConverterComponent(Component):\n    display_name = \"Type Convert + Merge\"\n    description = \"Convert types and merge 'text1' field into the result.\"\n    documentation = \"https://docs.langflow.org/components-processing#type-convert\"\n    icon = \"repeat\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Input Data\",\n            input_types=[\"Message\", \"Data\", \"DataFrame\"],\n            info=\"Accept Message, Data or DataFrame as input\",\n            required=True,\n        ),\n        # --- Êñ∞Â¢ûËæìÂÖ•ËäÇÁÇπ text1 ---\n        MessageTextInput(\n            name=\"text1\",\n            display_name=\"Text 1\",\n            info=\"This text will be merged into the output (as metadata, key, or column).\",\n            value=\"\",\n            tool_mode=True, # ÂÖÅËÆ∏‰Ωú‰∏∫ÂèÇÊï∞ËæìÂÖ•\n        ),\n        TabInput(\n            name=\"output_type\",\n            display_name=\"Output Type\",\n            options=[\"Message\", \"Data\", \"DataFrame\"],\n            info=\"Select the desired output data type\",\n            real_time_refresh=True,\n            value=\"Message\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Message Output\",\n            name=\"message_output\",\n            method=\"convert_to_message\",\n        )\n    ]\n\n    def update_outputs(self, frontend_node: dict, field_name: str, field_value: Any) -> dict:\n        \"\"\"Dynamically show only the relevant output based on the selected output type.\"\"\"\n        if field_name == \"output_type\":\n            # Start with empty outputs\n            frontend_node[\"outputs\"] = []\n\n            # Add only the selected output type\n            if field_value == \"Message\":\n                frontend_node[\"outputs\"].append(\n                    Output(\n                        display_name=\"Message Output\",\n                        name=\"message_output\",\n                        method=\"convert_to_message\",\n                    ).to_dict()\n                )\n            elif field_value == \"Data\":\n                frontend_node[\"outputs\"].append(\n                    Output(\n                        display_name=\"Data Output\",\n                        name=\"data_output\",\n                        method=\"convert_to_data\",\n                    ).to_dict()\n                )\n            elif field_value == \"DataFrame\":\n                frontend_node[\"outputs\"].append(\n                    Output(\n                        display_name=\"DataFrame Output\",\n                        name=\"dataframe_output\",\n                        method=\"convert_to_dataframe\",\n                    ).to_dict()\n                )\n\n        return frontend_node\n\n    def _get_cleaned_input(self):\n        \"\"\"Helper to handle input list/single item logic.\"\"\"\n        input_value = self.input_data\n        # Use the first item if it's a list (keeping original logic behavior)\n        if isinstance(input_value, list) and len(input_value) > 0:\n            input_value = input_value[0]\n        \n        # Handle pure string input by converting to Message first\n        if isinstance(input_value, str):\n            input_value = Message(text=input_value)\n            \n        return input_value\n\n    def convert_to_message(self) -> Message:\n        \"\"\"Convert to Message and inject text1 into metadata.\"\"\"\n        input_value = self._get_cleaned_input()\n        \n        # 1. Convert\n        result_msg = convert_to_message(input_value)\n        \n        # 2. Merge text1\n        if self.text1:\n            # Â¶ÇÊûú data ‰∏∫Á©∫ÔºåÂàùÂßãÂåñÂ≠óÂÖ∏\n            if result_msg.data is None:\n                result_msg.data = {}\n            # Â∞Ü text1 ÊîæÂÖ• metadata\n            result_msg.data[\"text1\"] = self.text1\n            \n        self.status = result_msg\n        return result_msg\n\n    def convert_to_data(self) -> Data:\n        \"\"\"Convert to Data and inject text1 as a key.\"\"\"\n        input_value = self._get_cleaned_input()\n\n        # 1. Convert\n        result_data = convert_to_data(input_value)\n\n        # 2. Merge text1\n        if self.text1:\n            # Data ÂØπË±°Êú¨Ë¥®ÊòØÂØπ dict ÁöÑÂ∞ÅË£ÖÔºåÁõ¥Êé•‰øÆÊîπ .data Â≠óÂÖ∏\n            result_data.data[\"text1\"] = self.text1\n\n        self.status = result_data\n        return result_data\n\n    def convert_to_dataframe(self) -> DataFrame:\n        \"\"\"Convert to DataFrame and add text1 as a column.\"\"\"\n        input_value = self._get_cleaned_input()\n\n        # 1. Convert\n        df = convert_to_dataframe(input_value)\n\n        # 2. Merge text1\n        if self.text1:\n            # ‰∏∫ÊâÄÊúâË°åÊ∑ªÂä†Âêç‰∏∫ text1 ÁöÑÂàó\n            df[\"text1\"] = self.text1\n\n        self.status = df\n        return df"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Input Data",
                "dynamic": false,
                "info": "Accept Message, Data or DataFrame as input",
                "input_types": [
                  "Message",
                  "Data",
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "output_type": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Output Type",
                "dynamic": false,
                "info": "Select the desired output data type",
                "load_from_db": false,
                "name": "output_type",
                "options": [
                  "Message",
                  "Data",
                  "DataFrame"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Data"
              },
              "text1": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Text 1",
                "dynamic": false,
                "info": "This text will be merged into the output (as metadata, key, or column).",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text1",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "TypeConverterComponent"
        },
        "dragging": false,
        "id": "TypeConverterComponent-rttuM",
        "measured": {
          "height": 357,
          "width": 320
        },
        "position": {
          "x": 10241.556397574286,
          "y": 5399.584043808588
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-jnWWE",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generates 5 separate API URLs from one base domain.",
            "display_name": "API Router (5 Ports)",
            "documentation": "",
            "edited": true,
            "field_order": [
              "domain"
            ],
            "frozen": false,
            "icon": "waypoints",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Upload API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_1",
                "name": "url_1",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Video API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_2",
                "name": "url_2",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "TTS API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_3",
                "name": "url_3",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Digital man API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_4",
                "name": "url_4",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Context API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_5",
                "name": "url_5",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Message\n\nclass APIRouteManagerComponent(Component):\n    display_name = \"API Router (5 Ports)\"\n    description = \"Generates 5 separate API URLs from one base domain.\"\n    icon = \"waypoints\"\n    name = \"APIRouteManager\"\n\n    # ÂÆö‰πâËæìÂÖ•\n    inputs = [\n        MessageTextInput(\n            name=\"domain\",\n            display_name=\"Base Domain\",\n            info=\"Enter the host, e.g. http://127.0.0.1:8000\",\n            value=\"http://127.0.0.1:8000\",\n            tool_mode=True,\n            required=True,\n        ),\n    ]\n\n    # --- ÂÖ≥ÈîÆÈÉ®ÂàÜÔºöÂÆö‰πâ 5 ‰∏™ËæìÂá∫Á´ØÂè£ ---\n    # Ê≥®ÊÑèÔºöËøôÈáåÂÆö‰πâ‰∫Ü outputs ÂàóË°®ÔºåUI Êâç‰ºöÊòæÁ§∫ 5 ‰∏™ÁÇπ\n    outputs = [\n        Output(display_name=\"Upload API\", name=\"url_1\", method=\"build_url_1\"),\n        Output(display_name=\"Video API\", name=\"url_2\", method=\"build_url_2\"),\n        Output(display_name=\"TTS API\", name=\"url_3\", method=\"build_url_3\"),\n        Output(display_name=\"Digital man API\", name=\"url_4\", method=\"build_url_4\"),\n        Output(display_name=\"Context API\", name=\"url_5\", method=\"build_url_5\"),\n    ]\n\n    # Á°¨ÁºñÁ†ÅË∑ØÂæÑÈÖçÁΩÆ\n    PATH_1 = \"/api/v1/pptToImg/upload\"\n    PATH_2 = \"/api/v1/video/synthesize\"\n    PATH_3 = \"/api/v1/tts/synthesize\"\n    PATH_4 = \"/api/v1/virtual/generate-video\"\n    PATH_5 = \"/api/v1/pptToImg/context\"\n\n    def _combine(self, path: str) -> Message:\n        \"\"\"ÂÜÖÈÉ®Â∑•ÂÖ∑ÔºöÊãºÊé• URL\"\"\"\n        # 1. Ëé∑ÂèñËæìÂÖ•ÔºàÂ§ÑÁêÜÂèØËÉΩÊòØ Message ÂØπË±°ÁöÑÊÉÖÂÜµÔºâ\n        domain_val = self.domain\n        if hasattr(domain_val, 'text'):\n            domain_val = domain_val.text\n        \n        # 2. ÁÆÄÂçïÊ†°È™å\n        if not domain_val or not isinstance(domain_val, str):\n             return Message(text=\"Error: Invalid Domain\")\n\n        # 3. ÊãºÊé•ÈÄªËæë\n        base = domain_val.strip().rstrip(\"/\")\n        path = path.strip()\n        if not path.startswith(\"/\"):\n            path = \"/\" + path\n        \n        return Message(text=f\"{base}{path}\")\n\n    # --- ÂØπÂ∫î outputs ÂàóË°®ÁöÑ 5 ‰∏™ÊñπÊ≥ï ---\n\n    def build_url_1(self) -> Message:\n        return self._combine(self.PATH_1)\n\n    def build_url_2(self) -> Message:\n        return self._combine(self.PATH_2)\n\n    def build_url_3(self) -> Message:\n        return self._combine(self.PATH_3)\n\n    def build_url_4(self) -> Message:\n        return self._combine(self.PATH_4)\n\n    def build_url_5(self) -> Message:\n        return self._combine(self.PATH_5)"
              },
              "domain": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Base Domain",
                "dynamic": false,
                "info": "Enter the host, e.g. http://127.0.0.1:8000",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "domain",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "selected_output": "url_5",
          "showNode": true,
          "type": "APIRouteManager"
        },
        "dragging": false,
        "id": "ParserComponent-jnWWE",
        "measured": {
          "height": 232,
          "width": 320
        },
        "position": {
          "x": 13433.318147744718,
          "y": 4443.748809771922
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "APIRouteManager-45oOD",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generates 5 separate API URLs from one base domain.",
            "display_name": "API Router (5 Ports)",
            "documentation": "",
            "edited": true,
            "field_order": [
              "domain"
            ],
            "frozen": false,
            "icon": "waypoints",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Upload API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_1",
                "name": "url_1",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Video API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_2",
                "name": "url_2",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "TTS API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_3",
                "name": "url_3",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Digital man API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_4",
                "name": "url_4",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Context API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_5",
                "name": "url_5",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Message\n\nclass APIRouteManagerComponent(Component):\n    display_name = \"API Router (5 Ports)\"\n    description = \"Generates 5 separate API URLs from one base domain.\"\n    icon = \"waypoints\"\n    name = \"APIRouteManager\"\n\n    # ÂÆö‰πâËæìÂÖ•\n    inputs = [\n        MessageTextInput(\n            name=\"domain\",\n            display_name=\"Base Domain\",\n            info=\"Enter the host, e.g. http://127.0.0.1:8000\",\n            value=\"http://127.0.0.1:8000\",\n            tool_mode=True,\n            required=True,\n        ),\n    ]\n\n    # --- ÂÖ≥ÈîÆÈÉ®ÂàÜÔºöÂÆö‰πâ 5 ‰∏™ËæìÂá∫Á´ØÂè£ ---\n    # Ê≥®ÊÑèÔºöËøôÈáåÂÆö‰πâ‰∫Ü outputs ÂàóË°®ÔºåUI Êâç‰ºöÊòæÁ§∫ 5 ‰∏™ÁÇπ\n    outputs = [\n        Output(display_name=\"Upload API\", name=\"url_1\", method=\"build_url_1\"),\n        Output(display_name=\"Video API\", name=\"url_2\", method=\"build_url_2\"),\n        Output(display_name=\"TTS API\", name=\"url_3\", method=\"build_url_3\"),\n        Output(display_name=\"Digital man API\", name=\"url_4\", method=\"build_url_4\"),\n        Output(display_name=\"Context API\", name=\"url_5\", method=\"build_url_5\"),\n    ]\n\n    # Á°¨ÁºñÁ†ÅË∑ØÂæÑÈÖçÁΩÆ\n    PATH_1 = \"/api/v1/pptToImg/upload\"\n    PATH_2 = \"/api/v1/video/synthesize\"\n    PATH_3 = \"/api/v1/tts/synthesize\"\n    PATH_4 = \"/api/v1/virtual/generate-video\"\n    PATH_5 = \"/api/v1/pptToImg/context\"\n\n    def _combine(self, path: str) -> Message:\n        \"\"\"ÂÜÖÈÉ®Â∑•ÂÖ∑ÔºöÊãºÊé• URL\"\"\"\n        # 1. Ëé∑ÂèñËæìÂÖ•ÔºàÂ§ÑÁêÜÂèØËÉΩÊòØ Message ÂØπË±°ÁöÑÊÉÖÂÜµÔºâ\n        domain_val = self.domain\n        if hasattr(domain_val, 'text'):\n            domain_val = domain_val.text\n        \n        # 2. ÁÆÄÂçïÊ†°È™å\n        if not domain_val or not isinstance(domain_val, str):\n             return Message(text=\"Error: Invalid Domain\")\n\n        # 3. ÊãºÊé•ÈÄªËæë\n        base = domain_val.strip().rstrip(\"/\")\n        path = path.strip()\n        if not path.startswith(\"/\"):\n            path = \"/\" + path\n        \n        return Message(text=f\"{base}{path}\")\n\n    # --- ÂØπÂ∫î outputs ÂàóË°®ÁöÑ 5 ‰∏™ÊñπÊ≥ï ---\n\n    def build_url_1(self) -> Message:\n        return self._combine(self.PATH_1)\n\n    def build_url_2(self) -> Message:\n        return self._combine(self.PATH_2)\n\n    def build_url_3(self) -> Message:\n        return self._combine(self.PATH_3)\n\n    def build_url_4(self) -> Message:\n        return self._combine(self.PATH_4)\n\n    def build_url_5(self) -> Message:\n        return self._combine(self.PATH_5)"
              },
              "domain": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Base Domain",
                "dynamic": false,
                "info": "Enter the host, e.g. http://127.0.0.1:8000",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "domain",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "selected_output": "url_4",
          "showNode": true,
          "type": "APIRouteManager"
        },
        "dragging": false,
        "id": "APIRouteManager-45oOD",
        "measured": {
          "height": 232,
          "width": 320
        },
        "position": {
          "x": 12347.308240290968,
          "y": 4413.134261890772
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "APIRouteManager-26dEs",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generates 5 separate API URLs from one base domain.",
            "display_name": "API Router (5 Ports)",
            "documentation": "",
            "edited": true,
            "field_order": [
              "domain"
            ],
            "frozen": false,
            "icon": "waypoints",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Upload API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_1",
                "name": "url_1",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Video API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_2",
                "name": "url_2",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "TTS API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_3",
                "name": "url_3",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Digital man API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_4",
                "name": "url_4",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Context API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_5",
                "name": "url_5",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Message\n\nclass APIRouteManagerComponent(Component):\n    display_name = \"API Router (5 Ports)\"\n    description = \"Generates 5 separate API URLs from one base domain.\"\n    icon = \"waypoints\"\n    name = \"APIRouteManager\"\n\n    # ÂÆö‰πâËæìÂÖ•\n    inputs = [\n        MessageTextInput(\n            name=\"domain\",\n            display_name=\"Base Domain\",\n            info=\"Enter the host, e.g. http://127.0.0.1:8000\",\n            value=\"http://127.0.0.1:8000\",\n            tool_mode=True,\n            required=True,\n        ),\n    ]\n\n    # --- ÂÖ≥ÈîÆÈÉ®ÂàÜÔºöÂÆö‰πâ 5 ‰∏™ËæìÂá∫Á´ØÂè£ ---\n    # Ê≥®ÊÑèÔºöËøôÈáåÂÆö‰πâ‰∫Ü outputs ÂàóË°®ÔºåUI Êâç‰ºöÊòæÁ§∫ 5 ‰∏™ÁÇπ\n    outputs = [\n        Output(display_name=\"Upload API\", name=\"url_1\", method=\"build_url_1\"),\n        Output(display_name=\"Video API\", name=\"url_2\", method=\"build_url_2\"),\n        Output(display_name=\"TTS API\", name=\"url_3\", method=\"build_url_3\"),\n        Output(display_name=\"Digital man API\", name=\"url_4\", method=\"build_url_4\"),\n        Output(display_name=\"Context API\", name=\"url_5\", method=\"build_url_5\"),\n    ]\n\n    # Á°¨ÁºñÁ†ÅË∑ØÂæÑÈÖçÁΩÆ\n    PATH_1 = \"/api/v1/pptToImg/upload\"\n    PATH_2 = \"/api/v1/video/synthesize\"\n    PATH_3 = \"/api/v1/tts/synthesize\"\n    PATH_4 = \"/api/v1/virtual/generate-video\"\n    PATH_5 = \"/api/v1/pptToImg/context\"\n\n    def _combine(self, path: str) -> Message:\n        \"\"\"ÂÜÖÈÉ®Â∑•ÂÖ∑ÔºöÊãºÊé• URL\"\"\"\n        # 1. Ëé∑ÂèñËæìÂÖ•ÔºàÂ§ÑÁêÜÂèØËÉΩÊòØ Message ÂØπË±°ÁöÑÊÉÖÂÜµÔºâ\n        domain_val = self.domain\n        if hasattr(domain_val, 'text'):\n            domain_val = domain_val.text\n        \n        # 2. ÁÆÄÂçïÊ†°È™å\n        if not domain_val or not isinstance(domain_val, str):\n             return Message(text=\"Error: Invalid Domain\")\n\n        # 3. ÊãºÊé•ÈÄªËæë\n        base = domain_val.strip().rstrip(\"/\")\n        path = path.strip()\n        if not path.startswith(\"/\"):\n            path = \"/\" + path\n        \n        return Message(text=f\"{base}{path}\")\n\n    # --- ÂØπÂ∫î outputs ÂàóË°®ÁöÑ 5 ‰∏™ÊñπÊ≥ï ---\n\n    def build_url_1(self) -> Message:\n        return self._combine(self.PATH_1)\n\n    def build_url_2(self) -> Message:\n        return self._combine(self.PATH_2)\n\n    def build_url_3(self) -> Message:\n        return self._combine(self.PATH_3)\n\n    def build_url_4(self) -> Message:\n        return self._combine(self.PATH_4)\n\n    def build_url_5(self) -> Message:\n        return self._combine(self.PATH_5)"
              },
              "domain": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Base Domain",
                "dynamic": false,
                "info": "Enter the host, e.g. http://127.0.0.1:8000",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "domain",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "selected_output": "url_3",
          "showNode": true,
          "type": "APIRouteManager"
        },
        "dragging": false,
        "id": "APIRouteManager-26dEs",
        "measured": {
          "height": 232,
          "width": 320
        },
        "position": {
          "x": 11697.747539567714,
          "y": 4465.255915418387
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "APIRouteManager-H7DON",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generates 5 separate API URLs from one base domain.",
            "display_name": "API Router (5 Ports)",
            "documentation": "",
            "edited": true,
            "field_order": [
              "domain"
            ],
            "frozen": false,
            "icon": "waypoints",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Upload API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_1",
                "name": "url_1",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Video API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_2",
                "name": "url_2",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "TTS API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_3",
                "name": "url_3",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Digital man API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_4",
                "name": "url_4",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Context API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_5",
                "name": "url_5",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Message\n\nclass APIRouteManagerComponent(Component):\n    display_name = \"API Router (5 Ports)\"\n    description = \"Generates 5 separate API URLs from one base domain.\"\n    icon = \"waypoints\"\n    name = \"APIRouteManager\"\n\n    # ÂÆö‰πâËæìÂÖ•\n    inputs = [\n        MessageTextInput(\n            name=\"domain\",\n            display_name=\"Base Domain\",\n            info=\"Enter the host, e.g. http://127.0.0.1:8000\",\n            value=\"http://127.0.0.1:8000\",\n            tool_mode=True,\n            required=True,\n        ),\n    ]\n\n    # --- ÂÖ≥ÈîÆÈÉ®ÂàÜÔºöÂÆö‰πâ 5 ‰∏™ËæìÂá∫Á´ØÂè£ ---\n    # Ê≥®ÊÑèÔºöËøôÈáåÂÆö‰πâ‰∫Ü outputs ÂàóË°®ÔºåUI Êâç‰ºöÊòæÁ§∫ 5 ‰∏™ÁÇπ\n    outputs = [\n        Output(display_name=\"Upload API\", name=\"url_1\", method=\"build_url_1\"),\n        Output(display_name=\"Video API\", name=\"url_2\", method=\"build_url_2\"),\n        Output(display_name=\"TTS API\", name=\"url_3\", method=\"build_url_3\"),\n        Output(display_name=\"Digital man API\", name=\"url_4\", method=\"build_url_4\"),\n        Output(display_name=\"Context API\", name=\"url_5\", method=\"build_url_5\"),\n    ]\n\n    # Á°¨ÁºñÁ†ÅË∑ØÂæÑÈÖçÁΩÆ\n    PATH_1 = \"/api/v1/pptToImg/upload\"\n    PATH_2 = \"/api/v1/video/synthesize\"\n    PATH_3 = \"/api/v1/tts/synthesize\"\n    PATH_4 = \"/api/v1/virtual/generate-video\"\n    PATH_5 = \"/api/v1/pptToImg/context\"\n\n    def _combine(self, path: str) -> Message:\n        \"\"\"ÂÜÖÈÉ®Â∑•ÂÖ∑ÔºöÊãºÊé• URL\"\"\"\n        # 1. Ëé∑ÂèñËæìÂÖ•ÔºàÂ§ÑÁêÜÂèØËÉΩÊòØ Message ÂØπË±°ÁöÑÊÉÖÂÜµÔºâ\n        domain_val = self.domain\n        if hasattr(domain_val, 'text'):\n            domain_val = domain_val.text\n        \n        # 2. ÁÆÄÂçïÊ†°È™å\n        if not domain_val or not isinstance(domain_val, str):\n             return Message(text=\"Error: Invalid Domain\")\n\n        # 3. ÊãºÊé•ÈÄªËæë\n        base = domain_val.strip().rstrip(\"/\")\n        path = path.strip()\n        if not path.startswith(\"/\"):\n            path = \"/\" + path\n        \n        return Message(text=f\"{base}{path}\")\n\n    # --- ÂØπÂ∫î outputs ÂàóË°®ÁöÑ 5 ‰∏™ÊñπÊ≥ï ---\n\n    def build_url_1(self) -> Message:\n        return self._combine(self.PATH_1)\n\n    def build_url_2(self) -> Message:\n        return self._combine(self.PATH_2)\n\n    def build_url_3(self) -> Message:\n        return self._combine(self.PATH_3)\n\n    def build_url_4(self) -> Message:\n        return self._combine(self.PATH_4)\n\n    def build_url_5(self) -> Message:\n        return self._combine(self.PATH_5)"
              },
              "domain": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Base Domain",
                "dynamic": false,
                "info": "Enter the host, e.g. http://127.0.0.1:8000",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "domain",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "selected_output": "url_2",
          "showNode": true,
          "type": "APIRouteManager"
        },
        "dragging": false,
        "id": "APIRouteManager-H7DON",
        "measured": {
          "height": 232,
          "width": 320
        },
        "position": {
          "x": 12968.33478192868,
          "y": 5458.752249642238
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "APIRouteManager-qHxWw",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generates 5 separate API URLs from one base domain.",
            "display_name": "API Router (5 Ports)",
            "documentation": "",
            "edited": true,
            "field_order": [
              "domain"
            ],
            "frozen": false,
            "icon": "waypoints",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Upload API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_1",
                "name": "url_1",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Video API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_2",
                "name": "url_2",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "TTS API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_3",
                "name": "url_3",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Digital man API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_4",
                "name": "url_4",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Context API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_5",
                "name": "url_5",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Message\n\nclass APIRouteManagerComponent(Component):\n    display_name = \"API Router (5 Ports)\"\n    description = \"Generates 5 separate API URLs from one base domain.\"\n    icon = \"waypoints\"\n    name = \"APIRouteManager\"\n\n    # ÂÆö‰πâËæìÂÖ•\n    inputs = [\n        MessageTextInput(\n            name=\"domain\",\n            display_name=\"Base Domain\",\n            info=\"Enter the host, e.g. http://127.0.0.1:8000\",\n            value=\"http://127.0.0.1:8000\",\n            tool_mode=True,\n            required=True,\n        ),\n    ]\n\n    # --- ÂÖ≥ÈîÆÈÉ®ÂàÜÔºöÂÆö‰πâ 5 ‰∏™ËæìÂá∫Á´ØÂè£ ---\n    # Ê≥®ÊÑèÔºöËøôÈáåÂÆö‰πâ‰∫Ü outputs ÂàóË°®ÔºåUI Êâç‰ºöÊòæÁ§∫ 5 ‰∏™ÁÇπ\n    outputs = [\n        Output(display_name=\"Upload API\", name=\"url_1\", method=\"build_url_1\"),\n        Output(display_name=\"Video API\", name=\"url_2\", method=\"build_url_2\"),\n        Output(display_name=\"TTS API\", name=\"url_3\", method=\"build_url_3\"),\n        Output(display_name=\"Digital man API\", name=\"url_4\", method=\"build_url_4\"),\n        Output(display_name=\"Context API\", name=\"url_5\", method=\"build_url_5\"),\n    ]\n\n    # Á°¨ÁºñÁ†ÅË∑ØÂæÑÈÖçÁΩÆ\n    PATH_1 = \"/api/v1/pptToImg/upload\"\n    PATH_2 = \"/api/v1/video/synthesize\"\n    PATH_3 = \"/api/v1/tts/synthesize\"\n    PATH_4 = \"/api/v1/virtual/generate-video\"\n    PATH_5 = \"/api/v1/pptToImg/context\"\n\n    def _combine(self, path: str) -> Message:\n        \"\"\"ÂÜÖÈÉ®Â∑•ÂÖ∑ÔºöÊãºÊé• URL\"\"\"\n        # 1. Ëé∑ÂèñËæìÂÖ•ÔºàÂ§ÑÁêÜÂèØËÉΩÊòØ Message ÂØπË±°ÁöÑÊÉÖÂÜµÔºâ\n        domain_val = self.domain\n        if hasattr(domain_val, 'text'):\n            domain_val = domain_val.text\n        \n        # 2. ÁÆÄÂçïÊ†°È™å\n        if not domain_val or not isinstance(domain_val, str):\n             return Message(text=\"Error: Invalid Domain\")\n\n        # 3. ÊãºÊé•ÈÄªËæë\n        base = domain_val.strip().rstrip(\"/\")\n        path = path.strip()\n        if not path.startswith(\"/\"):\n            path = \"/\" + path\n        \n        return Message(text=f\"{base}{path}\")\n\n    # --- ÂØπÂ∫î outputs ÂàóË°®ÁöÑ 5 ‰∏™ÊñπÊ≥ï ---\n\n    def build_url_1(self) -> Message:\n        return self._combine(self.PATH_1)\n\n    def build_url_2(self) -> Message:\n        return self._combine(self.PATH_2)\n\n    def build_url_3(self) -> Message:\n        return self._combine(self.PATH_3)\n\n    def build_url_4(self) -> Message:\n        return self._combine(self.PATH_4)\n\n    def build_url_5(self) -> Message:\n        return self._combine(self.PATH_5)"
              },
              "domain": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Base Domain",
                "dynamic": false,
                "info": "Enter the host, e.g. http://127.0.0.1:8000",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "domain",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "selected_output": "url_1",
          "showNode": true,
          "type": "APIRouteManager"
        },
        "dragging": false,
        "id": "APIRouteManager-qHxWw",
        "measured": {
          "height": 232,
          "width": 320
        },
        "position": {
          "x": 9400.12048213944,
          "y": 4597.0306247023145
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt Template-VZz3F",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": []
            },
            "description": "Create a prompt template with dynamic variables..",
            "display_name": "HOST ENDPOINT",
            "documentation": "",
            "edited": true,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "group": null,
            "icon": "braces",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt",
                "group_outputs": false,
                "hidden": null,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": 0,
            "replacement": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"HOST ENDPOINT\"\n    description: str = \"Create a prompt template with dynamic variables..\"\n    icon = \"braces\"\n    trace_type = \"prompt\"\n    name = \"Prompt Template\"\n    priority = 0\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "http://154.40.41.212:8201"
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt Template"
        },
        "dragging": false,
        "id": "Prompt Template-VZz3F",
        "measured": {
          "height": 218,
          "width": 320
        },
        "position": {
          "x": 11463.131904859913,
          "y": 3856.233502208774
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "TextOutput-HddTz",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Sends text output via API.",
            "display_name": "Text Output",
            "documentation": "https://docs.langflow.org/components-io#text-output",
            "edited": false,
            "field_order": [
              "input_value"
            ],
            "frozen": false,
            "icon": "type",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Text",
                "group_outputs": false,
                "method": "text_response",
                "name": "text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextOutputComponent(TextComponent):\n    display_name = \"Text Output\"\n    description = \"Sends text output via API.\"\n    documentation: str = \"https://docs.langflow.org/components-io#text-output\"\n    icon = \"type\"\n    name = \"TextOutput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Text to be passed as output.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Output Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n        )\n        self.status = self.input_value\n        return message\n"
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Text to be passed as output.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "TextOutput"
        },
        "dragging": false,
        "id": "TextOutput-HddTz",
        "measured": {
          "height": 216,
          "width": 320
        },
        "position": {
          "x": 14024.725761960923,
          "y": 5990.3029242379025
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-nInK7",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep",
              "clean_data"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Clean Data",
                "dynamic": false,
                "info": "Enable to clean the data by removing empty rows and lines in each cell of the DataFrame/ Data object.",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Clean Data\",\n            info=(\n                \"Enable to clean the data by removing empty rows and lines \"\n                \"in each cell of the DataFrame/ Data object.\"\n            ),\n            value=True,\n            advanced=True,\n            required=False,\n            show=False,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = field_value == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = field_value == \"Parser\"\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{download_url}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-nInK7",
        "measured": {
          "height": 341,
          "width": 320
        },
        "position": {
          "x": 13582.127508533018,
          "y": 5932.117172937723
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "APIRouteManager-71tBG",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generates 5 separate API URLs from one base domain with an optional suffix.",
            "display_name": "API Router (5 Ports)",
            "documentation": "",
            "edited": true,
            "field_order": [
              "domain",
              "url_suffix"
            ],
            "frozen": false,
            "icon": "waypoints",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Upload API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_1",
                "name": "url_1",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Video API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_2",
                "name": "url_2",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "TTS API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_3",
                "name": "url_3",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Digital man API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_4",
                "name": "url_4",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Context API",
                "group_outputs": false,
                "hidden": null,
                "method": "build_url_5",
                "name": "url_5",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Message\n\nclass APIRouteManagerComponent(Component):\n    display_name = \"API Router (5 Ports)\"\n    description = \"Generates 5 separate API URLs from one base domain with an optional suffix.\"\n    icon = \"waypoints\"\n    name = \"APIRouteManager\"\n\n    # ÂÆö‰πâËæìÂÖ•\n    inputs = [\n        MessageTextInput(\n            name=\"domain\",\n            display_name=\"Base Domain\",\n            info=\"Enter the host, e.g. http://127.0.0.1:8000\",\n            value=\"http://127.0.0.1:8000\",\n            tool_mode=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"url_suffix\",\n            display_name=\"URL Suffix\",\n            info=\"Appended to the end. E.g. '12345' -> '/12345'\",\n            value=\"\",\n            tool_mode=True,\n            required=False, \n        ),\n    ]\n\n    # --- ÂÆö‰πâ 5 ‰∏™ËæìÂá∫Á´ØÂè£ ---\n    outputs = [\n        Output(display_name=\"Upload API\", name=\"url_1\", method=\"build_url_1\"),\n        Output(display_name=\"Video API\", name=\"url_2\", method=\"build_url_2\"),\n        Output(display_name=\"TTS API\", name=\"url_3\", method=\"build_url_3\"),\n        Output(display_name=\"Digital man API\", name=\"url_4\", method=\"build_url_4\"),\n        Output(display_name=\"Context API\", name=\"url_5\", method=\"build_url_5\"),\n    ]\n\n    # Á°¨ÁºñÁ†ÅË∑ØÂæÑÈÖçÁΩÆ\n    PATH_1 = \"/api/v1/pptToImg/upload\"\n    PATH_2 = \"/api/v1/video/synthesize\"\n    PATH_3 = \"/api/v1/tts/synthesize\"\n    PATH_4 = \"/api/v1/virtual/generate-video\"\n    PATH_5 = \"/api/v1/pptToImg/context\"\n\n    def _combine(self, path: str) -> Message:\n        \"\"\"ÂÜÖÈÉ®Â∑•ÂÖ∑ÔºöÊãºÊé• URL + Suffix\"\"\"\n        \n        # --- 1. Â§ÑÁêÜÂüüÂêç (Domain) ---\n        domain_val = self.domain\n        if hasattr(domain_val, 'text'):\n            domain_val = domain_val.text\n        \n        if not domain_val or not isinstance(domain_val, str):\n             return Message(text=\"Error: Invalid Domain\")\n\n        # ÁßªÈô§ÂüüÂêçÊú´Â∞æÁöÑ slashÔºå‰øùËØÅÂπ≤ÂáÄÁöÑÂü∫Á°ÄÈÉ®ÂàÜ\n        base = domain_val.strip().rstrip(\"/\")\n        \n        # --- 2. Â§ÑÁêÜË∑ØÂæÑ (Path) ---\n        path = path.strip()\n        if not path.startswith(\"/\"):\n            path = \"/\" + path\n        # ÁßªÈô§Ë∑ØÂæÑÊú´Â∞æÁöÑ slash (‰∏∫‰∫ÜÂêéÈù¢ÊãºÊé•ÂêéÁºÄÊó∂Áªü‰∏ÄÂ§ÑÁêÜ)\n        path = path.rstrip(\"/\")\n            \n        # --- 3. Â§ÑÁêÜÂêéÁºÄÂèÇÊï∞ (Suffix) ---\n        suffix_val = self.url_suffix\n        if hasattr(suffix_val, 'text'):\n            suffix_val = suffix_val.text\n            \n        if not suffix_val or not isinstance(suffix_val, str):\n            suffix_val = \"\"\n        \n        suffix_val = suffix_val.strip()\n\n        # „ÄêÂÖ≥ÈîÆ‰øÆÊîπ„ÄëÂ¶ÇÊûúÂêéÁºÄÊúâÂÄºÔºå‰∏î‰∏ç‰ª• / ÂºÄÂ§¥ÔºåÂº∫Âà∂Ê∑ªÂä† /\n        if suffix_val:\n            if not suffix_val.startswith(\"/\"):\n                suffix_val = \"/\" + suffix_val\n        \n        # --- 4. ÊúÄÁªàÊãºÊé• ---\n        # base (Êó†Â∞æ/) + path (ÊúâÂ§¥/ Êó†Â∞æ/) + suffix (ÊúâÂ§¥/)\n        full_url = f\"{base}{path}{suffix_val}\"\n        \n        return Message(text=full_url)\n\n    # --- ÂØπÂ∫î outputs ÂàóË°®ÁöÑ 5 ‰∏™ÊñπÊ≥ï ---\n\n    def build_url_1(self) -> Message:\n        return self._combine(self.PATH_1)\n\n    def build_url_2(self) -> Message:\n        return self._combine(self.PATH_2)\n\n    def build_url_3(self) -> Message:\n        return self._combine(self.PATH_3)\n\n    def build_url_4(self) -> Message:\n        return self._combine(self.PATH_4)\n\n    def build_url_5(self) -> Message:\n        return self._combine(self.PATH_5)"
              },
              "domain": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Base Domain",
                "dynamic": false,
                "info": "Enter the host, e.g. http://127.0.0.1:8000",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "domain",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "url_suffix": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "URL Suffix",
                "dynamic": false,
                "info": "Appended to the end. E.g. '12345' -> '/12345'",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "url_suffix",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "selected_output": "url_5",
          "showNode": true,
          "type": "APIRouteManager"
        },
        "dragging": false,
        "id": "APIRouteManager-71tBG",
        "measured": {
          "height": 314,
          "width": 320
        },
        "position": {
          "x": 11719.90945262705,
          "y": 5973.07238397837
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-GsXoJ",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Select a language from English, Chinese, or Portuguese.",
            "display_name": "Language Selector",
            "documentation": "",
            "edited": true,
            "field_order": [
              "language"
            ],
            "frozen": false,
            "icon": "languages",
            "last_updated": "2025-11-20T12:12:07.882Z",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Selected Language",
                "group_outputs": false,
                "hidden": null,
                "method": "build",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import DropdownInput, Output\nfrom langflow.schema import Message\n\nclass LanguageSelectorComponent(Component):\n    display_name = \"Language Selector\"\n    description = \"Select a language from English, Chinese, or Portuguese.\"\n    icon = \"languages\"  # ËÆæÁΩÆÂõæÊ†á‰∏∫ËØ≠Ë®ÄÁõ∏ÂÖ≥\n    name = \"LanguageSelector\"\n\n    inputs = [\n        DropdownInput(\n            name=\"language\",\n            display_name=\"Select Language\",\n            # ÈÄâÈ°π‰ΩøÁî®ÂêÑËá™ÁöÑËØ≠Ë®ÄÊòæÁ§∫\n            options=[\"English\", \"‰∏≠Êñá\", \"Portugu√™s\"],\n            value=\"English\",\n            real_time_refresh=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Selected Language\",\n            name=\"output\",\n            method=\"build\",\n        ),\n    ]\n\n    def build(self) -> Message:\n        \"\"\"\n        ËæìÂá∫ÈÄâ‰∏≠ÁöÑËØ≠Ë®ÄÊñáÊú¨„ÄÇ\n        \"\"\"\n        selection = self.language\n        \n        # Â¶ÇÊûú‰Ω†ÈúÄË¶ÅÂ∞ÜÊòæÁ§∫ÁöÑÊñáÂ≠óËΩ¨Êç¢‰∏∫ ISO ‰ª£Á†Å (‰æãÂ¶Ç: ‰∏≠Êñá -> zh-CN)Ôºå\n        # ÂèØ‰ª•ÂèñÊ∂à‰∏ãÈù¢ËøôÊÆµ‰ª£Á†ÅÁöÑÊ≥®ÈáäÔºö\n        # \n        # mapping = {\n        #     \"English\": \"en-US\",\n        #     \"‰∏≠Êñá\": \"zh-CN\",\n        #     \"Portugu√™s\": \"pt-BR\"\n        # }\n        # selection = mapping.get(selection, selection)\n\n        return Message(text=selection)"
              },
              "language": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Select Language",
                "dynamic": false,
                "external_options": {},
                "info": "",
                "name": "language",
                "options": [
                  "English",
                  "‰∏≠Êñá",
                  "Portugu√™s"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "English"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "LanguageSelector"
        },
        "dragging": false,
        "id": "ParserComponent-GsXoJ",
        "measured": {
          "height": 232,
          "width": 320
        },
        "position": {
          "x": 9730.84739835849,
          "y": 4969.2147406385175
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": -2549.2736612764606,
      "y": -1068.4137741703523,
      "zoom": 0.25
    }
  },
  "description": "Transform Static Slides into Dynamic Videos Instantly",
  "endpoint_name": null,
  "id": "d169e413-2971-4285-a6ad-4160c95b0813",
  "is_component": false,
  "last_tested_version": "1.6.4",
  "name": "AIVidFromPPT",
  "tags": []
}